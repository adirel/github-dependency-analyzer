<?xml version="1.0"?>

<!--
 !  ANT build file
 !
 !   This file describes how to build ANT in a manner that is
 !   very broadly compatible with the Stalink build system.
 !   It is just a wrapper for the "realbuild.xml" file that came with
 !   the ANT distribution. To get started you'll need to have the
 !   bootstrap version of the "ant" command found in the local "bin"
 !   directory.
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build products
 !      deinstall        -> does nothing. this package cannot be deinstalled
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> same as export
 !      export-source    -> same as export
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> install a runonly distribution into Starlink tree
 !      jars             -> creates the package jar file
 !      javadocs         -> does nothing package is distributed with a
 !                          complete set
 !      test             -> run JUnit tests
 !
 !   Authors:
 !      Peter W. Draper (19-AUG-2002)
 !
 !   Version:
 !      $Id: build.xml,v 1.9 2002/08/19 13:19:29 pwd Exp $
 !
 !-->

<project name="Build file for ANT" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directort by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="ANT"/>
  <property name="name" value="ant"/>
  <property name="version" value="1.6-2-starlink"/>

  <!-- The Java package name -->
  <property name="package.name" value="org.apache.tools.ant"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>

  <!-- Distribution directories. Although ANT is built from soource
   !   it also comes as a third-party package so these directories
   !   serve multiple purposes.-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <property name="dist.base" value="distribution"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- Webstart and jar signing properties. -->
  <property name="webstart.codebase"
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="webstart.signer" value="${user.name}"/>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>

  <!--
   !   ==============
   !   Build the code
   !   ==============
   !-->
  <target name="build"
          unless="runonly.install"
          description="-> compiles the source code">

    <ant dir="${basedir}" antfile="realbuild.xml" target="build"/>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !-->
  <target name="jars"
          unless="runonly.install"
          description="-> creates the package jar file">

    <ant dir="${basedir}" antfile="realbuild.xml" target="jars"/>
    <copy todir="${dist.lib}">
       <fileset dir="${build.dir}/lib"/>
    </copy>

  </target>

  <!-- 
   !   ==================
   !   Sign the jar files
   !   ==================
   ! 
   !   Signs the jar files in lib and the installed ant.jar file.
   !-->
  <target name="sign_jars"
          depends="jars"
          description="signs jar files, post-install">

    <!-- Sign all jar files in source directory and the installed
     !   equivalents --> 
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"
             maxmemory="128m">
      <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
      <fileset dir="${star.jar.dir}" includes="ant*.jar"/>
      <fileset dir="${star.jar.dir}" includes="xercesImpl.jar"/>
      <fileset dir="${star.jar.dir}" includes="xml-apis.jar"/>
    </signjar>

  </target>


  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   ! Except for the jar files, which need to be built from the source
   ! code, this package is in a "dist" state, but with the usual package
   ! specific directories not generally in use.
   !-->
  <target name="dist"
          depends="jars"
          unless="runonly.install"
          description="-> configures the local binary distribution">

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   ! Do this Starlink fashion.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================   !
   !-->
  <target name="export-source"
          depends="export"
          description="-> same as export target">
  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !-->
  <target name="export-runonly"
          depends="export"
          description="-> same as export target">
  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <!-- Try to get everything as retained in the CVS repository-->
    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" prefix="${name}">
         <include name="*"/>
      </zipfileset>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <!--<tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>-->

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>
    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz" 
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2" 
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.base}" />

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs a sub-set of the dist products into the standard
   ! Starlink directories. Note these are not undoable.
   !-->
  <target name="install"
          depends="prepare,dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin}"/>
    <mkdir dir="${star.lib}"/>
    <mkdir dir="${star.etc.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <copy todir="${star.bin}">
      <fileset dir="${dist.bin}"/>
    </copy>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <copy todir="${star.lib}">
      <fileset dir="${dist.lib}">
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
        <include name="**/LICENSE*"/>
      </fileset>
    </copy>

    <copy todir="${star.docs.pkg}">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </copy>

    <copy todir="${star.docs.pkg}" filtering="false">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </copy>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Do normal install, but with some dependencies off (may not
      !   be able to run javac and javadoc as could be used by a JRE) -->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
 <target name="deinstall"
          description="-> does nothing, only for compatibility">
  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  The documentation for this package is part of the original
   !  release, so nothing to do.
   !-->
  <target name="javadocs"
          description="-> does nothing">
  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          description="Run the JUnit testcases">

    <ant dir="${basedir}" antfile="realbuild.xml" target="test"/>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">

     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->
<project name="apache-ant" default="main" basedir=".">

  <!-- Give user a chance to override without editing this file
       (and without typing -D on each invocation) -->
  <property file=".ant.properties"/>
  <property file="${user.home}/.ant.properties"/>
  <property environment="env"/>


  <!--
       ===================================================================
         Set the properties that control names and versions
       ===================================================================
  -->
  <property name="Name" value="Apache Ant"/>
  <property name="name" value="ant"/>
  <!-- this is the groupId of ant in the Maven repository -->
  <property name="groupid" value="org.apache.ant"/>
  <property name="project.version" value="1.7.0"/>
  <!-- pom.version is used when doing a distribution and must match with what is checked in under src/etc/poms -->
  <property name="pom.version" value="1.7.0-SNAPSHOT"/>
  <property name="manifest-version" value="1.7.0"/>
  <property name="bootstrap.jar" value="ant-bootstrap.jar"/>

  <property name="ant.package" value="org/apache/tools/ant"/>
  <property name="taskdefs.package" value="${ant.package}/taskdefs"/>
  <property name="condition.package" value="${taskdefs.package}/condition"/>
  <property name="optional.package" value="${taskdefs.package}/optional"/>
  <property name="optional.condition.package" value="${optional.package}/condition"/>
  <property name="type.package" value="${ant.package}/types"/>
  <property name="optional.type.package" value="${type.package}/optional"/>
  <property name="apache.resolver.type.package" value="${ant.package}/types/resolver"/>
  <property name="util.package" value="${ant.package}/util"/>
  <property name="regexp.package" value="${util.package}/regexp"/>

  <property name="optional.jars.prefix" value="ant"/>
  <property name="optional.jars.whenmanifestonly" value="skip"/>

  <!--
       ===================================================================
         Set the properties that control various build options
       ===================================================================
  -->
  <property name="debug" value="true"/>
  <property name="chmod.fail" value="true"/>
  <property name="chmod.maxparallel" value="250"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="javac.target" value="1.2"/>
  <property name="javac.source" value="1.2"/>
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="off"/>
  <property name="junit.summary" value="no"/>
  <property name="test.haltonfailure" value="false"/>
  <property name="junit.forkmode" value="once"/>
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico,**/*.pdf,**/*.zip"/>

  <!--
       ===================================================================
         Set the properties related to the source tree
       ===================================================================
  -->
  <property name="src.dir" value="src"/>
  <property name="java.dir" value="${src.dir}/main"/>
  <property name="script.dir" value="${src.dir}/script"/>
  <property name="lib.dir" value="lib"/>
  <property name="docs.dir" value="docs"/>
  <property name="etc.dir" value="${src.dir}/etc"/>
  <property name="src.junit" value="${src.dir}/tests/junit"/>
  <property name="src.antunit" value="${src.dir}/tests/antunit"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>
  <property name="manifest" value="${src.dir}/etc/manifest"/>
  <property name="resource.dir" value="${src.dir}/resources"/>

  <!--
       ===================================================================
         Set the properties for the build area
       ===================================================================
  -->
  <property name="build.dir" value="build"/>
  <property name="bootstrap.dir" value="bootstrap"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.lib" value="${build.dir}/lib"/>
  <property name="build.javadocs" value="${build.dir}/javadocs"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>
  <property name="build.junit.xml" location="${build.tests}/xml"/>
  <property name="antunit.xml" location="${build.dir}/antunit/xml"/>
  <property name="antunit.reports" location="${build.dir}/antunit/reports"/>
  <property name="build.junit.reports" location="${build.tests}/reports"/>
  <property name="manifest.tmp" value="${build.dir}/optional.manifest"/>
  <!-- the absolute path -->
  <property name="build.tests.value" location="${build.tests}"/>

  <!--
       ===================================================================
         Set the paths used in the build
       ===================================================================
  -->
  <path id="classpath">
    <!-- PWD: add expected JUnit jar file, Starlink should always have this -->
      <pathelement location="../junit/src/lib/junit.jar"/>
  </path>

  <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <!--
        include the test source and test data dirs
        so that we can pick resources via getResource(AsStream)
     -->
    <pathelement location="${src.junit}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value"
    refid="tests-classpath"/>

  <!--
        ===================================================================
          Set up properties for the distribution area
        ===================================================================
   -->
  <property name="dist.name" value="apache-${name}-${project.version}"/>
  <property name="dist.base" value="distribution"/>
  <property name="dist.base.source" value="${dist.base}/source"/>
  <property name="dist.base.binaries" value="${dist.base}/binaries"/>
  <property name="dist.dir" value="dist"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>
  <property name="dist.javadocs" value="${dist.dir}/docs/manual/api"/>

  <property name="src.dist.dir" value="dist-src"/>
  <property name="src.dist.src" value="${src.dist.dir}/src"/>
  <property name="src.dist.docs" value="${src.dist.dir}/docs"/>
  <property name="src.dist.lib" value="${src.dist.dir}/lib"/>

  <property name="java-repository.dir" value="java-repository/${groupid}"/>
  <property name="java-repository.jars.dir" value="${java-repository.dir}/jars"/>
  <property name="java-repository.poms.dir" value="${java-repository.dir}/poms"/>

  <!--
       ===================================================================
         Set up selectors to be used by javac, junit and jar to exclude
         files that have dependencies that are not available
       ===================================================================
  -->
  <!-- depends on JDK version -->
  <selector id="needs.jdk1.3+">
    <or>
      <filename name="${ant.package}/taskdefs/TestProcess*"/>
      <filename name="${optional.package}/extension/**"/>
    </or>
  </selector>

  <selector id="needs.jdk1.4+">
    <or>
      <filename name="${regexp.package}/Jdk14Regexp*"/>
      <filename name="${ant.package}/types/AssertionsTest.java"/>
    </or>
  </selector>

  <selector id="needs.jdk1.5+">
    <or>
      <filename name="${taskdefs.package}/AptTest*"/>
      <filename name="${util.package}/java15/*"/>
    </or>
  </selector>

  <!-- Kaffe has some JDK 1.5 features including java.lang.Readable,
       but not all of them -->
  <selector id="not.in.kaffe">
    <or>
      <filename name="${condition.package}/IsReachable*"/>
    </or>
  </selector>

  <!-- depends on external libraries -->
  <selector id="needs.trax">
    <or>
      <filename name="${optional.package}/TraXLiaison*"/>
      <filename name="${optional.package}/XsltTest*"/>
      <filename name="${type.package}/XMLCatalogBuildFileTest*"/>
    </or>
  </selector>

  <selector id="needs.apache-resolver">
    <filename name="${apache.resolver.type.package}/**"/>
  </selector>

  <selector id="needs.junit">
    <filename name="${optional.package}/junit/**"/>
  </selector>

  <selector id="needs.apache-regexp">
    <filename name="${regexp.package}/JakartaRegexp*"/>
  </selector>

  <selector id="needs.apache-oro">
    <or>
      <filename name="${regexp.package}/JakartaOro*"/>
      <filename name="${optional.package}/perforce/*"/>
    </or>
  </selector>

  <selector id="needs.apache-bcel">
    <or>
      <filename name="${ant.package}/filters/util/JavaClassHelper*"/>
      <filename name="${util.package}/depend/bcel/*"/>
      <filename name="${optional.type.package}/depend/ClassFileSetTest*"/>
    </or>
  </selector>

  <selector id="needs.apache-log4j">
    <filename name="${ant.package}/listener/Log4jListener*"/>
  </selector>

  <selector id="needs.commons-logging">
    <filename name="${ant.package}/listener/CommonsLoggingListener*"/>
  </selector>

  <selector id="needs.apache-bsf">
    <or>
      <filename name="${util.package}/ScriptRunner.*"/>
      <filename name="${util.package}/optional/ScriptRunner*"/>
    </or>
  </selector>

  <selector id="needs.stylebook">
    <filename name="${optional.package}/StyleBook*"/>
  </selector>

  <selector id="needs.javamail">
    <or>
      <filename name="${ant.package}/taskdefs/email/MimeMailer*"/>
    </or>
  </selector>

  <selector id="needs.netrexx">
    <filename name="${optional.package}/NetRexxC*"/>
  </selector>

  <selector id="needs.weblogic.ejbc">
    <filename name="${optional.package}/ejb/Ejbc*"/>
  </selector>

  <selector id="needs.weblogic.ddcreator">
    <filename name="${optional.package}/ejb/DDCreator*"/>
  </selector>

  <selector id="needs.weblogic.server">
    <or>
      <filename name="${optional.package}/ejb/WLRun*"/>
      <filename name="${optional.package}/ejb/WLStop*"/>
    </or>
  </selector>

  <selector id="needs.commons-net">
    <or>
      <filename name="${optional.package}/net/FTP*"/>
      <filename name="${optional.package}/net/RExec*"/>
      <filename name="${optional.package}/net/TelnetTask*"/>
    </or>
  </selector>

  <selector id="needs.starteam">
    <or>
      <filename name="${optional.package}/scm/AntStarTeam*"/>
      <filename name="${optional.package}/starteam/*"/>
    </or>
  </selector>

  <selector id="needs.antlr">
    <filename name="${optional.package}/ANTLR*"/>
  </selector>

  <selector id="needs.jmf">
    <filename name="${optional.package}/sound/*"/>
  </selector>

  <selector id="needs.jai">
    <or>
      <filename name="${optional.package}/image/*"/>
      <filename name="${optional.type.package}/image/*"/>
    </or>
  </selector>

  <selector id="needs.jdepend">
    <filename name="${optional.package}/jdepend/*"/>
  </selector>

  <selector id="needs.swing">
    <filename name="${optional.package}/splash/*"/>
  </selector>

  <selector id="needs.jsch">
    <filename name="${optional.package}/ssh/*"/>
  </selector>

  <selector id="ant.launcher">
    <filename name="${ant.package}/launch/**/*"/>
  </selector>

  <patternset id="onlinetests">
    <exclude name="**/GetTest.java" if="offline"/>
  </patternset>

  <patternset id="teststhatfail">
    <!-- Property 'run.failing.tests' should force Ant to run these tests. -->
    <!-- Because the whole patternset can not be excluded, you have to add -->
    <!-- an unless-attribute on each exclude-element.                      -->
    <exclude unless="run.failing.tests" name="${optional.package}/BeanShellScriptTest.java"/>
    <exclude unless="run.failing.tests" name="${optional.package}/jdepend/JDependTest.java"/>
    <exclude unless="run.failing.tests" name="${optional.package}/DotnetTest.java"/>
    <exclude unless="run.failing.tests" name="${optional.package}/WsdlToDotnetTest.java"/>
  </patternset>

  <!--tests that need an XML Schema-supporting parser to work-->
  <selector id="needs.xmlschema">
    <or>
      <filename name="${optional.package}/SchemaValidateTest.*"/>
      <filename name="${optional.package}/XmlValidateTest.*"/>
    </or>
  </selector>

  <!--
       ===================================================================
         Set up a patternsets that matches the parts of our JUnit testsuite
         that may be useful for task developers.
       ===================================================================
  -->
  <patternset id="useful.tests">
    <include name="${ant.package}/BuildFileTest*"/>
    <include name="${regexp.package}/RegexpMatcherTest*"/>
    <include name="${regexp.package}/RegexpTest*"/>
    <include name="${optional.package}/AbstractXSLTLiaisonTest*"/>
    <include name="${ant.package}/types/AbstractFileSetTest*"/>
  </patternset>

  <!--
       ===================================================================
         Set up a patternsets that matches the parts of our site that
         should not be part of the distribution.
       ===================================================================
  -->
  <patternset id="site.excludes">
    <exclude name="bindownload.html"/>
    <exclude name="srcdownload.html"/>
    <exclude name="*.cgi"/>
  </patternset>

  <!--
       ===================================================================
         Check to see what optional dependencies are available
       ===================================================================
  -->
  <target name="check_for_optional_packages">
    <available property="jdk1.3+" classname="java.lang.StrictMath"/>
    <available property="jdk1.4+" classname="java.lang.CharSequence"/>
    <available property="jdk1.5+" classname="java.net.Proxy"/>
    <available property="jdk1.6+" classname="java.util.ServiceLoader"/>
    <available property="kaffe" classname="kaffe.util.NotImplemented"/>
    <available property="bsf.present"
      classname="org.apache.bsf.BSFManager"
      classpathref="classpath"/>
    <available property="netrexx.present"
      classname="netrexx.lang.Rexx"
      classpathref="classpath"/>
    <available property="trax.present"
      classname="javax.xml.transform.Transformer"
      classpathref="classpath"/>
    <condition property="trax.impl.present">
      <or>
        <and>
          <isset property="javax.xml.transform.TransformerFactory"/>
          <available classname="${javax.xml.transform.TransformerFactory}"
            classpathref="classpath"/>
        </and>
        <available resource="META-INF/services/javax.xml.transform.TransformerFactory"/>
      </or>
    </condition>
    <available property="apache.resolver.present"
      classname="org.apache.xml.resolver.tools.CatalogResolver"
      classpathref="classpath"/>
    <available property="xalan2.present"
      classname="org.apache.xalan.transformer.TransformerImpl"
      classpathref="classpath"/>
    <available property="ejb.ejbc.present"
      classname="weblogic.ejbc"
      classpathref="classpath"/>
    <available property="ejb.DDCreator.present"
      classname="weblogic.ejb.utils.DDCreator"
      classpathref="classpath"/>
    <available property="ejb.wls.present"
      classname="weblogic.Server"
      classpathref="classpath"/>
    <available property="junit.present"
      classname="junit.framework.TestCase"
      classpathref="classpath"/>
    <available property="antunit.present"
      classname="org.apache.ant.antunit.AntUnit"
      classpathref="classpath"/>
    <available property="commons.net.present"
      classname="org.apache.commons.net.ftp.FTPClient"
      classpathref="classpath"/>
    <available property="starteam.present"
      classname="com.starbase.util.Platform"
      classpathref="classpath"/>
    <available property="antlr.present"
      classname="antlr.Tool"
      classpathref="classpath"/>
    <available property="stylebook.present"
      classname="org.apache.stylebook.Engine"
      classpathref="classpath"/>
    <available property="apache.regexp.present"
      classname="org.apache.regexp.RE"
      classpathref="classpath"/>
    <available property="apache.oro.present"
      classname="org.apache.oro.text.regex.Perl5Matcher"
      classpathref="classpath"/>
    <available property="jmf.present"
      classname="javax.sound.sampled.Clip"
      classpathref="classpath"/>
    <available property="jai.present"
      classname="javax.media.jai.JAI"
      classpathref="classpath"/>
    <available property="jdepend.present"
      classname="jdepend.framework.JDepend"
      classpathref="classpath"/>
    <available property="log4j.present"
      classname="org.apache.log4j.Logger"
      classpathref="classpath"/>
    <available property="commons.logging.present"
      classname="org.apache.commons.logging.LogFactory"
      classpathref="classpath"/>
    <available property="xalan.envcheck"
      classname="org.apache.xalan.xslt.EnvironmentCheck"
      classpathref="classpath"/>
    <available property="which.present"
      classname="org.apache.env.Which"
      classpathref="classpath"/>

    <available property="xerces.present"
      classname="org.apache.xerces.parsers.SAXParser"
      classpathref="classpath"/>
    <available property="bcel.present"
      classname="org.apache.bcel.Constants"
      classpathref="classpath"/>

    <condition property="javamail.complete">
      <and>
        <available classname="javax.activation.DataHandler"
          classpathref="classpath"/>
        <available classname="javax.mail.Transport"
          classpathref="classpath"/>
      </and>
    </condition>

    <condition property="some.regexp.support">
      <or>
        <isset property="jdk1.4+"/>
        <isset property="apache.regexp.present"/>
        <isset property="apache.oro.present"/>
      </or>
    </condition>

    <condition property="tests.and.ant.share.classloader">
      <or>
        <equals arg1="${junit.fork}" arg2="true"/>
        <equals arg1="${build.sysclasspath}" arg2="only"/>
      </or>
    </condition>

    <condition property="sun.tools.present">
      <and>
        <available classname="sun.tools.native2ascii.Main"/>
        <available classname="com.sun.tools.javah.Main"/>
      </and>
    </condition>

    <condition property="tests.are.on.system.classpath">
      <or>
        <resourcecount count="1">
          <intersect>
            <path path="${java.class.path}" />
            <file file="${build.tests}" />
          </intersect>
        </resourcecount>
        <istrue value="${junit.fork}"/>
      </or>
    </condition>

    <echo level="verbose"> tests.are.on.system.classpath=${tests.are.on.system.classpath}</echo>

    <condition property="jasper.present">
      <and>
        <available classname="org.apache.jasper.compiler.Compiler"/>
        <available classname="org.apache.jasper.JasperException"/>
      </and>
    </condition>

    <condition property="swing.present">
      <or>
        <not>
          <isset property="kaffe"/>
        </not>
        <available classname="javax.swing.ImageIcon"
          classpathref="classpath"/>
      </or>
    </condition>

    <!-- http client needs commons logging -->
    <condition property="apache-httpclient.present">
      <and>
        <available
          classname="org.apache.commons.httpclient.HttpClient"
          classpathref="classpath"/>
        <isset property="commons.logging.present"/>
      </and>
    </condition>

    <condition property="wsdl.found">
      <or>
        <available file="wsdl" filepath="${env.PATH}"/>
        <available file="wsdl.exe" filepath="${env.PATH}"/>
        <available file="wsdl.exe" filepath="${env.Path}"/>
      </or>
    </condition>
    <echo level="verbose"> wsdl.found=${wsdl.found}</echo>
    <condition property="csc.found">
      <or>
        <available file="mcs" filepath="${env.PATH}"/>
        <available file="csc" filepath="${env.PATH}"/>
        <available file="csc.exe" filepath="${env.PATH}"/>
        <available file="csc.exe" filepath="${env.Path}"/>
      </or>
    </condition>
    <echo level="verbose"> csc.found=${csc.found}</echo>
    <condition property="dotnetapps.found">
      <and>
        <isset property="csc.found"/>
        <isset property="wsdl.found"/>
      </and>
    </condition>
    <echo level="verbose"> dotnetapps.found=${dotnetapps.found}</echo>

    <available property="rhino.present"
      classname="org.mozilla.javascript.Scriptable"
      classpathref="classpath"/>
    <available property="beanshell.present"
      classname="bsh.StringUtil"
      classpathref="classpath"/>
    <available property="xerces1.present"
      classname="org.apache.xerces.framework.XMLParser"
      classpathref="classpath"/>
    <available property="jsch.present"
      classname="com.jcraft.jsch.Session"
      classpathref="classpath"/>

    <condition property="build.compiler" value="classic">
      <not>
        <isset property="jdk1.3+"/>
      </not>
    </condition>
    <property name="build.compiler" value="modern"/>

    <!--check for XSD support in the parser-->
    <condition property="xmlschema.present">
      <or>
        <parsersupports
          feature="http://apache.org/xml/features/validation/schema"/>
        <parsersupports
          feature="http://java.sun.com/xml/jaxp/properties/schemaSource"/>
      </or>
    </condition>

  </target>


  <!--
       ===================================================================
         Prepare the build
       ===================================================================
  -->
  <target name="prepare">
    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>
    <filterchain id="ant.filters">
       <expandproperties/>
    </filterchain>
  </target>

  <!--
       ===================================================================
         Build the code
       ===================================================================
  -->
  <target name="build"
    depends="prepare, check_for_optional_packages"
    description="--> compiles the source code">
    <mkdir dir="${build.dir}"/>
    <mkdir dir="${build.classes}"/>
    <mkdir dir="${build.lib}"/>

    <javac srcdir="${java.dir}"
      destdir="${build.classes}"
      debug="${debug}"
      deprecation="${deprecation}"
      target="${javac.target}"
      source="${javac.source}"
      optimize="${optimize}">
      <classpath refid="classpath"/>

      <selector id="conditional-patterns">
        <not>
          <or>
            <selector refid="needs.jdk1.3+" unless="jdk1.3+"/>
            <selector refid="needs.jdk1.4+" unless="jdk1.4+"/>
            <selector refid="needs.jdk1.5+" unless="jdk1.5+"/>
            <selector refid="not.in.kaffe" if="kaffe"/>

            <selector refid="needs.trax" unless="trax.present"/>
            <selector refid="needs.apache-resolver" unless="apache.resolver.present"/>
            <selector refid="needs.junit" unless="junit.present"/>
            <selector refid="needs.apache-regexp"
              unless="apache.regexp.present"/>
            <selector refid="needs.apache-oro" unless="apache.oro.present"/>
            <selector refid="needs.apache-bcel" unless="bcel.present"/>
            <selector refid="needs.apache-log4j" unless="log4j.present"/>
            <selector refid="needs.commons-logging"
              unless="commons.logging.present"/>
            <selector refid="needs.apache-bsf" unless="bsf.present"/>
            <selector refid="needs.stylebook" unless="stylebook.present"/>
            <selector refid="needs.javamail" unless="javamail.complete"/>
            <selector refid="needs.netrexx" unless="netrexx.present"/>
            <selector refid="needs.weblogic.ejbc" unless="ejb.ejbc.present"/>
            <selector refid="needs.weblogic.ddcreator"
              unless="ejb.DDCreator.present"/>
            <selector refid="needs.weblogic.server" unless="ejb.wls.present"/>
            <selector refid="needs.commons-net" unless="commons.net.present"/>
            <selector refid="needs.starteam" unless="starteam.present"/>
            <selector refid="needs.antlr" unless="antlr.present"/>
            <selector refid="needs.jmf" unless="jmf.present"/>
            <selector refid="needs.jai" unless="jai.present"/>
            <selector refid="needs.jdepend" unless="jdepend.present"/>
            <selector refid="needs.swing" unless="swing.present"/>
            <selector refid="needs.jsch" unless="jsch.present"/>
            <selector refid="needs.xmlschema" unless="xmlschema.present"/>
          </or>
        </not>
      </selector>
    </javac>

    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/*.properties"/>
        <include name="**/*.dtd"/>
        <include name="**/*.xml"/>
      </fileset>
      <fileset dir="${resource.dir}" />
    </copy>

    <copy todir="${build.classes}"
      overwrite="true" encoding="UTF-8">
      <fileset dir="${java.dir}">
        <include name="**/version.txt"/>
        <include name="**/defaultManifest.mf"/>
      </fileset>
      <filterchain refid="ant.filters"/>
    </copy>

    <copy todir="${build.classes}/${optional.package}/junit/xsl">
      <fileset dir="${etc.dir}">
        <include name="junit-frames.xsl"/>
        <include name="junit-noframes.xsl"/>
      </fileset>
    </copy>
  </target>

  <!--
       ===================================================================
         Create the all of the Apache Ant jars
       ===================================================================
  -->
  <target name="jars"
    depends="build"
    description="--> creates the Apache Ant jars">

    <copy todir="${build.dir}">
      <fileset dir="${basedir}">
        <include name="LICENSE"/>
        <include name="LICENSE.xerces"/>
        <include name="LICENSE.dom"/>
        <include name="LICENSE.sax"/>
        <include name="NOTICE"/>
      </fileset>
      <mapper type="glob" from="*" to="*.txt"/>
    </copy>

    <copy file="${manifest}" tofile="${manifest.tmp}"/>
    <manifest file="${manifest.tmp}">
      <section name="${optional.package}/">
        <attribute name="Extension-name"
          value="org.apache.tools.ant"/>
        <attribute name="Specification-Title"
          value="Apache Ant"/>
        <attribute name="Specification-Version"
          value="${manifest-version}"/>
        <attribute name="Specification-Vendor"
          value="Apache Software Foundation"/>
        <attribute name="Implementation-Title"
          value="org.apache.tools.ant"/>
        <attribute name="Implementation-Version"
          value="${manifest-version}"/>
        <attribute name="Implementation-Vendor"
          value="Apache Software Foundation"/>
      </section>
    </manifest>

    <jar destfile="${build.lib}/${name}-launcher.jar"
      basedir="${build.classes}"
      whenmanifestonly="fail">
      <selector refid="ant.launcher"/>
      <manifest>
        <attribute name="Main-Class" value="org.apache.tools.ant.launch.Launcher"/>
      </manifest>
    </jar>

    <jar destfile="${build.lib}/${name}.jar"
      basedir="${build.classes}"
      manifest="${manifest}"
      whenmanifestonly="fail">
      <not>
        <selector id="non-core">
          <or>
            <filename name="${optional.package}/**"/>
            <filename name="${optional.type.package}/**"/>
            <filename name="${util.package}/depend/**"/>
            <filename name="${util.package}/optional/**"/>
            <selector refid="needs.apache-log4j"/>
            <selector refid="needs.commons-logging"/>
            <selector refid="needs.apache-bcel"/>
            <selector refid="needs.apache-bsf"/>
            <selector refid="needs.apache-regexp"/>
            <selector refid="needs.apache-resolver"/>
            <selector refid="needs.apache-oro"/>
            <selector refid="needs.jdk1.4+"/>
            <selector refid="needs.jdk1.5+"/>
            <selector refid="needs.javamail"/>
            <selector refid="ant.launcher"/>
          </or>
        </selector>
      </not>
      <metainf dir="${build.dir}">
        <include name="LICENSE.txt"/>
        <include name="NOTICE.txt"/>
      </metainf>

      <manifest>
        <section name="${ant.package}/">
          <attribute name="Extension-name"
            value="org.apache.tools.ant"/>
          <attribute name="Specification-Title"
            value="Apache Ant"/>
          <attribute name="Specification-Version"
            value="${manifest-version}"/>
          <attribute name="Specification-Vendor"
            value="Apache Software Foundation"/>
          <attribute name="Implementation-Title"
            value="org.apache.tools.ant"/>
          <attribute name="Implementation-Version"
            value="${manifest-version}"/>
          <attribute name="Implementation-Vendor"
            value="Apache Software Foundation"/>
        </section>
      </manifest>

      <fileset dir="${docs.dir}">
        <include name="images/ant_logo_large.gif"/>
      </fileset>
    </jar>

    <jar destfile="${build.lib}/${bootstrap.jar}"
      basedir="${build.classes}"
      manifest="${manifest}"
      whenmanifestonly="fail">
      <include name="${ant.package}/Main.class"/>
      <metainf dir="${build.dir}">
        <include name="LICENSE.txt"/>
        <include name="NOTICE.txt"/>
      </metainf>
      <manifest>
        <attribute name="Class-Path"
          value="ant.jar xml-apis.jar xercesImpl.jar xalan.jar"/>
      </manifest>
    </jar>

    <jar destfile="${build.lib}/ant-nodeps.jar"
      basedir="${build.classes}"
      manifest="${manifest.tmp}"
      whenmanifestonly="${optional.jars.whenmanifestonly}">
      <and>
        <selector refid="non-core"/>
        <not>
          <or>
            <selector refid="ant.launcher"/>
            <selector refid="needs.trax"/>
            <selector refid="needs.apache-resolver"/>
            <selector refid="needs.junit"/>
            <selector refid="needs.apache-regexp"/>
            <selector refid="needs.apache-oro"/>
            <selector refid="needs.apache-bcel"/>
            <selector refid="needs.apache-log4j"/>
            <selector refid="needs.commons-logging"/>
            <selector refid="needs.apache-bsf"/>
            <selector refid="needs.stylebook"/>
            <selector refid="needs.javamail"/>
            <selector refid="needs.netrexx"/>
            <selector refid="needs.weblogic.ejbc"/>
            <selector refid="needs.weblogic.ddcreator"/>
            <selector refid="needs.weblogic.server"/>
            <selector refid="needs.commons-net"/>
            <selector refid="needs.starteam"/>
            <selector refid="needs.antlr"/>
            <selector refid="needs.jmf"/>
            <selector refid="needs.jai"/>
            <selector refid="needs.jdepend"/>
            <selector refid="needs.swing"/>
            <selector refid="needs.jsch"/>
          </or>
        </not>
      </and>
      <metainf dir="${build.dir}">
        <include name="LICENSE.txt"/>
        <include name="NOTICE.txt"/>
      </metainf>
    </jar>

    <macrodef name="optional-jar">
      <attribute name="dep"/>
      <sequential>
        <jar destfile="${build.lib}/${optional.jars.prefix}-@{dep}.jar"
          basedir="${build.classes}"
          manifest="${manifest.tmp}"
          whenmanifestonly="${optional.jars.whenmanifestonly}">
          <selector refid="needs.@{dep}"/>
        </jar>
      </sequential>
    </macrodef>

    <optional-jar dep="trax"/>
    <optional-jar dep="apache-resolver"/>
    <optional-jar dep="junit"/>
    <optional-jar dep="apache-regexp"/>
    <optional-jar dep="apache-oro"/>
    <optional-jar dep="apache-bcel"/>
    <optional-jar dep="apache-log4j"/>
    <optional-jar dep="commons-logging"/>
    <optional-jar dep="apache-bsf"/>
    <optional-jar dep="stylebook"/>
    <optional-jar dep="javamail"/>
    <optional-jar dep="netrexx"/>
    <optional-jar dep="commons-net"/>
    <optional-jar dep="starteam"/>
    <optional-jar dep="antlr"/>
    <optional-jar dep="jmf"/>
    <optional-jar dep="jai"/>
    <optional-jar dep="swing"/>
    <optional-jar dep="jsch"/>
    <optional-jar dep="jdepend"/>

    <jar destfile="${build.lib}/${optional.jars.prefix}-weblogic.jar"
      basedir="${build.classes}"
      manifest="${manifest.tmp}"
      whenmanifestonly="${optional.jars.whenmanifestonly}">
      <or>
        <selector refid="needs.weblogic.ejbc"/>
        <selector refid="needs.weblogic.ddcreator"/>
        <selector refid="needs.weblogic.server"/>
      </or>
    </jar>

  </target>

  <!--   Creates jar of test utility classes -->
  <target name="test-jar"
    depends="compile-tests"
    description="--> creates the Apache Ant Test Utilities jar">

    <fail unless="junit.present">
      We cannot build the test jar unless JUnit is present,
      as JUnit is needed to compile the test classes.
    </fail>
    <jar destfile="${build.lib}/${name}-testutil.jar"
      basedir="${build.tests}">
      <patternset refid="useful.tests"/>
    </jar>
  </target>

  <!--
       ===================================================================
         Create the essential distribution that can run Apache Ant
       ===================================================================
  -->
  <target name="dist-lite"
    depends="jars,test-jar"
    description="--> creates a minimum distribution to run Apache Ant">

    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin}"/>
    <mkdir dir="${dist.lib}"/>

    <copy todir="${dist.lib}">
      <fileset dir="${build.lib}">
        <exclude name="${bootstrap.jar}"/>
      </fileset>
    </copy>

    <copy todir="${dist.lib}">
      <fileset dir="${lib.dir}">
        <include name="*.jar"/>
        <include name="*.zip"/>
      </fileset>
    </copy>

    <copy todir="${dist.bin}">
      <fileset dir="${script.dir}"/>
    </copy>

    <fixcrlf srcdir="${dist.bin}" eol="dos" includes="*.bat,*.cmd"/>
    <fixcrlf srcdir="${dist.bin}" eol="unix">
      <include name="ant"/>
      <include name="antRun"/>
      <include name="*.pl"/>
    </fixcrlf>

    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
      failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
      failonerror="${chmod.fail}" maxparallel="${chmod.maxparallel}"/>
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
      <fileset dir="${dist.bin}">
        <include name="**/ant"/>
        <include name="**/antRun"/>
        <include name="**/*.pl"/>
        <include name="**/*.py"/>
      </fileset>
    </chmod>

  </target>

  <!--
        ===================================================================
          Create the complete distribution
        ===================================================================
   -->
  <target name="dist" description="--> creates a complete distribution">
    <antcall inheritAll="false" target="internal_dist">
      <param name="dist.dir" value="${dist.name}"/>
    </antcall>
  </target>

  <target name="dist_javadocs" depends="javadocs">
    <mkdir dir="${dist.javadocs}"/>
    <copy todir="${dist.javadocs}" overwrite="true">
      <fileset dir="${build.javadocs}"/>
    </copy>
  </target>


  <target name="internal_dist" depends="dist-lite,dist_javadocs">
    <mkdir dir="${dist.docs}"/>
    <mkdir dir="${dist.etc}"/>

    <copy todir="${dist.lib}" file="${lib.dir}/README"/>
    <copy todir="${dist.lib}" file="${lib.dir}/libraries.properties"/>

    <copy todir="${dist.lib}">
        <fileset dir="${src.dir}/etc/poms">
            <include name="*/pom.xml"/>
        </fileset>
        <mapper type="regexp" from="^(.*)[/\\]pom.xml" to="\1-${project.version}.pom"/>
        <filterchain>
            <tokenfilter>
                <replaceregex pattern="${pom.version}" replace="${project.version}"/>
            </tokenfilter>
        </filterchain>
    </copy>
    <copy todir="${dist.lib}">
        <fileset dir="${src.dir}/etc/poms">
            <include name="pom.xml"/>
        </fileset>
        <mapper type="glob" from="pom.xml" to="ant-parent-${project.version}.pom"/>
        <filterchain>
            <tokenfilter>
                <replaceregex pattern="${pom.version}" replace="${project.version}"/>
            </tokenfilter>
        </filterchain>
    </copy>
    <checksum algorithm="md5">
        <fileset dir="${dist.lib}">
            <include name="*.pom"/>
        </fileset>
    </checksum>
    <checksum algorithm="sha1">
        <fileset dir="${dist.lib}">
            <include name="*.pom"/>
        </fileset>
    </checksum>

    <copy todir="${dist.docs}">
      <fileset dir="${docs.dir}" excludes="${unfiltered.files}">
        <patternset refid="site.excludes"/>
      </fileset>
      <filterchain refid="ant.filters"/>
    </copy>

    <copy todir="${dist.docs}" filtering="false">
      <fileset dir="${docs.dir}" includes="${unfiltered.files}">
        <patternset refid="site.excludes"/>
      </fileset>
    </copy>

    <copy todir="${dist.dir}">
      <fileset dir="${basedir}">
        <include name="README"/>
        <include name="INSTALL"/>
        <include name="LICENSE"/>
        <include name="LICENSE.xerces"/>
        <include name="LICENSE.dom"/>
        <include name="LICENSE.sax"/>
        <include name="NOTICE"/>
        <include name="TODO"/>
        <include name="WHATSNEW"/>
        <include name="KEYS"/>
        <include name="fetch.xml"/>
	<include name="get-m2.xml"/>
      </fileset>
    </copy>

    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
      failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
      failonerror="${chmod.fail}" maxparallel="${chmod.maxparallel}"/>
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
      <fileset dir="${dist.bin}">
        <include name="**/ant"/>
        <include name="**/antRun"/>
        <include name="**/*.pl"/>
        <include name="**/*.py"/>
      </fileset>
    </chmod>

    <!-- publish some useful stylesheets -->
    <copy todir="${dist.etc}">
      <fileset dir="${etc.dir}">
        <include name="junit-frames.xsl"/>
        <include name="junit-noframes.xsl"/>
        <include name="junit-frames-xalan1.xsl"/>
        <include name="coverage-frames.xsl"/>
        <include name="maudit-frames.xsl"/>
        <include name="mmetrics-frames.xsl"/>
        <include name="changelog.xsl"/>
        <include name="jdepend.xsl"/>
        <include name="jdepend-frames.xsl"/>
        <include name="checkstyle/*.xsl"/>
        <include name="log.xsl"/>
        <include name="tagdiff.xsl"/>
      </fileset>
      <fileset dir="${build.lib}">
        <include name="${bootstrap.jar}"/>
      </fileset>
    </copy>

  </target>


  <!--
       ===================================================================
         Target to create bootstrap build
       ===================================================================
  -->
  <target name="bootstrap" description="--> creates a bootstrap build">
    <antcall inheritAll="false" target="dist-lite">
      <param name="dist.dir" value="${bootstrap.dir}"/>
    </antcall>
  </target>


  <!--
       ===================================================================
         Create the source distribution
       ===================================================================
  -->
  <target name="src-dist"
    description="--> creates a source distribution">

    <mkdir dir="${src.dist.dir}"/>

    <copy todir="${src.dist.lib}">
      <fileset dir="${lib.dir}">
        <include name="*.jar"/>
        <include name="*.zip"/>
        <include name="README"/>
        <include name="libraries.properties"/>
      </fileset>
    </copy>

    <copy todir="${src.dist.src}">
      <fileset dir="${src.dir}"/>
    </copy>

    <copy todir="${src.dist.docs}">
      <fileset dir="${docs.dir}">
        <exclude name="manual/api/**"/>
        <patternset refid="site.excludes"/>
      </fileset>
    </copy>

    <copy todir="${src.dist.dir}">
      <fileset dir="${basedir}">
        <include name="README"/>
        <include name="INSTALL"/>
        <include name="LICENSE"/>
        <include name="LICENSE.xerces"/>
        <include name="LICENSE.dom"/>
        <include name="LICENSE.sax"/>
        <include name="NOTICE"/>
        <include name="TODO"/>
        <include name="WHATSNEW"/>
        <include name="KEYS"/>
        <include name="build.bat"/>
        <include name="build.sh"/>
        <include name="bootstrap.bat"/>
        <include name="bootstrap.sh"/>
        <include name="build.xml"/>
        <include name="fetch.xml"/>
	<include name="get-m2.xml"/>
      </fileset>
    </copy>

    <fixcrlf srcdir="${src.dist.dir}" eol="dos" includes="*.bat,*.cmd"/>
    <fixcrlf srcdir="${src.dist.dir}" eol="unix">
      <include name="**/*.sh"/>
      <include name="**/*.pl"/>
      <include name="**/ant"/>
      <include name="**/antRun"/>
    </fixcrlf>
    <fixcrlf srcdir="${src.dist.dir}">
      <include name="**/*.java"/>
      <exclude name="${tests.etc.dir}/taskdefs/fixcrlf/expected/Junk?.java"/>
      <exclude name="${tests.etc.dir}/taskdefs/fixcrlf/input/Junk?.java"/>
    </fixcrlf>

    <chmod perm="ugo+x" dir="${src.dist.dir}" type="dir"
      failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${src.dist.dir}" failonerror="${chmod.fail}"/>
    <chmod perm="ugo+x" failonerror="${chmod.fail}">
      <fileset dir="${src.dist.dir}">
        <include name="**/.sh"/>
        <include name="**/.pl"/>
        <include name="**/.py"/>
        <include name="**/ant"/>
        <include name="**/antRun"/>
      </fileset>
    </chmod>

  </target>

  <!--
       ===================================================================
         Create the binary distribution
       ===================================================================
  -->
  <target name="main_distribution"
    description="--> creates the zip and tar distributions">
    <delete dir="${dist.base}"/>
    <delete dir="${dist.name}"/>
    <delete dir="${java-repository.dir}"/>
    <mkdir dir="${dist.base}"/>
    <mkdir dir="${dist.base.source}"/>
    <mkdir dir="${dist.base.binaries}"/>
    <mkdir dir="${java-repository.jars.dir}"/>
    <mkdir dir="${java-repository.poms.dir}"/>
    <antcall inheritAll="false" target="internal_dist">
      <param name="dist.dir" value="${dist.name}"/>
    </antcall>
    <zip destfile="${dist.base.binaries}/${dist.name}-bin.zip">
      <zipfileset dir="${dist.name}/.." filemode="755">
        <include name="${dist.name}/bin/ant"/>
        <include name="${dist.name}/bin/antRun"/>
        <include name="${dist.name}/bin/*.pl"/>
        <include name="${dist.name}/bin/*.py"/>
      </zipfileset>
      <fileset dir="${dist.name}/..">
        <include name="${dist.name}/**"/>
        <exclude name="${dist.name}/bin/ant"/>
        <exclude name="${dist.name}/bin/antRun"/>
        <exclude name="${dist.name}/bin/*.pl"/>
        <exclude name="${dist.name}/bin/*.py"/>
      </fileset>
    </zip>
    <tar longfile="gnu"
      destfile="${dist.base.binaries}/${dist.name}-bin.tar">
      <!-- removes redundant definition of permissions, but seems to
           drop dirs (and to be slow)
      <zipfileset src="${dist.base.binaries}/${dist.name}-bin.zip"/>
      -->
      <tarfileset dir="${dist.name}/.." mode="755" username="ant" group="ant">
        <include name="${dist.name}/bin/ant"/>
        <include name="${dist.name}/bin/antRun"/>
        <include name="${dist.name}/bin/*.pl"/>
        <include name="${dist.name}/bin/*.py"/>
      </tarfileset>
      <tarfileset dir="${dist.name}/.." username="ant" group="ant">
        <include name="${dist.name}/**"/>
        <exclude name="${dist.name}/bin/ant"/>
        <exclude name="${dist.name}/bin/antRun"/>
        <exclude name="${dist.name}/bin/*.pl"/>
        <exclude name="${dist.name}/bin/*.py"/>
      </tarfileset>
    </tar>
    <gzip destfile="${dist.base.binaries}/${dist.name}-bin.tar.gz"
      src="${dist.base.binaries}/${dist.name}-bin.tar"/>
    <bzip2 destfile="${dist.base.binaries}/${dist.name}-bin.tar.bz2"
      src="${dist.base.binaries}/${dist.name}-bin.tar"/>
    <delete file="${dist.base.binaries}/${dist.name}-bin.tar"/>

    <copy todir="${java-repository.jars.dir}">
      <fileset dir="${dist.name}/lib">
        <include name="ant*.jar"/>
      </fileset>
      <mapper type="glob" from="*.jar" to="*-${project.version}.jar"/>
    </copy>
    <copy todir="${java-repository.poms.dir}">
      <fileset dir="${dist.name}/lib">
        <include name="*.pom"/>
        <include name="*.sha1"/>
        <include name="*.md5"/>
      </fileset>
      <mapper>
        <mapper type="glob" from="*.pom" to="*.pom"/>
        <mapper type="glob" from="*.pom.sha1" to="*.pom.sha1"/>
        <mapper type="glob" from="*.pom.md5" to="*.pom.md5"/>
      </mapper>
    </copy>
    <checksum fileext=".md5">
      <fileset dir="${java-repository.jars.dir}" includes="*${project.version}.jar"/>
    </checksum>
    <checksum fileext=".sha1" algorithm="SHA">
      <fileset dir="${java-repository.jars.dir}" includes="*${project.version}.jar"/>
    </checksum>
    <delete dir="${dist.name}"/>
    <checksum fileext=".md5">
      <fileset dir="${dist.base.binaries}/">
        <include name="**/*"/>
        <exclude name="**/*.asc"/>
        <exclude name="**/*.md5"/>
      </fileset>
    </checksum>
    <checksum fileext=".sha1" algorithm="SHA">
      <fileset dir="${dist.base.binaries}/">
        <include name="**/*"/>
        <exclude name="**/*.asc"/>
        <exclude name="**/*.md5"/>
      </fileset>
    </checksum>

    <antcall inheritAll="false" target="src-dist">
      <param name="src.dist.dir" value="${dist.name}"/>
    </antcall>
    <zip destfile="${dist.base.source}/${dist.name}-src.zip">
      <zipfileset dir="${dist.name}/.." filemode="755">
        <include name="${dist.name}/bootstrap.sh"/>
        <include name="${dist.name}/build.sh"/>
      </zipfileset>
      <fileset dir="${dist.name}/..">
        <include name="${dist.name}/**"/>
        <exclude name="${dist.name}/bootstrap.sh"/>
        <exclude name="${dist.name}/build.sh"/>
      </fileset>
    </zip>
    <tar longfile="gnu"
      destfile="${dist.base.source}/${dist.name}-src.tar">
      <!--
      <zipfileset src="${dist.base.source}/${dist.name}-src.zip"/>
      -->
      <tarfileset dir="${dist.name}/.." mode="755" username="ant" group="ant">
        <include name="${dist.name}/bootstrap.sh"/>
        <include name="${dist.name}/build.sh"/>
      </tarfileset>
      <tarfileset dir="${dist.name}/.." username="ant" group="ant">
        <include name="${dist.name}/**"/>
        <exclude name="${dist.name}/bootstrap.sh"/>
        <exclude name="${dist.name}/build.sh"/>
      </tarfileset>
    </tar>
    <gzip destfile="${dist.base.source}/${dist.name}-src.tar.gz"
      src="${dist.base.source}/${dist.name}-src.tar"/>
    <bzip2 destfile="${dist.base.source}/${dist.name}-src.tar.bz2"
      src="${dist.base.source}/${dist.name}-src.tar"/>
    <delete file="${dist.base.source}/${dist.name}-src.tar"/>
    <delete dir="${dist.name}"/>
    <checksum fileext=".md5">
      <fileset dir="${dist.base.source}/">
        <include name="**/*"/>
        <exclude name="**/*.asc"/>
        <exclude name="**/*.md5"/>
      </fileset>
    </checksum>
    <checksum fileext=".sha1" algorithm="SHA">
      <fileset dir="${dist.base.source}/">
        <include name="**/*"/>
        <exclude name="**/*.asc"/>
        <exclude name="**/*.md5"/>
      </fileset>
    </checksum>
  </target>

  <target name="distribution" depends="main_distribution"
    description="--> creates the full Apache Ant distribution">
  </target>

  <!--
       ===================================================================
         Upload the distribution to cvs.apache.org for final releases
       ===================================================================
  -->

  <target name="init-upload" >
    <fail unless="apache.user" message="set a property apache.user with your apache user"/>
    <fail unless="ssh.passphrase" message="set a property with your ssh passphrase"/>
    <fail unless="ssh.keyfile" message="set a property with your ssh keyfile"/>
    <property name="ssh.knownhosts" location="${user.home}/.ssh/known_hosts" />
    <property name="ssh.host" value="cvs.apache.org"/>
    <property name="ssh.verbose" value="false"/>
    <property name="ssh.base.directory" value="/www/www.apache.org/dist"/>
    <property name="ssh.dist.directory" value="${ssh.base.directory}/ant"/>
    <property name="ssh.java-repository.directory" value="/www/people.apache.org/repo/m1-ibiblio-rsync-repository/ant"/>
    <echo >
      Uploading Ant version ${project.version}
      to host ${ssh.host} as ${apache.user}
      distribution to ${ssh.dist.directory}
      JAR files to ${ssh.java-repository.directory}/jars
      POM files to ${ssh.java-repository.directory}/poms
      Known hosts = ${ssh.knownhosts}
    </echo>
  </target>

  <!-- create the directories if absent-->
  <target name="ssh-mkdirs"
    depends="init-upload">
    <sshexec username="${apache.user}" host="${ssh.host}"
      keyfile="${ssh.keyfile}" passphrase="${ssh.passphrase}"
      knownhosts="${ssh.knownhosts}"
      command="mkdir -p ${ssh.dist.directory}" />
    <sshexec username="${apache.user}" host="${ssh.host}"
      keyfile="${ssh.keyfile}" passphrase="${ssh.passphrase}"
      knownhosts="${ssh.knownhosts}"
      command="mkdir -p ${ssh.java-repository.directory}/jars"/>
    <sshexec username="${apache.user}" host="${ssh.host}"
      keyfile="${ssh.keyfile}" passphrase="${ssh.passphrase}"
      knownhosts="${ssh.knownhosts}"
      command="mkdir -p ${ssh.java-repository.directory}/poms"/>
  </target>

  <target name="upload" description="--> uploads the distribution"
      depends="init-upload,ssh-mkdirs">
    <scp todir="${apache.user}@${ssh.host}:${ssh.dist.directory}"
      keyfile="${ssh.keyfile}" passphrase="${ssh.passphrase}"
      knownhosts="${ssh.knownhosts}"
      verbose="${ssh.verbose}" >
      <fileset dir="${dist.base}">
        <include name="**/*${project.version}*"/>
      </fileset>
     </scp>
    <scp todir="${apache.user}@${ssh.host}:${ssh.java-repository.directory}"
      keyfile="${ssh.keyfile}" passphrase="${ssh.passphrase}"
      knownhosts="${ssh.knownhosts}"
      verbose="${ssh.verbose}">
      <fileset dir="java-repository/ant">
        <include name="*/*${project.version}*"/>
      </fileset>
     </scp>
  </target>

  <!--
       ===================================================================
         Cleans up build and distribution directories
       ===================================================================
  -->
  <target name="clean"
    description="--> cleans up build and dist directories">
    <delete dir="${build.dir}"/>
    <delete dir="${dist.base}"/>
    <delete dir="${dist.dir}"/>
    <delete>
      <fileset dir="." includes="**/*~" defaultexcludes="no"/>
    </delete>
  </target>

  <!--
       ===================================================================
         Cleans everything
       ===================================================================
  -->
  <target name="allclean"
    depends="clean"
    description="--> cleans up everything">
    <delete file="${bootstrap.dir}/bin/antRun"/>
    <delete file="${bootstrap.dir}/bin/antRun.bat"/>
    <delete file="${bootstrap.dir}/bin/*.pl"/>
    <delete file="${bootstrap.dir}/bin/*.py"/>
  </target>

  <!--
       ===================================================================
         Installs Apache Ant
       ===================================================================
  -->
  <target name="install" if="ant.install">
    <antcall inheritAll="false" target="internal_dist">
      <param name="dist.dir" value="${ant.install}"/>
    </antcall>
  </target>

  <target name="install-lite" if="ant.install">
    <antcall inheritAll="false" target="dist-lite">
      <param name="dist.dir" value="${ant.install}"/>
    </antcall>
  </target>

  <!--
       ===================================================================
         Creates the API documentation
       ===================================================================
  -->
  <target name="javadoc_check">
    <uptodate property="javadoc.notrequired"
      targetfile="${build.javadocs}/packages.html">
      <srcfiles dir="${java.dir}" includes="**/*.java"/>
    </uptodate>
    <uptodate property="tests.javadoc.notrequired"
      targetfile="${build.tests.javadocs}/packages.html">
      <srcfiles dir="${src.junit}">
        <patternset refid="useful.tests"/>
      </srcfiles>
    </uptodate>
  </target>

  <target name="javadocs" depends="prepare, javadoc_check"
    unless="javadoc.notrequired"
    description="--> creates the API documentation">
    <mkdir dir="${build.javadocs}"/>
    <javadoc useexternalfile="yes"
      destdir="${build.javadocs}"
      author="true"
      version="true"
      locale="en"
      windowtitle="${Name} API"
      doctitle="${Name}"
      verbose="${javadoc.verbose}">

      <packageset dir="${java.dir}"/>

      <!-- hide some meta information for javadoc -->
      <tag name="todo" description="To do:" scope="all"/>
      <tag name="ant.task" enabled="false" description="Task:" scope="types"/>
      <tag name="ant.datatype" enabled="false" description="Data type:" scope="types"/>
      <tag name="ant.attribute" enabled="false" description="Attribute:" scope="types"/>
      <tag name="ant.attribute.group" enabled="false" description="Attribute group:" scope="types"/>
      <tag name="ant.element" enabled="false" description="Nested element:" scope="types"/>
      <group title="Apache Ant Core" packages="org.apache.tools.ant*"/>
      <group title="Core Tasks" packages="org.apache.tools.ant.taskdefs*"/>
      <group title="Core Types" packages="org.apache.tools.ant.types*"/>
      <group title="Optional Tasks" packages="org.apache.tools.ant.taskdefs.optional*"/>
      <group title="Optional Types" packages="org.apache.tools.ant.types.optional*"/>
      <group title="Ant Utilities" packages="org.apache.tools.ant.util*"/>

    </javadoc>
  </target>

  <target name="test-javadocs" depends="prepare, javadoc_check"
    unless="tests.javadoc.notrequired"
    description="--> creates the API documentation for test utilities">
    <mkdir dir="${build.tests.javadocs}"/>
    <javadoc useexternalfile="yes"
      destdir="${build.tests.javadocs}"
      author="true"
      version="true"
      locale="en"
      windowtitle="${Name} Test Utilities"
      doctitle="${Name}">

      <!-- hide some meta information for javadoc -->
      <tag name="pre" description="Precondition:" scope="all"/>

      <fileset dir="${src.junit}">
        <patternset refid="useful.tests"/>
      </fileset>

    </javadoc>
  </target>

  <!--
       ===================================================================
         Compile testcases
       ===================================================================
  -->
  <target name="compile-tests" depends="build" if="junit.present">
    <mkdir dir="${build.tests}"/>

    <javac srcdir="${src.junit}"
      destdir="${build.tests}"
      debug="${debug}"
      target="${javac.target}"
      source="${javac.source}"
      deprecation="${deprecation}">
      <classpath refid="tests-classpath"/>

      <selector refid="conditional-patterns"/>
    </javac>

    <!-- Used by AntlibTest.testAntlibResource: -->
    <jar jarfile="${build.tests}/org/apache/tools/ant/taskdefs/test2-antlib.jar">
      <zipfileset dir="${tests.etc.dir}" fullpath="taskdefs/test.antlib.xml">
        <include name="taskdefs/test2.antlib.xml"/>
      </zipfileset>
    </jar>
  </target>

  <target name="dump-info" depends="dump-sys-properties,run-which"/>

  <target name="dump-sys-properties" unless="which.present"
    depends="xml-check">
    <echo message="java.vm.info=${java.vm.info}"/>
    <echo message="java.vm.name=${java.vm.name}"/>
    <echo message="java.vm.vendor=${java.vm.vendor}"/>
    <echo message="java.vm.version=${java.vm.version}"/>
    <echo message="os.arch=${os.arch}"/>
    <echo message="os.name=${os.name}"/>
    <echo message="os.version=${os.version}"/>
    <echo message="file.encoding=${file.encoding}"/>
    <echo message="user.language=${user.language}"/>
  	<echo message="ant.version=${ant.version}"/>
  </target>

  <!-- helper class from Xalan2 to check for jar versioning of xml/xsl processors -->
  <target name="xml-check" depends="check_for_optional_packages"
    if="xalan.envcheck" unless="which.present">
    <java classname="org.apache.xalan.xslt.EnvironmentCheck"/>
  </target>

  <target name="run-which" depends="check_for_optional_packages"
    if="which.present">
    <java classname="org.apache.env.Which" taskname="which"/>
  </target>

  <!-- test to see if we are online or not. can take a while when we are off line, so
    setting the property is a good shortcut-->
  <target name="probe-offline">
    <condition property="offline">
      <or>
        <isset property="offline"/>
        <not>
          <http url="http://www.apache.org/"/>
        </not>
      </or>
    </condition>
    <echo level="verbose"> offline=${offline}</echo>
  </target>

  <!--
       ===================================================================
         Run testcase
       ===================================================================
  -->

  <target name="check-failed">
    <condition property="tests.failed">
      <or>
        <isset property="junit.failed" />
        <isset property="antunit.failed" />
      </or>
    </condition>
  </target>

  <target name="test" description="--> run unit tests and reports"
          depends="dump-info,junit-report,antunit-report,check-failed">
    <fail if="tests.failed">Unit tests failed;
see ${build.junit.reports} / ${antunit.reports}
    </fail>
  </target>

  <target name="run-tests" depends="dump-info,junit-tests,antunit-tests,check-failed"
          description="--> run unit tests without reports">
    <fail if="tests.failed" message="Unit tests failed" />
  </target>

  <target name="test-init" depends="probe-offline,check_for_optional_packages">
    <macrodef name="test-junit">
      <element name="junit-nested" implicit="true" />
      <sequential>
        <mkdir dir="${build.junit.xml}" />
        <property name="test.junit.vmargs" value=""/>
        <junit printsummary="${junit.summary}"
               haltonfailure="${test.haltonfailure}"
               fork="${junit.fork}"
               forkmode="${junit.forkmode}"
               failureproperty="junit.failed"
               errorproperty="junit.failed"
               filtertrace="${junit.filtertrace}">
          <sysproperty key="ant.home" value="${ant.home}"/>
          <sysproperty key="build.tests" file="${build.tests}"/>
          <sysproperty key="build.tests.value" value="${build.tests.value}"/>
          <sysproperty key="offline" value="${offline}"/>
          <sysproperty key="tests-classpath.value"
                       value="${tests-classpath.value}"/>
          <sysproperty key="root" file="${basedir}"/>
          <sysproperty key="build.compiler" value="${build.compiler}"/>
          <sysproperty key="tests.and.ant.share.classloader"
                       value="${tests.and.ant.share.classloader}"/>
          <classpath refid="tests-classpath"/>
          <formatter type="xml"/>
          <jvmarg line="${test.junit.vmargs}"/>
          <junit-nested />
        </junit>
      </sequential>
    </macrodef>

    <fail>"testcase" cannot be specified with "junit.testcase" or "antunit.testcase".
      <condition>
        <and>
          <isset property="testcase" />
          <or>
            <isset property="antunit.testcase" />
            <isset property="junit.testcase" />
          </or>
        </and>
      </condition>
    </fail>

    <condition property="antunit.testcase" value="${testcase}">
      <available file="${src.antunit}/${testcase}" />
    </condition>

    <condition property="junit.testcase" value="${testcase}">
      <available classname="${testcase}" classpathref="tests-classpath" />
    </condition>

    <fail>Cannot locate test ${testcase}
      <condition>
        <and>
          <isset property="testcase" />
          <not>
            <or>
              <isset property="antunit.testcase" />
              <isset property="junit.testcase" />
            </or>
          </not>
        </and>
      </condition>
    </fail>

    <condition property="run.junit">
      <and>
        <not><equals arg1="${testcase}" arg2="${antunit.testcase}" /></not>
        <isset property="junit.present" />
        <available file="${src.junit}" />
      </and>
    </condition>

    <condition property="junit.single">
      <and>
        <isset property="junit.testcase" />
        <isset property="run.junit" />
      </and>
    </condition>

    <condition property="junit.batch">
      <and>
        <not><isset property="junit.testcase" /></not>
        <isset property="run.junit" />
      </and>
    </condition>

    <condition property="run.antunit">
      <and>
        <not><equals arg1="${testcase}" arg2="${junit.testcase}" /></not>
        <isset property="antunit.present" />
        <available file="${src.antunit}" />
      </and>
    </condition>

    <condition property="run.antunit.report">
      <and>
        <isset property="run.antunit" />
        <isset property="trax.impl.present" />
      </and>
    </condition>

    <condition property="run.junit.report">
      <and>
        <isset property="run.junit" />
        <isset property="trax.impl.present" />
      </and>
    </condition>
  </target>

  <target name="junit-report" depends="junit-tests,junit-report-only" />

  <target name="junit-report-only" depends="test-init" if="run.junit.report">
    <mkdir dir="${build.junit.reports}" />
    <junitreport todir="${build.junit.reports}">
      <fileset dir="${build.junit.xml}">
        <include name="TEST-*.xml"/>
      </fileset>
      <report format="frames" todir="${build.junit.reports}"/>
    </junitreport>
  </target>

  <target name="junit-tests" depends="junit-batch,junit-single-test" />

  <target name="junit-batch" depends="compile-tests,test-init"
      if="junit.batch">

    <property name="junit.includes" value="**/*Test*" />
    <property name="junit.excludes" value="" />

    <test-junit>
      <formatter type="brief" usefile="false"/>

      <batchtest todir="${build.junit.xml}">
        <fileset dir="${src.junit}"
                 includes="${junit.includes}" excludes="${junit.excludes}">

          <!-- abstract classes, not testcases -->
          <exclude name="${taskdefs.package}/TaskdefsTest.java"/>
          <exclude name="${ant.package}/BuildFileTest.java"/>
          <exclude name="${regexp.package}/RegexpMatcherTest.java"/>
          <exclude name="${regexp.package}/RegexpTest.java"/>
          <exclude name="${optional.package}/AbstractXSLTLiaisonTest.java"/>
          <exclude name="${ant.package}/types/AbstractFileSetTest.java"/>
          <exclude name="${ant.package}/types/selectors/BaseSelectorTest.java"/>

          <!-- helper classes, not testcases -->
          <exclude name="org/example/**"/>
          <exclude name="${taskdefs.package}/TaskdefTest*Task.java"/>
          <exclude name="${optional.package}/junit/TestFormatter.java"/>

          <!-- interactive tests -->
          <exclude name="${taskdefs.package}/TestProcess.java"/>
          <exclude name="${optional.package}/splash/SplashScreenTest.java"/>

          <!-- only run these tests if their required libraries are
               installed -->
          <selector refid="conditional-patterns"/>

          <!-- tests excluded if the test is run in offline mode -->
          <patternset refid="onlinetests"/>

          <!-- failing tests excluded unless run.failing.tests is set -->
          <patternset refid="teststhatfail"/>

          <!-- runtime dependencies that are different from compile
               time dependencies -->
          <exclude name="${optional.package}/ReplaceRegExpTest.java"
            unless="some.regexp.support"/>
          <exclude name="${ant.package}/types/selectors/ContainsRegexpTest.java"
            unless="some.regexp.support"/>
          <exclude name="${ant.package}/types/mappers/RegexpPatternMapperTest.java"
            unless="some.regexp.support"/>

          <!-- needs BSF to work -->
          <exclude name="${optional.package}/Rhino*.java"
            unless="bsf.present"/>
          <exclude name="${optional.package}/Rhino*.java"
            unless="rhino.present"/>
          <exclude name="${optional.package}/script/*.java"
            unless="bsf.present"/>
          <exclude name="${optional.package}/script/*.java"
            unless="rhino.present"/>
          <exclude name="${optional.package}/BeanShellScriptTest.java"
            unless="bsf.present"/>
          <exclude name="${optional.package}/BeanShellScriptTest.java"
            unless="beanshell.present"/>
          <exclude name="${optional.type.package}/Script*.java"
            unless="bsf.present"/>
          <exclude name="${optional.type.package}/Script*.java"
            unless="rhino.present"/>

          <!-- fail if testcases can be loaded from the system classloader -->
          <exclude name="${ant.package}/AntClassLoaderDelegationTest.java"
            if="tests.are.on.system.classpath"/>
          <exclude name="${optional.package}/junit/JUnitClassLoaderTest.java"
            if="tests.are.on.system.classpath"/>

          <!-- these tests need to be localised before being ran???? -->
          <exclude name="${optional.package}/PvcsTest.java"/>

          <!-- These tests need a TraX implementation like xalan2 or saxon -->
          <exclude name="${optional.package}/TraXLiaisonTest.java"
            unless="trax.impl.present"/>
          <exclude name="${optional.package}/XsltTest.java"
            unless="trax.impl.present"/>
          <exclude name="${ant.package}/types/XMLCatalogBuildFileTest.java"
            unless="trax.impl.present"/>
          <exclude name="${optional.package}/junit/JUnitReportTest.java"
            unless="run.junitreport"/>
          <exclude name="${taskdefs.package}/StyleTest.java"
            unless="trax.impl.present"/>

          <!-- needs xerces to work -->
          <exclude name="${ant.package}/IncludeTest.java"
            unless="xerces1.present"/>
          <exclude name="${type.package}/selectors/ModifiedSelectorTest.java"
            unless="xerces1.present"/>

          <!-- needs resolver.jar to work -->
          <exclude name="${optional.package}/XmlValidateCatalogTest.java"
            unless="apache.resolver.present"/>

          <!-- needs jasperc -->
          <exclude name="${optional.package}/JspcTest.java"
            unless="jasper.present"/>

          <!-- misc oneoff tests -->
          <exclude name="${optional.package}/WsdlToDotnetTest.java"
            unless="dotnetapps.found"/>
          <exclude name="${optional.package}/DotnetTest.java"
            unless="dotnetapps.found"/>

          <!--  These tests only passes if testcases and Ant classes have
          been loaded by the same classloader - will throw
          IllegalAccessExceptions otherwise.  -->
          <exclude name="${taskdefs.package}/SQLExecTest.java"
            unless="tests.and.ant.share.classloader"/>
          <exclude name="${taskdefs.package}/cvslib/ChangeLogWriterTest.java"
            unless="tests.and.ant.share.classloader"/>
          <exclude name="${taskdefs.package}/cvslib/ChangeLogParserTest.java"
            unless="tests.and.ant.share.classloader"/>
          <exclude name="${optional.package}/sos/SOSTest.java"
            unless="tests.and.ant.share.classloader"/>
          <exclude name="${optional.package}/vss/MSVSSTest.java"
            unless="tests.and.ant.share.classloader"/>
          <exclude name="${optional.package}/TraXLiaisonTest.java"
            unless="tests.and.ant.share.classloader"/>
          <exclude name="${taskdefs.package}/ProcessDestroyerTest.java"
            unless="tests.and.ant.share.classloader"/>
          <exclude name="${taskdefs.package}/ProtectedJarMethodsTest.java"
            unless="tests.and.ant.share.classloader"/>

          <!-- can only run if cvs is installed on your machine
               enable by setting the property have.cvs
          -->
          <exclude name="${taskdefs.package}/AbstractCvsTaskTest.java"
            unless="have.cvs"/>

          <!-- needs a local ftp server and the entry of a user/password combination -->
          <exclude name="${optional.package}/net/FTPTest.java"/>

          <!-- test needs special setup -->
          <exclude name="${optional.package}/ssh/ScpTest.java"/>

          <!-- test fails if build/classes and ant.jar are using the same
               classloader  -->
          <exclude name="${ant.package}/util/ClasspathUtilsTest.java"
            if="tests.and.ant.share.classloader"/>
        </fileset>
      </batchtest>
    </test-junit>
  </target>

  <target name="junit-single-test" depends="compile-tests,junit-single-test-only"
    description="--> runs the single unit test at $${junit.testcase}" />

  <target name="junit-single-test-only" depends="test-init" if="junit.single"
    description="--> runs the single unit test at $${junit.testcase} (no compile)">
    <test-junit>
      <formatter type="plain" usefile="false"/>
      <test name="${junit.testcase}" todir="${build.junit.xml}"/>
    </test-junit>
  </target>

  <target name="interactive-tests" description="--> runs interactive tests"
    depends="compile-tests"
    if="jdk1.3+">
    <java classpathref="tests-classpath"
      classname="org.apache.tools.ant.taskdefs.TestProcess"
      fork="true"/>
  </target>

  <target name="antunit-tests" depends="dump-info,build,test-init"
          if="run.antunit" description="--> run the antunit tests">

    <condition property="antunit.includes" value="${antunit.testcase}"
               else="**/test.xml,**/*-test.xml">
      <isset property="antunit.testcase" />
    </condition>

    <property name="antunit.excludes" value="" />

    <mkdir dir="${antunit.xml}" />
    <au:antunit xmlns:au="antlib:org.apache.ant.antunit"
                failonerror="false" errorproperty="antunit.failed">
      <fileset dir="${src.antunit}" includes="${antunit.includes}"
               excludes="${antunit.excludes}" />
      <au:plainlistener />
      <au:xmllistener todir="${antunit.xml}" />
    </au:antunit>
  </target>

  <target name="antunit-report" depends="antunit-tests,antunit-report-only" />

  <target name="antunit-report-only" depends="test-init" if="run.antunit.report">
    <length>
      <fileset dir="${antunit.xml}" includes="TEST-*.xml" />
    </length>
    <mkdir dir="${antunit.reports}" />
    <junitreport todir="${antunit.reports}">
      <fileset dir="${antunit.xml}" includes="TEST-*.xml" />
      <report styledir="${src.antunit}" format="frames"
              todir="${antunit.reports}"/>
    </junitreport>
    <length>
      <fileset dir="${antunit.xml}" includes="TEST-*.xml" />
    </length>
  </target>

  <!--
       ===================================================================
         Main target - runs dist-lite by default
       ===================================================================
  -->
  <target name="main"
    description="--> creates a minimum distribution in ./dist"
    depends="dist-lite"/>


  <!--
       ===================================================================
         MSI target - creates an MSI installer file with the help of
                      the WiX toolset and the dotnet Antlib.
       ===================================================================
  -->
  <target name="msi"
    description="--> creates an MSI file for Ant, requires WiX and the dotnet Antlib"
    depends="internal_dist"
    xmlns:dn="antlib:org.apache.ant.dotnet">

    <property name="msi.dir" value="${build.dir}"/>
    <property name="msi.name" value="${name}-${project.version}.msi"/>
    <property name="msi.file" value="${msi.dir}/${msi.name}"/>
    <property name="wix.home" value="${user.home}/wix"/>
    <property name="wixobj.dir" value="${build.dir}/wix"/>

    <property name="dist.dir.resolved" location="${dist.dir}"/>

    <mkdir dir="${wixobj.dir}"/>

    <dn:wix target="${msi.file}"
      mode="both" wixHome="${wix.home}" wixobjDestDir="${wixobj.dir}">
      <sources dir="${etc.dir}" includes="*.wxs"/>
      <moresources dir="${dist.dir}"/>

      <candleParameter name="dist.dir" value="${dist.dir.resolved}"/>
      <candleParameter name="version" value="${manifest-version}"/>
    </dn:wix>
  </target>

</project>
<project default="all" xmlns:ac="antlib:net.sf.antcontrib">
  <description>
    This build file is designed to report the performance
    of ant from various releases.
    to use:
    * install ant-contrib.jar to ($ANT_HOME|$HOME/.ant)/lib
    * install beanshell jar and bsf jar
    * use unix (with bash) or install cygwin
    * set the env variables {whichever needs testing}
      ANT_HOME
      ANT_HOME_6_5 (the directory containing ant 1.6.5)
      ANT_HOME_6_4
      ANT_HOME_5_4
    
    * run ant
    For example:
       export ANT_HOME="c:/cygwin/home/me/svn/trunk/dist"
       export ANT_HOME_5_4="l:/apps/apache-ant-1.5.4"
       ant.bat

    TODO: more build files.
  </description>
  <property environment="env"/>

  <target name="all" depends="gen,do-times"/>

  <target name="clean">
    <delete quiet="yes" dir="build"/>
  </target>

  <macrodef name="run-ant-files">
    <attribute name="env-ant"/>
    <sequential>
      <ac:if>
        <isset property="@{env-ant}"/>
        <then>
          <ac:shellscript shell="bash">
            export ANT_HOME=${@{env-ant}}
            echo $ANT_HOME
            echo -n "--  props.xml     --: "
            $ANT_HOME/bin/ant -f build/gen/props.xml | grep time
            echo -n "-- ant-call.xml   --: "
            $ANT_HOME/bin/ant -f build/gen/ant-call.xml | grep time
          </ac:shellscript>
        </then>
      </ac:if>
    </sequential>
  </macrodef>
  
  <target name="do-times">
    <run-ant-files env-ant="env.ANT_HOME"/>
    <run-ant-files env-ant="env.ANT_HOME_6_5"/>
    <run-ant-files env-ant="env.ANT_HOME_6_2"/>
    <run-ant-files env-ant="env.ANT_HOME_5_4"/>
  </target>


  <target name="gen-dirs">
    <mkdir dir="build/gen"/>
  </target>

  <target name="avail">
    <available property="avail.props.xml"
               file="props.xml" filepath="build/gen"/>
    <available property="avail.ant-call.xml"
               file="ant-call.xml" filepath="build/gen"/>
  </target>

  <target name="gen-props" depends="gen-dirs,avail" unless="avail.props.xml">
    <script language="beanshell">
      import java.io.*;
      out = new PrintWriter(new BufferedWriter(new FileWriter(
          "build/gen/props.xml")));
      out.println("&lt;project name='props' default='props'&gt;");
      out.println("  &lt;target name='props'&gt;");
      for (int i = 0; i &lt; 20000; ++i) {
          out.println(
              "    &lt;property name='prop" + i + "' value='val'/&gt;");
      }
      out.println("  &lt;/target&gt;");
      out.println("&lt;/project&gt;");
      out.close();
      self.log("Created build/gen/props.xml");
    </script>
  </target>

  <target name="gen-ant-call" depends="gen-dirs,avail"
          unless="avail.ant-call.xml">
    <script language="beanshell">
      import java.io.*;
      out = new PrintWriter(new BufferedWriter(new FileWriter(
          "build/gen/ant-call.xml")));
      out.println("&lt;project name='ant-call' default='call'&gt;");
      out.println("  &lt;target name='me'/&gt;");
      out.println("  &lt;target name='call'&gt;");
      for (int i = 0; i &lt; 1000; ++i) {
          out.println("    &lt;antcall target='me'/&gt;");
      }
      out.println("  &lt;/target&gt;");
      out.println("&lt;/project&gt;");
      out.close();
      self.log("Created build/gen/ant-call.xml");
    </script>
  </target>

  <target name="gen" depends="gen-ant-call,gen-props"/>
</project>
<?xml version="1.0"?>
<!DOCTYPE project [
    <!ENTITY included_file SYSTEM "file:./included_file.xml">
]>

<project name="test" default="test" basedir=".">

  <target name="setup">
  </target>

  &included_file;

  <target name="test" depends="included-target">
    <echo>test target ran.</echo>
  </target>

</project>
<?xml version="1.0"?>
<!DOCTYPE project [
    <!ENTITY included_file SYSTEM "file:./included_file.xml">
]>

<project name="test" default="test" basedir=".">

  <target name="setup">
  </target>

  &included_file;

  <target name="test" depends="included-target">
    <echo>test target ran.</echo>
  </target>

</project>
<?xml version="1.0"?>
<!DOCTYPE project [
    <!ENTITY included_file SYSTEM "file:./included_file.xml">
]>

<project name="test" default="test" basedir=".">

  <target name="setup">
  </target>

  &included_file;

  extraneous_text

  <target name="test" depends="included-target">
    <echo>test target ran.</echo>
  </target>

</project>
<?xml version="1.0"?>
<!DOCTYPE project [
    <!ENTITY included_file SYSTEM "file:./included_file.xml">
]>

<project name="test" default="test" basedir=".">

  <target name="setup">
  </target>

  &included_file;

  <target name="test" depends="included-target">
    <copy file="nonexistent-file" todir="/non/existent/dir"/>
    <echo>test target ran.</echo>
  </target>

</project>
<?xml version="1.0"?>
<project default="cleanup" basedir=".">

  <target name="init">
    <mkdir dir="result" />
  </target>

  <target name="cleanup">
    <delete dir="result"/>
  </target>

  <target name="testLineContains" depends="init">
    <copy todir="result">
      <fileset dir="input">
        <include name="linecontains.test"/>
      </fileset>
      <filterchain>
        <filterreader classname="org.apache.tools.ant.filters.LineContains">
          <param type="contains" value="beta"/>
        </filterreader>
      </filterchain>
    </copy>
    <!--<fixcrlf srcdir="result" eol="lf">
      <include name="linecontains.test"/>
    </fixcrlf>-->
  </target>
  
  <target name="testNegateLineContains" depends="init">
    <copy file="input/linecontains.test"
          tofile="result/negatelinecontains.test">
      <filterchain>
        <filterreader classname="org.apache.tools.ant.filters.LineContains">
          <param type="negate" value="true"/>
          <param type="contains" value="beta"/>
        </filterreader>
      </filterchain>
    </copy>
    <fail>
      <condition>
        <not>
          <filesmatch file1="result/negatelinecontains.test"
                      file2="expected/negatelinecontains.test" />
        </not>
      </condition>
    </fail>
  </target>
  
  <target name="testEscapeUnicode" depends="init">
    <copy todir="result" encoding="UTF-8">
      <fileset dir="input">
        <include name="escapeunicode.test"/>
      </fileset>
      <filterchain>
        <escapeunicode/>
      </filterchain>
    </copy>
    <fixcrlf srcdir="result" eol="crlf">
      <include name="escapeunicode.test"/>
    </fixcrlf>
  </target>

  <target name="testStripJavaComments" depends="init">
    <copy todir="result">
      <fileset dir="input" includes="stripjavacomments.test" />
      <filterchain>
        <filterreader classname="org.apache.tools.ant.filters.StripJavaComments" />
      </filterchain>
    </copy>
  </target>

  <target name="testReplaceTokens" depends="init">
    <copy todir="result">
      <fileset dir="input" includes="replacetokens.test" />
      <filterchain>
        <replacetokens>
          <token key="foo" value=""/>
        </replacetokens>
      </filterchain>
    </copy>
  </target>

  <target name="testReplaceTokensPropertyFile" depends="init">
    <copy tofile="result/replacetokensPropertyFile.test">
      <fileset dir="input" includes="replacetokens.test" />
      <filterchain>
	<filterreader classname="org.apache.tools.ant.filters.ReplaceTokens">
          <param type="propertiesfile" value="${basedir}/input/sample.properties"/>
    	</filterreader>
      </filterchain>
    </copy>
  </target>

  <target name="testNoAddNewLine" depends="init">
    <concat destfile="result/nonl">This has no new lines</concat>
    <copy file="result/nonl" tofile="result/nonl-copyfilter">
      <filterchain><tokenfilter/></filterchain>
    </copy>
    <condition property="filterchain.files.are.same">
      <filesmatch file1="result/nonl" file2="result/nonl-copyfilter"/>
    </condition>
    <fail unless="filterchain.files.are.same">File was modified</fail>
  </target>

</project>
<?xml version="1.0"?>
<project name="fixcrlf" default="cleanup" basedir=".">
  <target name="init">
    <mkdir dir="result" />
  </target>

  <target name="cleanup">
    <delete dir="result" />
  </target>

  <macrodef name="assertequal">
    <attribute name="junk" default="" />
    <attribute name="name" default="Junk@{junk}.java" />
    <attribute name="file1" default="result/@{name}" />
    <attribute name="file2" default="expected/@{name}" />
    <sequential>
      <fail message="@{file1} and @{file2} are different">
        <condition>
          <not>
            <filesmatch file1="@{file1}" file2="@{file2}" />
          </not>
        </condition>
      </fail>
    </sequential>
  </macrodef>

  <target name="test1" depends="init">
    <fixcrlf srcdir="input" destdir="result"
             includes="Junk1.java"
             javafiles="true" tab="add" eol="crlf" eof="asis" />
    <assertequal junk="1" />
  </target>

  <target name="test2" depends="init">
    <fixcrlf srcdir="input" destdir="result"
             includes="Junk2.java"
             javafiles="true" tab="add" cr="add" eol="crlf" eof="asis" />
    <assertequal junk="2" />
  </target>

  <target name="test3" depends="init">
    <fixcrlf srcdir="input" destdir="result"
             includes="Junk3.java"
             javafiles="true" tab="remove" eol="lf" eof="asis" />
    <assertequal junk="3" />
  </target>

  <target name="test4" depends="init">
    <fixcrlf srcdir="input" destdir="result"
             includes="Junk4.java"
             javafiles="true" tab="remove" eol="lf" eof="asis" />
    <assertequal junk="4" />
  </target>

  <target name="test5" depends="init">
    <fixcrlf srcdir="input" destdir="result"
             includes="Junk5.java"
             tab="remove" eol="lf" eof="asis" />
    <assertequal junk="5" />
  </target>

  <target name="test6" depends="init">
    <fixcrlf srcdir="input" destdir="result"
             includes="Junk6.java"
             tab="add" cr="remove" eol="crlf" eof="asis" />
    <assertequal junk="6" />
  </target>

  <target name="test7" depends="init">
    <fixcrlf srcdir="input" destdir="result"
             includes="Junk7.java"
             tab="add" cr="add" eof="asis" />
    <assertequal junk="7" />
  </target>

  <target name="test8" depends="init">
    <fixcrlf srcdir="input" destdir="result"
             includes="Junk8.java"
             javafiles="true" tab="add" cr="add" eof="add" />
    <assertequal junk="8" />
  </target>

  <target name="test9" depends="init">
    <fixcrlf srcdir="input" destdir="result"
             includes="Junk9.java"
             javafiles="true" tab="remove" cr="remove" eof="remove" />
    <assertequal junk="9" />
  </target>

  <target name="testMacLines" depends="init">
    <fixcrlf srcdir="input" destdir="result"
             includes="Mac2Unix" eol="lf" />
    <assertequal name="Mac2Unix" />
  </target>

  <target name="testNoOverwrite" depends="test1">
    <touch file="result/Junk1.java" millis="0" />
    <fixcrlf srcdir="input" destdir="result"
             includes="Junk1.java" preservelastmodified="false"
             javafiles="true" tab="add" eol="crlf" eof="asis" />
    <fail message="overwrote unchanged output file">Q
      <condition>
        <not>
          <isfileselected file="result/Junk1.java">
            <date when="equal" millis="0" />
          </isfileselected>
        </not>
      </condition>
    </fail>
  </target>

  <target name="testEncoding" depends="init">
    <fixcrlf srcdir="input" destdir="result"
             includes="input.crlf.utf16"
             javafiles="false" cr="remove" encoding="UnicodeBig" />
    <assertequal file1="result/input.crlf.utf16"
                 file2="expected/input.lf.utf16" />
  </target>

  <target name="testOutputEncoding" depends="init">
    <fixcrlf srcdir="input" destdir="result"
             includes="input.crlf.utf16"
             javafiles="false" eol="lf" encoding="UnicodeBig"
             outputencoding="ascii" />
    <assertequal file1="result/input.crlf.utf16"
                 file2="expected/input.lf.ascii" />
  </target>

  <target name="testLongLines" depends="init">
    <fixcrlf srcdir="input" destdir="result"
             includes="longlines.crlf"
             javafiles="false" cr="remove" />
    <assertequal file1="result/longlines.crlf"
                 file2="expected/longlines.lf" />
  </target>

  <target name="testCrCrLfSequence-unix" depends="init">
    <fixcrlf srcdir="input" destdir="result"
             includes="crcrlf" eol="lf" />
    <assertequal file1="result/crcrlf"
                 file2="expected/crcrlf.unix" />
  </target>

  <target name="testCrCrLfSequence-dos" depends="init">
    <fixcrlf srcdir="input" destdir="result"
             includes="crcrlf" eol="crlf" />
    <assertequal file1="result/crcrlf"
                 file2="expected/crcrlf.dos" />
  </target>

  <target name="testCrCrLfSequence-mac" depends="init">
    <fixcrlf srcdir="input" destdir="result"
             includes="crcrlf" eol="cr" />
    <assertequal file1="result/crcrlf"
                 file2="expected/crcrlf.mac" />
  </target>

  <target name="testFixlastDos" depends="init">
    <fixcrlf srcdir="input" destdir="result"
             includes="fixlastfalse.lf" eol="crlf" />
    <assertequal file1="result/fixlastfalse.lf"
                 file2="expected/fixlast.dos" />
  </target>

  <target name="testFixlastFalseMac" depends="init">
    <fixcrlf srcdir="input" destdir="result"
             includes="fixlastfalse.lf" eol="cr" fixlast="false" />
    <assertequal file1="result/fixlastfalse.lf"
                 file2="expected/fixlastfalse.mac" />
  </target>

  <!-- Bugzilla Report 20840 -->
  <target name="createParentDirs" depends="init">
    <fixcrlf srcdir="." destdir="result" includes="input/Junk1.java" />
  </target>

  <target name="testFixFile" depends="init">
    <fixcrlf file="input/longlines.crlf" destdir="result" />
    <fail message="didn't create output file">
      <condition>
        <not>
          <available file="result/longlines.crlf" />
        </not>
      </condition>
    </fail>
  </target>

  <target name="testFixFileExclusive" depends="init">
    <fixcrlf file="input/longlines.crlf" srcdir="input" destdir="result"/>
  </target>

  <target name="testPreserveLastModified" depends="init">
    <fixcrlf file="input/longlines.crlf" destdir="result"
             preservelastmodified="true" />
    <fail>
      <condition>
        <not>
          <uptodate srcfile="result/longlines.crlf"
                    targetfile="input/longlines.crlf" />
        </not>
      </condition>
    </fail>

    <touch file="result/longlines.crlf" millis="0" />

    <fixcrlf file="result/longlines.crlf" destdir="result" eol="lf"
             preservelastmodified="true" />

    <fileset id="fs" file="result/longlines.crlf">
      <date when="equal" millis="0" />
    </fileset>
    <property name="fs" refid="fs" />
    <fail unless="fs" />
  </target>

  <target name="testFilter1" depends="init">
    <copy file="input/Junk1.java" todir="result" overwrite="true">
      <filterchain>
        <fixcrlf javafiles="true" tab="add"
                 eol="crlf" eof="asis" />
      </filterchain>
    </copy>
    <assertequal junk="1" />
  </target>

  <target name="testFilter2" depends="init">
    <copy file="input/Junk2.java" todir="result" overwrite="true">
      <filterchain>
        <fixcrlf javafiles="true" tab="add" cr="add" eol="crlf" eof="asis" />
      </filterchain>
    </copy>
    <assertequal junk="2" />
  </target>

  <target name="testFilter3" depends="init">
    <copy file="input/Junk3.java" todir="result" overwrite="true">
      <filterchain>
        <fixcrlf javafiles="true" tab="remove" eol="lf" eof="asis" />
      </filterchain>
    </copy>
    <assertequal junk="3" />
  </target>

  <target name="testFilter4" depends="init">
    <copy file="input/Junk4.java" todir="result" overwrite="true">
      <filterchain>
        <fixcrlf javafiles="true" tab="remove" eol="lf" eof="asis" />
      </filterchain>
    </copy>
    <assertequal junk="4" />
  </target>

  <target name="testFilter5" depends="init">
    <copy file="input/Junk5.java" todir="result" overwrite="true">
      <filterchain>
        <fixcrlf tab="remove" eol="lf" eof="asis" />
      </filterchain>
    </copy>
    <assertequal junk="5" />
  </target>

  <target name="testFilter6" depends="init">
    <copy file="input/Junk6.java" todir="result" overwrite="true">
      <filterchain>
        <fixcrlf tab="add" cr="remove" eol="crlf" eof="asis" />
      </filterchain>
    </copy>
    <assertequal junk="6" />
  </target>

  <target name="testFilter7" depends="init">
    <copy file="input/Junk7.java" todir="result" overwrite="true">
      <filterchain>
        <fixcrlf tab="add" cr="add" eof="asis" />
      </filterchain>
    </copy>
    <assertequal junk="7" />
  </target>

  <target name="testFilter8" depends="init">
    <copy file="input/Junk8.java" todir="result" overwrite="true">
      <filterchain>
        <fixcrlf javafiles="true" tab="add" cr="add" eof="add" />
      </filterchain>
    </copy>
    <assertequal junk="8" />
  </target>

  <target name="testFilter9" depends="init">
    <copy file="input/Junk9.java" todir="result" overwrite="true">
      <filterchain>
        <fixcrlf javafiles="true" tab="remove" cr="remove" eof="remove" />
      </filterchain>
    </copy>
    <assertequal junk="9" />
  </target>

  <target name="testCannotDoubleEof" depends="test8">
    <fixcrlf file="result/Junk8.java"
             javafiles="true" tab="add" cr="add" eof="add" />
    <assertequal junk="8" />
  </target>

  <target name="testTabInLiteralInComment">
    <copy file="input/tab_in_literal_in_comment" todir="result"
          overwrite="true">
      <filterchain>
        <fixcrlf javafiles="true" tab="remove" eol="lf" fixlast="false" />
      </filterchain>
    </copy>
    <assertequal name="tab_in_literal_in_comment" />
  </target>
</project>
<?xml version="1.0"?>

<!--
     Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->
<project default="no">

  <property name="out" location="output"/>
  <property name="in" location="input"/>

  <target name="no">
    <fail>For tests only</fail>
  </target>

  <target name="setUp">
    <mkdir dir="${out}"/>
  </target>

  <target name="tearDown">
    <delete dir="${out}"/>
  </target>

  <target name="compile" depends="setUp">
    <javac srcdir="${in}" destdir="${out}"/>
  </target>

  <target name="simple-compile" depends="compile">
    <javah destdir="${out}">
      <class name="org.example.Foo"/>
      <classpath>
        <pathelement location="${out}"/>
      </classpath>
    </javah>
  </target>
</project>
<?xml version="1.0"?>

<!--
     Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->
<project default="no">

  <property name="out" location="output"/>
  <property name="in" location="input"/>

  <target name="no">
    <fail>For tests only</fail>
  </target>

  <target name="setUp">
    <mkdir dir="${out}"/>
  </target>

  <target name="tearDown">
    <delete dir="${out}"/>
  </target>

  <target name="testIso8859-1" depends="setUp">
    <native2ascii encoding="ISO8859-1" dest="${out}"
                  src="${in}" includes="iso8859-1.*"/>
  </target>
</project>
    <?xml version="1.0"?>

<project name="xslt-test" basedir="." default="nothing">

  <property name="out.dir" value="out"/>


  <target name="setup">
  </target>

  <target name="teardown">
      <delete dir="${out.dir}" failonerror="false" />
  </target>
  

  <target name="testStyleIsSet">
      <xslt in="data.xml" out="${out.dir}/out.xml"/>
  </target>

  <target name="testTransferParameterSet">
      <property name="value" value="myvalue"/>
      <xslt in="data.xml" out="${out.dir}/out.xml" style="printParams.xsl">
          <param name="set" expression="${value}"/>
      </xslt>
  </target>

  <target name="testTransferParameterEmpty">
      <property name="value" value=""/>
      <xslt in="data.xml" out="${out.dir}/out.xml" style="printParams.xsl">
          <param name="empty" expression="${value}"/>
      </xslt>
  </target>

  <target name="testTransferParameterUnset">
      <xslt in="data.xml" out="${out.dir}/out.xml" style="printParams.xsl">
          <param name="undefined" expression="${value}"/>
      </xslt>
  </target>

  <target name="testTransferParameterUnsetWithIf">
      <xslt in="data.xml" out="${out.dir}/out.xml" style="printParams.xsl">
          <param name="undefined" expression="${value}" if="value" />
      </xslt>
  </target>

  <target name="testDefaultMapper">
    <property name="value" value="myvalue"/>
    <xslt style="printParams.xsl" destDir="${out.dir}" basedir=".">
      <param name="set" expression="${value}"/>
    </xslt>
  </target>

  <target name="testCustomMapper">
    <property name="value" value="myvalue"/>
    <xslt style="printParams.xsl" destDir="${out.dir}" basedir=".">
      <param name="set" expression="${value}"/>
      <mapper type="glob" from="data.*" to="out.*"/>
    </xslt>
  </target>

  <target name="testTypedMapper">
    <property name="value" value="myvalue"/>
    <xslt style="printParams.xsl" destDir="${out.dir}" basedir=".">
      <param name="set" expression="${value}"/>
      <globmapper from="data.*" to="out.*"/>
    </xslt>
  </target>

  <target name="testExplicitFileset">
    <property name="value" value="myvalue"/>
    <xslt style="printParams.xsl" destDir="${out.dir}"
          useImplicitFileset="false" basedir="..">
      <param name="set" expression="${value}"/>
      <fileset dir="."/>
    </xslt>
  </target>

  <target name="testNewerStylesheet">
      <antcall target="copyXsl">
        <param name="xsl.value" value="old-value"/>
      </antcall>
      <xslt in="data.xml" out="${out.dir}/out.xml" style="tmp.xsl"/>

      <antcall target="copyXsl">
        <param name="xsl.value" value="new-value"/>
      </antcall>
      <xslt in="data.xml" out="${out.dir}/out.xml" style="tmp.xsl"/>
      <delete file="tmp.xsl"/>
  </target>

  <target name="testDirectoryHierarchyWithDirMatching">
    <mkdir dir="${out.dir}/src/level1/"/>
    <copy file="data.xml" todir="${out.dir}/src/level1/"/>
    <xslt basedir="${out.dir}/src" destdir="${out.dir}/dest"
           style="printParams.xsl"/>
  </target>

  <target name="testDirsWithSpaces">
    <mkdir dir="${out.dir}/s rc/"/>
    <copy file="data.xml" todir="${out.dir}/s rc/"/>
    <xslt basedir="${out.dir}/s rc" destdir="${out.dir}/d est"
           style="printParams.xsl"/>
  </target>

  <target name="copyXsl" if="xsl.value">
      <copy file="testNewerStylesheet.xsl" tofile="tmp.xsl" overwrite="true">
          <filterchain><expandproperties/></filterchain>
      </copy>
  </target>

  <target name="testWithStyleAttrAndResource">
      <!-- also testing style as resources, with refid -->
      <file id="xslFile" file="printParams.xsl"/>
      <xslt in="data.xml" out="${out.dir}/out.xml" style="printParams.xsl">
        <style refid="xslFile" />
      </xslt>
  </target>

  <target name="testWithFileResource">
      <xslt in="data.xml" out="${out.dir}/out.xml">
          <style>
              <file file="printParams.xsl"/>
          </style>
          <param name="set" expression="value"/>
      </xslt>
  </target>

  <target name="testWithUrlResource">
      <makeurl file="printParams.xsl" property="printParams.xsl.url"/>
      <xslt in="data.xml" out="${out.dir}/out.xml">
          <style>
              <url url="${printParams.xsl.url}"/>
          </style>
          <param name="set" expression="value"/>
      </xslt>
  </target>

  <target name="testFilenameAndFiledirAsParam">
      <mkdir dir="${out.dir}/xml/dir"/>
      <mkdir dir="${out.dir}/out"/>
      <copy file="data.xml" tofile="${out.dir}/xml/one.xml"/>
      <copy file="data.xml" tofile="${out.dir}/xml/two.xml"/>
      <copy file="data.xml" tofile="${out.dir}/xml/three.xml"/>
      <copy file="data.xml" tofile="${out.dir}/xml/dir/four.xml"/>
      <xslt style="printFilename.xsl"
            destdir="${out.dir}/out"
            basedir="${out.dir}/xml"
            includes="**/*.xml"
            extension=".txt"

            filenameparameter="filename"
            filedirparameter="filedir"
      />
  </target>

  <target name="testFilenameAsParam">
      <mkdir dir="${out.dir}/xml/dir"/>
      <mkdir dir="${out.dir}/out"/>
      <copy file="data.xml" tofile="${out.dir}/xml/one.xml"/>
      <copy file="data.xml" tofile="${out.dir}/xml/two.xml"/>
      <copy file="data.xml" tofile="${out.dir}/xml/three.xml"/>
      <copy file="data.xml" tofile="${out.dir}/xml/dir/four.xml"/>
      <xslt style="printFilename.xsl"
            destdir="${out.dir}/out"
            basedir="${out.dir}/xml"
            includes="**/*.xml"
            extension=".txt"

            filenameparameter="filename"
      />
  </target>

  <target name="testFilenameAsParamNoSetting">
      <mkdir dir="${out.dir}/xml/dir"/>
      <mkdir dir="${out.dir}/out"/>
      <copy file="data.xml" tofile="${out.dir}/xml/one.xml"/>
      <copy file="data.xml" tofile="${out.dir}/xml/two.xml"/>
      <copy file="data.xml" tofile="${out.dir}/xml/three.xml"/>
      <copy file="data.xml" tofile="${out.dir}/xml/dir/four.xml"/>
      <xslt style="printFilename.xsl"
            destdir="${out.dir}/out"
            basedir="${out.dir}/xml"
            includes="**/*.xml"
            extension=".txt"
      /> <!-- without 'filenameparameter' to check, that the xsl:param is NOT set -->
  </target>

</project>
<project default="sort"
         xmlns:rcmp="antlib:org.apache.tools.ant.types.resources.comparators">

  <property name="dirname" value="work" />
  <property name="dir" location="${dirname}" />
  <property name="echolevel" value="debug" />

  <target name="tearDown">
    <delete dir="${dir}" />
    <delete file="${zip}" />
    <delete file="${jar}" deleteonexit="true" />
    <delete file="${file}" />
  </target>

  <target name="sortsetup" unless="sortsetup.done">
    <mkdir dir="${dir}" />

    <echo file="${dir}/b" message="yyy" />
    <echo file="${dir}/e" message="aaa" />
    <sleep seconds="2" />
    <echo file="${dir}/c" message="x" />
    <echo file="${dir}/d" message="x" />
    <sleep seconds="2" />
    <echo file="${dir}/a" message="zz" />
    <echo file="${dir}/f" message="zz" />

    <mkdir dir="${dir}/a.dir" />
    <mkdir dir="${dir}/b.dir" />
    <mkdir dir="${dir}/c.dir" />

    <macrodef name="mysort">
      <attribute name="property" />
      <attribute name="separator" default="," />
      <element name="cmp" optional="true" implicit="true" />
      <sequential>
        <pathconvert property="@{property}" pathsep="@{separator}">
          <sort>
            <fileset dir="${dir}" includes="a,b,c" />
            <cmp />
          </sort>
          <flattenmapper />
        </pathconvert>
        <echo level="${echolevel}">@{property}=${@{property}}</echo>
      </sequential>
    </macrodef>

    <property name="sortsetup.done" value="true" />
  </target>

  <target name="testsortdefault" depends="sortsetup">
    <mysort property="sortdf" />
    <fail>
      <condition>
        <not>
          <equals arg1="${sortdf}" arg2="a,b,c" />
        </not>
      </condition>
    </fail>
  </target>

  <target name="testrvdefault" depends="sortsetup">
    <mysort property="sortdf-rev">
      <rcmp:reverse />
    </mysort>
    <fail>
      <condition>
        <not>
          <equals arg1="${sortdf-rev}" arg2="c,b,a" />
        </not>
      </condition>
    </fail>
  </target>

  <target name="testname" depends="sortsetup">
    <mysort property="sortnm">
      <rcmp:name />
    </mysort>
    <fail>
      <condition>
        <not>
          <equals arg1="${sortnm}" arg2="a,b,c" />
        </not>
      </condition>
    </fail>
  </target>

  <target name="testrvname" depends="sortsetup">
    <mysort property="sortnm-rev">
      <rcmp:reverse>
        <rcmp:name />
      </rcmp:reverse>
    </mysort>
    <fail>
      <condition>
        <not>
          <equals arg1="${sortnm-rev}" arg2="c,b,a" />
        </not>
      </condition>
    </fail>
  </target>

  <target name="testdate" depends="sortsetup">
    <mysort property="sortlm">
      <rcmp:date />
    </mysort>
    <fail>
      <condition>
        <not>
          <equals arg1="${sortlm}" arg2="b,c,a" />
        </not>
      </condition>
    </fail>
  </target>

  <target name="testrvdate" depends="sortsetup">
    <mysort property="sortlm-rev">
      <rcmp:reverse>
        <rcmp:date />
      </rcmp:reverse>
    </mysort>
    <fail>
      <condition>
        <not>
          <equals arg1="${sortlm-rev}" arg2="a,c,b" />
        </not>
      </condition>
    </fail>
  </target>

  <target name="testsize" depends="sortsetup">
    <mysort property="sortsz">
      <rcmp:size />
    </mysort>
    <fail>
      <condition>
        <not>
          <equals arg1="${sortsz}" arg2="c,a,b" />
        </not>
      </condition>
    </fail>
  </target>

  <target name="testrvsize" depends="sortsetup">
    <mysort property="sortsz-rev">
      <rcmp:reverse>
        <rcmp:size />
      </rcmp:reverse>
    </mysort>
    <fail>
      <condition>
        <not>
          <equals arg1="${sortsz-rev}" arg2="b,a,c" />
        </not>
      </condition>
    </fail>
  </target>

  <target name="testcontent" depends="sortsetup">
    <mysort property="sortct">
      <rcmp:content />
    </mysort>
    <fail>
      <condition>
        <not>
          <equals arg1="${sortct}" arg2="c,b,a" />
        </not>
      </condition>
    </fail>
  </target>

  <target name="testrvcontent" depends="sortsetup">
    <mysort property="sortct-rev">
      <rcmp:reverse>
        <rcmp:content />
      </rcmp:reverse>
    </mysort>
    <fail>
      <condition>
        <not>
          <equals arg1="${sortct-rev}" arg2="a,b,c" />
        </not>
      </condition>
    </fail>
  </target>

  <target name="testexists" depends="sortsetup">
    <pathconvert property="sortex" pathsep=",">
      <sort>
        <resources>
          <file file="${dir}/a" />
          <resource name="redherring" exists="false" />
        </resources>
        <rcmp:exists />
      </sort>
      <flattenmapper />
    </pathconvert>
    <fail>
      <condition>
        <not>
          <equals arg1="${sortex}" arg2="redherring,a" />
        </not>
      </condition>
    </fail>
  </target>

  <target name="testrvexists" depends="sortsetup">
    <pathconvert property="sortex-rev" pathsep=",">
      <sort>
        <resources>
          <file file="${dir}/a" />
          <resource name="redherring" exists="false" />
        </resources>
        <rcmp:reverse>
          <rcmp:exists />
        </rcmp:reverse>
      </sort>
      <flattenmapper />
    </pathconvert>
    <fail>
      <condition>
        <not>
          <equals arg1="${sortex-rev}" arg2="a,redherring" />
        </not>
      </condition>
    </fail>
  </target>

  <target name="testtype" depends="sortsetup">
    <pathconvert property="sorttp" pathsep=",">
      <sort>
        <resources>
          <file file="${dir}/a" />
          <file file="${dir}/a.dir" />
        </resources>
        <rcmp:type />
      </sort>
      <flattenmapper />
    </pathconvert>
    <fail>
      <condition>
        <not>
          <equals arg1="${sorttp}" arg2="a,a.dir" />
        </not>
      </condition>
    </fail>
  </target>

  <target name="testrvtype" depends="sortsetup">
    <pathconvert property="sorttp-rev" pathsep=",">
      <sort>
        <resources>
          <file file="${dir}/a" />
          <file file="${dir}/a.dir" />
        </resources>
        <rcmp:reverse>
          <rcmp:type />
        </rcmp:reverse>
      </sort>
      <flattenmapper />
    </pathconvert>
    <fail>
      <condition>
        <not>
          <equals arg1="${sorttp-rev}" arg2="a.dir,a" />
        </not>
      </condition>
    </fail>
  </target>

  <target name="forwardsort"
    depends="testsortdefault,testname,testdate,testsize,testcontent,testexists,testtype" />

  <target name="reversesort"
    depends="testrvdefault,testrvname,testrvdate,testrvsize,testrvcontent,testrvexists,testrvtype" />

  <target name="testcompoundsort1" depends="sortsetup">
    <pathconvert property="sortcmp1" pathsep=",">
      <sort>
        <resources>
          <file file="${dir}/c" />
          <file file="${dir}/b.dir" />
          <file file="${dir}/a" />
          <file file="${dir}/c.dir" />
          <file file="${dir}/b" />
          <file file="${dir}/a.dir" />
        </resources>
        <rcmp:reverse>
          <rcmp:type />
        </rcmp:reverse>
        <rcmp:name />
      </sort>
      <flattenmapper />
    </pathconvert>
    <fail>
      <condition>
        <not>
          <equals arg1="${sortcmp1}" arg2="a.dir,b.dir,c.dir,a,b,c" />
        </not>
      </condition>
    </fail>
  </target>

  <target name="testcompoundsort2" depends="sortsetup">
    <pathconvert property="sortcmp2" pathsep=",">
      <sort>
        <files includes="${dir}/?" />
        <rcmp:size />
        <rcmp:content />
        <rcmp:reverse>
          <rcmp:name />
        </rcmp:reverse>
      </sort>
      <flattenmapper />
    </pathconvert>
    <fail>
      <condition>
        <not>
          <equals arg1="${sortcmp2}" arg2="d,c,f,a,e,b" />
        </not>
      </condition>
    </fail>
  </target>

  <target name="compoundsort" depends="testcompoundsort1,testcompoundsort2" />

  <target name="sort" depends="forwardsort,reversesort,compoundsort" />

</project>
<?xml version="1.0"?>

<!--
 !   ARRAY build file
 !
 !   This file describes how to build the ARRAY package from a source
 !   release. It requires Apache ANT and a Java Development Kit.
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> install a runonly distribution into Starlink tree
 !      jars             -> creates the package jar file
 !      javadocs         -> creates the API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit tests
 !
 !   Authors:
 !      Peter W. Draper (2-JUL-2002)
 !      Mark Taylor (31-JUL-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for ARRAY" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!-- The environment CLASSPATH is ignored by Ant tasks. -->
  <property name="build.sysclasspath" value="ignore"/>


  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="ARRAY"/>
  <property name="name" value="array"/>
  <property name="version" value="0.2"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.4"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.jni" location="${build.dir}/jni"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants -->
  <property name="dist.dir" value="${basedir}"/>

  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.dir}/bin/${name}"/>
  <property name="dist.lib.pkg" value="${dist.dir}/lib/${name}"/>
  <property name="dist.docs.pkg" value="${dist.dir}/docs/${name}"/>
  <property name="dist.etc.pkg" value="${dist.dir}/etc/${name}"/>
  <property name="dist.javadocs" value="${dist.dir}/docs/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally build
   !   class files in preference to installed ones (an externally
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- Util -->
    <pathelement location="${star.jar.dir}/util/util.jar"/>

  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that the
   !   building a classpath based on their manifest class-paths will
   !   not resolve all references (these may be to other third party
   !   jars, that are normally resolved using relative URLs). The way
   !   that this is resolved is simply to locate all "build/classes"
   !   directories and all jar files in the "dist" parts and just add
   !   these all to the classpath. Known third party dependencies are
   !   added after the "build/classes" directories using the
   !   "extclasspath" type, just so that they will be referred to
   !   first. If this doesn't work as expected add the additional
   !   classes/jars to the external classpath.
   !-->
  <extclasspath id="built.jarpath">

    <pathelement location="${star.build.dir}/util/lib/util/util.jar"/>

  </extclasspath>

  <path id="built.classpath">

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property 
   !   "extra.class.path" (which can be defined locally using say 
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using local, built, installed order-->
  <path id="classpath">
    <path refid="local.classpath"/>
    <path refid="built.classpath"/>
    <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath -->
  <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!-- Need Util -->
    <available property="util.present"
               classpathref="classpath"
               classname="uk.ac.starlink.util.GenericNioBuffer"/>
    <fail message="No Util available" unless="util.present"/>

    <!-- Need JUnit for testcases, not essential -->
    <condition property="testframework.present">
      <and>
        <available classpathref="tests-classpath"
                   classname="junit.framework.TestCase"/>
        <available classpathref="tests-classpath"
                   classname="uk.ac.starlink.util.TestCase"/>
      </and>
    </condition>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images) should also be copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages, build_classes"
          unless="runonly.install"
          description="-> compiles the source code">

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}" includes="[none]"/>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <!--
     !  <mkdir dir="${dist.lib.pkg}"/>
     !  <copy todir="${dist.lib.pkg}">
     !    <fileset dir="{$src.jars.dir}" includes="[none]"/>
     !  </copy>
    -->

  </target>


  <!-- Build the java class files. -->
  <target name="build_classes" depends="assemble_java">
    <mkdir dir="${build.classes}"/>
    <javac srcdir="${build.java}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

      <!-- Exclude any Java files in the source tree that should not be
       !   compiled -->
      <exclude name="**/retired_code/*"/>
      <exclude name="**/*Test*"/>
    </javac>
  </target>


  <!--
   !   Put all the java source files in the build directory.
   !   Some of these are copied direct from the source directory, some
   !   are generated by running java classes in the prep directory.
   !-->
  <target name="assemble_java">
    <condition property="java.assembled">
      <and>
        <uptodate srcfile="${src.dir}/prep/WriteConvertWorker.java"
          targetfile="${build.java}/uk/ac/starlink/array/ConvertWorker.java"/>
        <uptodate>
          <srcfiles dir="${java.dir}" includes="**/*.java"/>
          <mapper type="glob" from="*.java" to="${build.java}/*.java"/>
        </uptodate>
      </and>
    </condition>
    <antcall target="do_assemble_java"/>
  </target>


  <!-- Do the work of assembling the java sources. -->
  <target name="do_assemble_java" unless="java.assembled">

    <mkdir dir="${build.java}"/>

    <copy todir="${build.java}">
      <fileset dir="${java.dir}">
        <include name="**/*.java"/>
        <include name="**/*.html"/>
      </fileset>
    </copy>

    <mkdir dir="${build.dir}/prep"/>
    <javac srcdir="${src.dir}/prep"
           destdir="${build.dir}/prep"
           source="${source.version}">
    </javac>
    <java classname="WriteConvertWorker" 
          classpath="${build.dir}/prep"
          output="${build.java}/uk/ac/starlink/array/ConvertWorker.java"
          failonerror="yes"/>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of components are also required these should be created
   !  here too. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs).
   !  Builds a jar of the java source too.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar" basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <zip destfile="${dist.lib.pkg}/${name}_src.zip" basedir="${build.java}"/>

    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>

  </target>


  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>ARRAY API</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink ARRAY - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="array/array.jar"/>
         <!--<extension name="FITS" href="fits.jnlp"/> FITS depends on this too!-->
         <extension name="HDS" href="hds.jnlp"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =============================
   !   Create the local distribution
   !   =============================
   !
   !  Creates a local distribution in the directory "dist.dir"
   !  (usually the current directory). Installations are based on this
   !  distribution. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have source).
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> creates the local binary distribution">

    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Set permissions on contents of distribution directory -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall> 

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

    <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !
   ! For binary archives which contain platform-dependent code (e.g.
   ! shareable libraries) the operating system name is appended to
   | the archive name.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <property name="tarfile.name" value="${archive.name}.tar"/>
    <tar longfile="gnu" destfile="${tarfile.name}">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
      </tarfileset>
    </tar>

    <gzip zipfile="${star.archive.dir}/${tarfile.name}.gz" 
          src="${tarfile.name}"/>
    <bzip2 zipfile="${star.archive.dir}/${tarfile.name}.bz2"
           src="${tarfile.name}"/>
    <delete file="${tarfile.name}"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
        <include name="**/*.so"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory. 
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>


  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   =========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

    <!-- Make sure that the expected file structure exists, some
         of these files can be missing if originally empty -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Do normal install, but with many targets switched off-->
    <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   ! that were copied into place by the install target.
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}" failonerror="false"/>

  </target>


  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  The documentation is created from the Java sources. Should also
   !  extend this to include the possibility of other miscellaneous
   !  documentation (FAQs etc.).
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${build.java}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${build.java}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          depends="prepare,assemble_java"
          description="-> make source files for release API documention">
  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="testframework.present">
    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >
      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="tests-classpath"/>
    </javac>
  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="testframework.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="java.io.tmpdir" value="${build.tests}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="plain" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test*"/>
          <exclude name="uk/ac/starlink/TestCase.java"/>
        </fileset>
      </batchtest>

    </junit>
  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">
      <sysproperty key="java.io.tmpfile" value="${build.tests}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>
    </junit>
  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   ASTGUI build file
 !
 !   This file describes how to build and install ASTGUI from
 !   source and binary releases. ASTGUI is a class library
 !   (i.e. provides an API and related documentation).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for ASTGUI" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="ASTGUI"/>
  <property name="name" value="astgui"/>
  <property name="version" value="1.1"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.ast.gui"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="true"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- Other packages -->
    <pathelement location="${star.jar.dir}/jniast/jniast.jar"/>

  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">

    <pathelement location="${star.build.dir}/jniast/lib/jniast/jniast.jar"/>

  </extclasspath>

  <!-- "Local" third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, say
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <!--<fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>-->
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property
   !   "extra.class.path" (which can be defined locally using say
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath, add tests.dir and tests.etc.dir so that
   !   resources may be located there -->
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!--  JNIAST, don't use a class that loads the shareable library  -->
    <available property="jniast.present"
               classpathref="classpath"
               classname="uk.ac.starlink.ast.Grf"/>

    <fail message="No JNIAST available" unless="jniast.present"/>

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here. 
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           optimize="${optimize}">

      <classpath refid="classpath"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
      <exclude name="**/*.html"/>
      <exclude name="**/*.properties*"/>
      <exclude name="**/retired/*"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/images/*"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <!--<copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>-->

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>

  </target>


  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>ASTGUI</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink ASTGUI - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="astgui/astgui.jar"/>
         <extension name="JNIAST" href="jniast.jnlp"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <!--<mkdir dir="${dist.bin.pkg}"/>-->
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <!--<mkdir dir="${dist.etc.pkg}"/>-->

    <!-- Copy any configuration/helper scripts etc. -->
    <!--<copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>-->

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
    <!--<copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>-->

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
    <!--<chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>-->

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <!--<zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>-->
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <!--<zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>-->

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <!--<tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>-->
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <!--<tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>-->

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <!--<delete dir="${dist.bin}"/>-->
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <!--<delete dir="${dist.etc}"/>-->

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <!--<property name="star.bin" value="${star.install}/bin"/>-->
    <property name="star.lib" value="${star.install}/lib"/>
    <!--<property name="star.etc" value="${star.install}/etc"/>-->
    <property name="star.docs" value="${star.install}/docs"/>
    <!--<property name="star.bin.pkg" value="${star.bin}/${name}"/>-->
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <!--<property name="star.etc.pkg" value="${star.etc}/${name}"/>-->
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <!--<mkdir dir="${star.bin.pkg}"/>-->
    <mkdir dir="${star.lib.pkg}"/>
    <!--<mkdir dir="${star.etc.pkg}"/>-->
    <mkdir dir="${star.docs.pkg}"/>

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
    <!--<loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>-->

    <!--<chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>-->

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory-->
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <!--<mkdir dir="${dist.bin.pkg}"/>-->
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <!--<mkdir dir="${dist.etc.pkg}"/>-->

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
         <exclude name="**/images"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
          <exclude name="**/images/*"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           deprecation="${deprecation}" >

      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ===================
   !   Run JUnit testcases
   !   ===================
   !-->
  <target name="test"
          description="-> does nothing"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/JUnit*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <classpath refid="tests-classpath"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   !  =====================
   !  Run non-JUnit UI test
   !  =====================
   ! 
   ! Use this to test interaction with a UI.
   !-->
  <target name="uitest"
          depends="compile-tests"
          description="Run up main UI for testing">

    <java classname="TestPlotConfigFrame" fork="true">
      <classpath refid="tests-classpath"/>
    </java>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   AstroGrid build file
 !
 !   This file describes how to build and install AstroGrid from
 !   source and binary releases. AstroGrid is a class library
 !   (i.e. provides an API and related documentation).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for AstroGrid" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="AstroGrid"/>
  <property name="name" value="astrogrid"/>
  <property name="version" value="0.2"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.astrogrid"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.4"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Any achitecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- Table -->
    <pathelement location="${star.jar.dir}/table/table.jar"/>

    <!-- CONNECT -->
    <pathelement location="${star.jar.dir}/connect/connect.jar"/>

  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">

    <pathelement 
       location="${star.build.dir}/table/lib/table/table.jar"/>
    <pathelement
       location="${star.build.dir}/connect/lib/connect/connect.jar"/>

  </extclasspath>

  <!-- "Local" third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, say
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property
   !   "extra.class.path" (which can be defined locally using say
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath, add tests.dir and tests.etc.dir so that
   !   resources may be located there -->
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    ============
   !    Library path
   !    ============
   !    Used by test targets for locating native libraries.
   !-->
  <path id="tests-libpath.id">
    <pathelement path="${java.library.path}"/>
    <pathelement location="${star.jar.dir}/${os.arch}"/>
  </path>
  <property name="tests-libpath" refid="tests-libpath.id"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!-- Table -->
    <available property="table.present"
               classpathref="classpath"
               classname="uk.ac.starlink.table.StarTable"/>
    <fail message="No Table available" unless="table.present"/>

    <!-- CONNECT -->
    <available property="connect.present"
               classpathref="classpath"
               classname="uk.ac.starlink.connect.Connector"/>
    <fail message="No CONNECT available" unless="connect.present"/>

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here. 
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <classpath refid="classpath"/>
      <compilerarg value="-proc:none" compiler="javac1.6"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
      <exclude name="**/*.html"/>
      <exclude name="**/*.properties*"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/*.gif"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this class library.
     !   This goes into "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">

      <information>
         <title>ASTROGRID - Starlink classes for use with AstroGrid</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink ASTROGRID - Webstart edition"</description>
         <offline_allowed/>
       </information>

       <security>
          <all_permissions/>
       </security>

       <resources>
         <j2se version="1.5+"/>

         <!-- Define the main library jar file -->
         <jar href="${name}/${name}.jar"/>

         <!-- Name any extension packages we directly depend on -->
         <extension name="CONNECT" href="connect.jnlp"/>
       </resources>

       <!-- This is a component -->
       <component_desc/>

     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin.pkg}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <mkdir dir="${dist.etc.pkg}"/>

    <!-- Copy any configuration/helper scripts etc. -->
 <!--
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>
  -->

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
 <!--
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>
  -->

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
    <!-- <mkdir dir="${star.bin.pkg}"/> -->
    <mkdir dir="${star.lib.pkg}"/>
    <!-- <mkdir dir="${star.etc.pkg}"/> -->
    <mkdir dir="${star.docs.pkg}"/>

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

<!--
    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>
    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>
 -->

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>
    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

    <!-- Make sure that the expected file structure exists, some
         of these files can be missing if originally empty -->
    <mkdir dir="${dist.dir}"/>
    <!-- <mkdir dir="${dist.bin.pkg}"/> -->
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <!-- <mkdir dir="${dist.etc.pkg}"/> -->

    <!-- Do normal install, but with many targets switched off-->
    <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

  <!--
    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <classpath refid="tests-classpath"/>
    </javac>
   !-->

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

 <echo message="Ignore AstroGrid tests for now"/>
 <echo message="- they require connections which can't be made (no service)"/>
 <!--
    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/JUnit*"/>
          <include name="**/*Test*"/>
        </fileset>
      </batchtest>

    </junit>
  -->

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   Axis build file
 !
 !   This file describes how to install the local Axis package from its
 !   released state. It requires Apache ANT and a Java Development Kit.
 !
 !   The main targets are:
 !
 !      build            -> makes copies of local files that will be modified
 !      clean            -> removes local copies
 !      deinstall        -> undo the install target
 !      dist             -> makes package into dist state
 !      export           -> creates the full distribution archives
 !      export-runonly   -> same as export
 !      export-source    -> same as export
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> same as install
 !      jars             -> add manifest and sign jar files
 !      javadocs         -> does nothing
 !      javadoc-sources  -> does nothing
 !
 !   The targets that do nothing are provided for compatibility with
 !   the normal build system.
 !!
 !! test targets yet to be done.
 !!
 !   Authors:
 !      Peter W. Draper (9-JUL-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for Axis" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="Axis"/>
  <property name="name" value="axis"/>
  <property name="version" value="1.0b2"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing any unmodified jars of this package -->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Distribution directories, these are the actual state of this
   !   package at all times -->
  <property name="dist.dir" value="${basedir}"/>

  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  
  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://xml.apache.org/axis/"/>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

  </target>

  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !   Just makes local copies of the package jar files so that they
   !   can be safely modified.
   !-->
  <target name="build"
          depends="prepare"
          description="-> make local copies of files for modification">

    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>

  </target>

  <!--
   !   ===========================
   !   Create the package jar file
   !   ===========================
   !
   !   This just updates the manifest and signs with using the local
   !   keystore.
   !-->
  <target name="jars"
          depends="build"
          description="-> packages jar files">

    <!-- Add the manifest to the axis.jar file, just an update -->
    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/axis.jar" basedir="${dist.dir}"
         update="true" excludes="**">

      <!-- Create the manifest, note wraps in column 80 so avoid
       !   this. TODO: perform this task automatically?-->
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
      
    </jar>

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
    </signjar>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>AXIS</title>
         <vendor>Apache</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Apache axis - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =============================
   !   Create the local distribution
   !   =============================
   !
   !  Nothing to do, this package is permanently in this condition.
   !-->
  <target name="dist"
          depends="jars,webstart"
          description="-> make package ready for distribution">
  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  package.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  Same as export, except for the name.
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

    <antcall target="create_archives">
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. Same as export, except for the
   !  name.
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

    <antcall target="create_archives">
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required.
   ! For this package these are all the same just set the property
   ! "archive.name" to define what name to use for the outfile
   ! files. The archives are also written into the directory
   ! ${star.archive.dir} (the local directory by default).
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>
    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib"/>

    </zip>

    <tar longfile="gnu" destfile="${archive.name}.tar">

      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib"/>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz" 
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2" 
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>
  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !
   !   Removes copies of jar files.
   !-->
  <target name="clean"
          description="-> removes local copies">

    <delete dir="${dist.lib}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the package into another set of directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>

    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   =========================================
   !
   ! Same as install.
   !-->
  <target name="install-runonly"
          description="-> install distribution into Starlink tree">

     <antcall target="install"/>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   ! that were copied into place by the install target.
   !-->
 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall" 
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Does nothing.
   !-->
  <target name="javadocs"
          description="-> does nothing">
  </target>

  <!--
   !   ==========================================
   !   Creates the API documentation java sources
   !   ==========================================
   !
   !  Does nothing.
   !-->
  <target name="javadoc-sources"
          description="-> does nothing">
  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          description="-> does nothing"/>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   Main source build file
 !
 !   This file describes how to build the Starlink java system from a
 !   source release. It requires Apache ANT and a Java Development Kit.
 !
 !   The main targets are:
 !
 !      build          -> compiles the system
 !      javadocs       -> creates packages API documentation
 !      javadocs-full  -> creates the complete API documentation
 !      install        -> installs the system and documentation
 !      deinstall      -> deinstalls the system
 !      clean          -> cleans up the build
 !      export         -> create full export distributions of packages
 !      export-full    -> exports all monolithic archives
 !      export-full-source -> exports full source archives
 !      export-full-built  -> exports monolithic runtime distributions
 !      export-full-docs   -> exports monolithic docs archive
 !      test           -> run any JUnit tests in the system
 !      keystore       -> generate a keystore for signing jar files
 !      system         -> make report of JVM system properties
 !
 !   Authors:
 !      Peter W. Draper (2-JUL-2002)
 !
 !-->

<project name="Build file for Starlink" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}"/>

  <!-- Whether to generate Java documentation -->
  <property name="javadocs.required" value="false"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!-- Webstart and jar signing properties. -->
  <property name="webstart.codebase"
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="webstart.signer" value="${user.name}"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions. Use "full" names
   !   to avoid passing these down the packages. All parameters are
   !   passed by default. -->
  <property name="FullName" value="Starlink-UK"/>
  <property name="fullname" value="starlink"/>
  <property name="fullversion" value="0.1"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>

  <!-- Default target for the sub-packages -->
  <property name="what" value="build"/>

  <!-- Directory for the complete java documentation -->
  <property name="docs.dir" value="${basedir}/docs"/>
  <property name="docs.javadocs" value="${docs.dir}/javadocs"/>

  <!-- Local directory for support files -->
  <property name="support.dir" value="${basedir}/src"/>
  <property name="support.docs" value="${support.dir}/docs"/>
  <property name="support.etc" value="${support.dir}/etc"/>

  <!--
   !  ======================================
   !  Execute all ANT in all sub-directories
   !  ======================================
   !
   !  Execute a target in each of the sub-directories. The target
   !  invoked is defined by the "what" property. New packages should
   !  have an entry created in the correct dependency order. Note
   !  that all properties defined in this file are passed on.
   !-->
  <target name="call_package_ant">

    <echo message="Executing JUnit target: ${what}"/>
    <ant dir="./junit" target="${what}"/>

    <echo message="Executing tamfits target: ${what}"/>
    <ant dir="./tamfits" target="${what}"/>

    <echo message="Executing axis target: ${what}"/>
    <ant dir="./axis" target="${what}"/>

    <echo message="Executing Jetty target: ${what}"/>
    <ant dir="./jetty" target="${what}"/>

    <echo message="Executing UTIL target: ${what}"/>
    <ant dir="./util" target="${what}"/>

    <echo message="Executing SOAPSERVER target: ${what}"/>
    <ant dir="./soapserver" target="${what}"/>

    <echo message="Executing XDOC target: ${what}"/>
    <ant dir="./xdoc" target="${what}"/>

    <echo message="Executing PLASTIC target: ${what}"/>
    <ant dir="./plastic" target="${what}"/>

    <echo message="Executing JSAMP target: ${what}"/>
    <ant dir="./jsamp" target="${what}"/>

    <echo message="Executing Task target: ${what}"/>
    <ant dir="./task" target="${what}"/>

    <echo message="Executing CONNECT target: ${what}"/>
    <ant dir="./connect" target="${what}"/>

    <echo message="Executing JNIAST target: ${what}"/>
    <ant dir="./jniast" target="${what}"/>

    <echo message="Executing Pal target: ${what}"/>
    <ant dir="./pal" target="${what}"/>

    <echo message="Executing DIVA target: ${what}"/>
    <ant dir="./diva" target="${what}"/>

    <echo message="Executing HELP target: ${what}"/>
    <ant dir="./help" target="${what}"/>

    <echo message="Executing ASTGUI target: ${what}"/>
    <ant dir="./astgui" target="${what}"/>

    <echo message="Executing JNIHDS target: ${what}"/>
    <ant dir="./jnihds" target="${what}"/>

    <echo message="Executing HDX target: ${what}"/>
    <ant dir="./hdx" target="${what}"/>

    <echo message="Executing NDArray target: ${what}"/>
    <ant dir="./array" target="${what}"/>

    <echo message="Executing NDX target: ${what}"/>
    <ant dir="./ndx" target="${what}"/>

    <echo message="Executing Table target: ${what}"/>
    <ant dir="./table" target="${what}"/>

    <echo message="Executing Mirage target: ${what}"/>
    <ant dir="./mirage" target="${what}"/>

    <echo message="Executing NDTools target: ${what}"/>
    <ant dir="./ndtools" target="${what}"/>

    <echo message="Executing HDS target: ${what}"/>
    <ant dir="./hds" target="${what}"/>

    <echo message="Executing FITS target: ${what}"/>
    <ant dir="./fits" target="${what}"/>

    <echo message="Executing JSky target: ${what}"/>
    <ant dir="./jsky" target="${what}"/>

    <echo message="Executing VOTable target: ${what}"/>
    <ant dir="./votable" target="${what}"/>

    <echo message="Executing CDF target: ${what}"/>
    <ant dir="./cdf" target="${what}"/>

    <echo message="Executing RAYREG target: ${what}"/>
    <ant dir="./rayreg" target="${what}"/>

    <echo message="Executing REGISTRY target: ${what}"/>
    <ant dir="./registry" target="${what}"/>

    <echo message="Executing VO target: ${what}"/>
    <ant dir="./vo" target="${what}"/>

    <echo message="Excecuting SRB target: ${what}"/>
    <ant dir="./srb" target="${what}"/>

    <echo message="Executing AstroGrid target: ${what}"/>
    <ant dir="./astrogrid" target="${what}"/>

    <echo message="Executing TTOOLS target: ${what}"/>
    <ant dir="./ttools" target="${what}"/>

    <echo message="Executing DATANODE target: ${what}"/>
    <ant dir="./datanode" target="${what}"/>

    <echo message="Executing JAIUtil target: ${what}"/>
    <ant dir="./jaiutil" target="${what}"/>

 <!--   <echo message="Executing JPCS target: ${what}"/> -->
 <!--   <ant dir="./jpcs" target="${what}"/> -->

 <!--   <echo message="Executing StarTask target: ${what}"/> -->
 <!--   <ant dir="./startask" target="${what}"/> -->

 <!--   <echo message="Executing JNIKAPPA target: ${what}"/> -->
 <!--   <ant dir="./jnikappa" target="${what}"/> -->

    <echo message="Executing SOG target: ${what}"/>
    <ant dir="./sog" target="${what}"/>

    <echo message="Executing SPLAT target: ${what}"/>
    <ant dir="./splat" target="${what}"/>

    <echo message="Executing TOPCAT target: ${what}"/>
    <ant dir="./topcat" target="${what}"/>

    <echo message="Executing Treeview target: ${what}"/>
    <ant dir="./treeview" target="${what}"/>

    <echo message="Executing Coco target: ${what}"/>
    <ant dir="./coco" target="${what}"/>

    <echo message="Executing RV target: ${what}"/>
    <ant dir="./rv" target="${what}"/>

    <echo message="Executing FROG target: ${what}"/>
    <ant dir="./frog" target="${what}"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can
   !  proceed. This isn't used at present, but shows the sort of thing
   !  you might want to do.
   !-->
  <target name="prepare">
    <tstamp>
      <format property="year" pattern="yyyy" />
    </tstamp>
    <filterchain id="install.filters">
      <replacetokens>
        <token key="VERSION" value="${version}" />
        <token key="DATE" value="${TODAY}" />
        <token key="TIME" value="${TSTAMP}" />
      </replacetokens>
    </filterchain>
  </target>

  <!--
   !   ==================
   !   Build all packages
   !   ==================
   !-->
  <target name="build" depends="prepare"
          description="--> compiles all packages">

     <antcall target="call_package_ant">
        <param name="what" value="build"/>
     </antcall>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean" depends="prepare" description="--> cleans up build">

     <antcall target="call_package_ant">
        <param name="what" value="clean"/>
     </antcall>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !-->
  <target name="install" depends="prepare"
          description="--> install into Starlink tree">

     <antcall target="call_package_ant">
        <param name="what" value="install"/>
     </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !-->
  <target name="deinstall" depends="prepare"
          description="--> undo the install target">

     <antcall target="call_package_ant">
        <param name="what" value="deinstall"/>
     </antcall>

  </target>

  <!--
   !   =========================================
   !   Creates API documentation in each package
   !   =========================================
   !
   !  Create the documentation in each package.
   !
   !-->
  <target name="javadocs" depends="prepare"
          description="--> generate the java documentation">

     <antcall target="call_package_ant">
        <param name="what" value="javadocs"/>
     </antcall>

  </target>

  <!--
   !   =============================================
   !   Creates the complete system API documentation
   !   =============================================
   !
   !  Creates the complete javadocs for all local source packages.
   !-->
  <target name="javadocs-full" depends="prepare"
          description="--> generate the complete java documentation">

     <!-- First make the all the java source available in a suitable
      !   fashion for gathering together. -->
     <antcall target="call_package_ant">
        <param name="what" value="javadoc-sources"/>
     </antcall>

     <!-- Generate a classpath that should include the compiled forms
      !   of all the source we're about to document.
      !-->
     <path id="classpath">
       <dirset dir="${star.build.dir}">
          <include name="*/build/classes"/>
       </dirset>
       <fileset dir="${star.build.dir}">
          <include name="*/lib/*/*.jar"/>
       </fileset>
     </path>

     <mkdir dir="${docs.javadocs}"/>
     <javadoc useexternalfile="yes"
              destdir="${docs.javadocs}"
              author="true"
              version="true"
              locale="en"
              windowtitle="${FullName} API"
              doctitle="${FullName}"
              protected="true"
              classpathref="classpath"
              source="1.5"
              maxmemory="512m">

      <!-- Get all possible package names from the build/java
       !   directories. Need to name all top-level packages
       !   unfortunately (rather than just get all source file names)
       !   otherwise internal linking doesn't work well. If a single
       !   packageset (which is really a dirset) that could be
       !   modified to remove the "{package}/build/java" part could be
       !   created then this would be unnecessary (TODO: look into
       !   this and maybe create a special type).
       !-->
      <packageset dir="util/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="soapserver/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="xdoc/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="plastic/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="task/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="connect/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="jniast/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="astgui/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="jnihds/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="array/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="ndx/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="table/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="hds/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="fits/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="votable/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="ttools/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="registry/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="vo/build/java" defaultexcludes="yes">
         <exclude name="net/ivoa/www/**"/>
      </packageset>

      <packageset dir="srb/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="astrogrid/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="datanode/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="hdx/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="jaiutil/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="mirage/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="pal/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="coco/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="rv/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <packageset dir="diva/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <group title="${FullName} API" packages="uk.ac.starlink.*"/>

      <!-- Third party packages built from source -->
      <packageset dir="tamfits/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>
      <group title="nom.tam.fits API" packages="nom.*"/>

      <packageset dir="jsky/build/java" defaultexcludes="yes">
         <include name="**"/>
      </packageset>
      <group title="JSky API" packages="jsky.*"/>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <!-- TODO: link to static third party docs, need fixed relative
       !   positions or pretend offline and use a package list -->

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!--
   !   ===============================
   !   Create the export distributions
   !   ===============================
   !-->
  <target name="export" depends="prepare"
          description="--> create all export archives">

     <antcall target="call_package_ant">
        <param name="what" value="export"/>
     </antcall>

  </target>

  <!-- Properties used for building full export archives. -->
  <property name="archive.name" value="starjava"/>
  <property name="archive.jni.name" value="${archive.name}-${os.arch}"/>
  <property name="archive.top" value="starjava/"/>
  <property name="tar.user" value="${user.name}"/>
  <property name="tar.group" value="star"/>
  <property name="licence.file" value="LICENCE.txt"/>
  <property name="export.readme" value="README"/>

  <!--
   !   ========================================
   !   Export source, docs and runtime archives
   !   ========================================
   !-->
  <target name="export-full"
          depends="export-full-source,export-full-built,export-full-docs"
          description="--> exports all monolithic archives">
    <copy todir="${star.archive.dir}">
      <fileset dir="${support.etc}">
        <include name="${licence.file}"/>
        <include name="${export.readme}"/>
      </fileset>
    </copy>
  </target>

  <!--
   !   ===========================
   !   Export full source archives
   !   ===========================
   !-->
  <target name="export-full-source"
          depends="deinstall,clean"
          description="--> exports monolithic source archive">

    <!-- Export a tree consisting of all and only the java source files
     !   in the namespace uk.ac.starlink.*, in a single zip file of the
     !   corresponding structure.  For casual browsing or building,
     !   this is more digestible than the full tree of packages and build
     !   machinery.  -->

    <!-- Ensure that all the source code is available. -->
    <antcall target="call_package_ant">
      <param name="what" value="javadoc-sources"/>
    </antcall>

    <!-- Copy all the files in the starlink namespace to a scratch directory -->
    <property name="source.tree.dir" value="${star.build.dir}/build/java"/>
    <mkdir dir="${source.tree.dir}"/>
    <copy todir="${source.tree.dir}">
      <fileset dir="${star.build.dir}"
               includes="*/src/main/uk/ac/starlink/**/*.java"/>
      <fileset dir="${star.build.dir}"
               includes="*/build/java/uk/ac/starlink/**"/>
      <mapper type="regexp" from="(uk/ac/starlink/.*)" to="\1"/>
    </copy>
    <copy todir="${source.tree.dir}" file="${support.etc}/${licence.file}"/>

    <!-- Construct a zip file from the scratch directory. -->
    <zip destfile="${star.archive.dir}/${archive.name}-src.zip"
         basedir="${source.tree.dir}"/>

    <!-- Tidy up by deleting the scratch directory -->
    <delete dir="${source.tree.dir}"/>

  </target>

  <!--
   !   ==========================
   !   Export full built archives
   !   ==========================
   !-->
  <target name="export-full-built"
          depends="install"
          description="--> exports monolithic runtime distributions">

    <tar destfile="${star.archive.dir}/${archive.name}.tar.gz"
         longfile="gnu" compression="gzip">
      <tarfileset dir="${support.etc}" includes="${licence.file}"
                                            prefix="${archive.top}"
                                            username="${tar.user}"
                                            group="${tar.group}"/>
      <tarfileset dir="${star.install}/bin" prefix="${archive.top}bin"
                                            username="${tar.user}"
                                            group="${tar.group}"
                                            mode="755"/>
      <tarfileset dir="${star.install}/etc" prefix="${archive.top}etc"
                                            username="${tar.user}"
                                            group="${tar.group}"/>
      <tarfileset dir="${star.install}/lib" prefix="${archive.top}lib"
                                            username="${tar.user}"
                                            group="${tar.group}"/>
    </tar>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">
      <zipfileset dir="${support.etc}" includes="${licence.file}"
                                            prefix="${archive.top}"/>
      <zipfileset dir="${star.install}/bin" prefix="${archive.top}bin"/>
      <zipfileset dir="${star.install}/etc" prefix="${archive.top}etc"/>
      <zipfileset dir="${star.install}/lib" prefix="${archive.top}lib"/>
    </zip>

  </target>

  <!--
   !   =======================================
   !   Create a keystore for signing jar files
   !   =======================================
   !
   !   Note this only works if a keystore doesn't already exist.
   !   Should only be necessary to do this from time to time (when
   !   validity peroid expires?).
   !-->
  <target name="keystore">
    <genkey alias="${webstart.alias}"
           keystore="${webstart.keystore}"
           storepass="${webstart.storepass}"
           keypass="${webstart.keypass}"
           dname="CN=${webstart.signer}, O=${FullName}, L=RAL, C=UK"/>

     <!-- dname format:
      !      CN=cName, OU=orgUnit, O=org, L=city, S=state, C=countryCode-->

     <!-- Probably a good time to sign ANT -->
     <antcall target="sign_ant"/>

  </target>

  <!--
   !   ===================
   !   Sign ANTs jar files
   !   ===================
   !   Can only do this once a keystore has been created..., so must
   !   be done after ANT has been built
   !-->
  <target name="sign_ant">

    <ant dir="./ant" inheritAll="false" target="sign_jars"/>

  </target>

  <!--
   !   =================================
   !   Export full documentation archive
   !   =================================
   !-->
  <target name="export-full-docs"
          depends="javadocs-full,install"
          description="--> exports monolithic doc and javadoc archive">
    <zip destfile="${star.archive.dir}/${archive.name}-docs.zip">
      <zipfileset dir="${support.etc}" includes="${licence.file}"
                                             prefix="${archive.top}"/>
      <zipfileset dir="${docs.dir}/javadocs" prefix="${archive.top}javadocs"/>

      <!-- Pick up non-javadoc docs from the installation -->
      <zipfileset dir="${star.install}/docs" prefix="${archive.top}docs"
         excludes="**/javadocs/**"/>
    </zip>
  </target>

  <!--
   !   =================
   !   Run the testcases
   !   =================
   !-->
  <target name="test" depends="prepare"
          description="--> run all the test targets">

     <antcall target="call_package_ant">
        <param name="what" value="test"/>
     </antcall>

  </target>

  <!--
   !   ========================
   !   Report system properties
   !   ========================
   !-->
  <target name="system"
          description="--> report system properties">

    <echo message="System properties:"/>
    <echo message=" java.version = ${java.version}"/>
    <echo message=" java.vendor = ${java.vendor}"/>
    <echo message=" java.vendor.url = ${java.vendor.url}"/>
    <echo message=" java.home = ${java.home}"/>
    <echo message=" java.vm.specification.version = ${java.vm.specification.version}"/>
    <echo message=" java.vm.specification.vendor = ${java.vm.specification.vendor}"/>
    <echo message=" java.vm.specification.name = ${java.vm.specification.name}"/>
    <echo message=" java.vm.version = ${java.vm.version}"/>
    <echo message=" java.vm.vendor = ${java.vm.vendor}"/>
    <echo message=" java.vm.name = ${java.vm.name}"/>
    <echo message=" java.specification.version = ${java.specification.version}"/>
    <echo message=" java.specification.vendor = ${java.specification.vendor}"/>
    <echo message=" java.specification.name = ${java.specification.name}"/>
    <echo message=" java.class.version = ${java.class.version}"/>
    <echo message=" java.class.path = ${java.class.path}"/>
    <echo message=" java.library.path = ${java.library.path}"/>
    <echo message=" java.io.tmpdir = ${java.io.tmpdir}"/>
    <echo message=" java.compiler = ${java.compiler}"/>
    <echo message=" java.ext.dirs = ${java.ext.dirs}"/>
    <echo message=" os.name = ${os.name}"/>
    <echo message=" os.arch = ${os.arch}"/>
    <echo message=" os.version = ${os.version}"/>
    <echo message=" file.separator = ${file.separator}"/>
    <echo message=" path.separator = ${path.separator}"/>
    <echo message=" line.separator = ${line.separator}"/>
    <echo message=" user.name = ${user.name}"/>
    <echo message=" user.home = ${user.home}"/>
    <echo message=" user.dir = ${user.dir}"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   CDF build file
 !
 !   This file describes how to build and install CDF from
 !   source and binary releases. CDF is a class library
 !   (i.e. provides an API and related documentation).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for CDF" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="CDF"/>
  <property name="name" value="cdf"/>
  <property name="version" value="1.0"/>

  <!-- The Java package name -->
  <property name="package.name" value="{package.path}"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.5"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Any achitecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase"
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Installed jar files.
   !
   !   Name all the installed jar files of other packages that we depend on.
   !
   !   When compiling under Java 1.4 these will be used to produce a full
   !   classpath that is equivalent to that generated when these are
   !   referenced as optional bundled packages by the JVM.
   !   When compiling under Java 1.5 (and probably later) this is just
   !   a simple path of these jar files, as the expansion to a full optional
   !   bundled package classpath is performed by the compiler
   !
   !   What that all means is that the manifest classpaths of these jar files
   !   are honoured, the plain compiler pre Java 1.5 didn't do that. When Java
   !   1.4 is no longer used the extclasspath type can be replaced by a simple
   !   path.
   !-->
  <extclasspath id="installed.classpath">

    <!-- Table -->
    <pathelement location="${star.jar.dir}/table/table.jar"/>

  </extclasspath>

  <!-- Local build system jar files.
   !
   !   Name all the jar files of other packages that we depend on, which have
   !   not been installed (should be same packages as in installed.classpath).
   !-->
  <extclasspath id="built.jarpath">
    <pathelement location="${star.build.dir}/table/lib/table/table.jar"/>
  </extclasspath>

  <!-- Find all local third party jars files.
   !
   !   Normally these will be kept in their own third party package, but may
   !   be kept here temporarily, say if there are version conflicts that
   !   cannot be addressed. They are installed with the package jar files and
   !   should be entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  </path>

  <!-- Create the local build system CLASSPATH.
   !
   !   Create the classpath used when building this package as part of a full
   !   build system without any dependency on any installed or external jar
   !   files.
   !
   !   Classes compiled in the local build tree will be in the "build/classes"
   !   part of each package. Third party packages, have do not have any source
   !   code, just jar files, will have their jar files in their "dist"
   !   directories (usually lib/{package_name}).
   !
   !   So the full built classpath is created by constructing a path
   !   consisting of:
   !
   !      - all third party jar files in this package
   !      - all build/classes directories in the local build system (these
   !        will have the most recent class files)
   !      - all jar files named in built.jarpath, i.e. named local build
   !        system jar files (these can be normal packages in the "dist" state
   !        or third party packages)
   !      - all jar files in the "dist" directories of all packages in the
   !        local build system (these are necessary to make sure that the jar
   !        files in the previous part have their dependencies fulfilled,
   !        without having them all installed)
   !-->
  <path id="built.classpath">

    <!-- Third party jars held by this package -->
    <path refid="package.jars"/>

    <!-- All classes in the local build system -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent jars in the local build system -->
    <path refid="built.jarpath"/>

    <!-- All "dist" jar files to make sure everything is resolved, including
     !   relative URLs of the local packages, without installation -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

  </path>

  <!-- User-defined CLASSPATH.
   !
   !   This is set by the property "extra.class.path" (which can be defined
   !   locally using say -Dextra.class.path=$CLASSPATH on the command line
   !   or by setting the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Create the full CLASSPATH used during compilation.
   !
   !   This is created from the user-defined classpath, followed by the
   !   classpath for building against the local system, followed by the
   !   classpath for building against an installed system.
   !-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- Create the JUnit tests CLASSPATH.
   ! 
   !   Note that in addition to the build/classes and build/tests directory
   !   we also add tests.dir and tests.etc.dir so that resources may be
   !   located there. The full classpath is also used.
   !-->  
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    ============
   !    Library path
   !    ============
   !    Used by test targets for locating native libraries.
   !-->
  <path id="tests-libpath.id">
    <pathelement path="${java.library.path}"/>
    <pathelement location="${star.jar.dir}/${os.arch}"/>
  </path>
  <property name="tests-libpath" refid="tests-libpath.id"/>

  <!--
   !    ===============
   !    Extension tasks
   !    ===============
   !    Add any local or extension ANT tasks that are required. Local
   !    tasks should be moved into the ANT package if used outside of this
   !    package. 
   !-->
  <taskdef resource="axis-tasks.properties" classpathref="classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !
   !    Minimalist check of the required dependencies so that the build will
   !    not proceed if some basic dependencies are not present on the
   !    classpath. Optional components could also be checked here.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!--  Table -->
    <available property="table.present"
               classpathref="classpath"
               classname="uk.ac.starlink.table.StarTable"/>

    <fail message="No TABLE available" unless="table.present"/>

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <classpath refid="classpath"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
      <exclude name="**/{Retired1.java}"/>
      <exclude name="**/{Retired2.java}"/>
      <exclude name="**/*.html"/>
      <exclude name="**/*.properties*"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/{package.support.files}"/>
        <include name="**/{more.package.support.files}"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this class library.
     !   This goes into "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">

      <information>
         <title>{Package} - {description}</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink {Package} - Webstart edition"</description>
         <offline_allowed/>
       </information>

       <security>
          <all_permissions/>
       </security>

       <resources>
         <j2se version="1.5+"/>

         <!-- Define the main library jar file -->
         <jar href="${name}/${name}.jar"/>

         <!-- Name any extension packages we directly depend on -->
         <extension name="{EXT1}" href="{ext1}.jnlp"/>
         <extension name="{EXT2}" href="{ext2}.jnlp"/>
       </resources>

       <!-- This is a component -->
       <component_desc/>

     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin.pkg}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <mkdir dir="${dist.etc.pkg}"/>

    <!-- Copy any configuration/helper scripts etc. -->
  <!--
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>
   !-->

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
  <!--
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>
   !-->

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin.pkg}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.etc.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory-->
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <mkdir dir="${dist.etc.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   coco build file
 !
 !   This file describes how to build and install coco from
 !   source and binary releases.
 !   Coco is a application to Convert between various
 !   Celestial Coordinates systems.
 !   (uses the Positional Astronomy Library).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Roy Platon (27-JAN-2003)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for coco" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="Coco"/>
  <property name="name" value="coco"/>
  <property name="version" value="1.0"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.coco"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.4"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Any achitecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
           value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- {Other packages} -->
    <pathelement location="${star.jar.dir}/pal/pal.jar"/>

    <!-- {More packages} -->
  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">

    <!-- {More packages} -->
  </extclasspath>

  <!-- "Local" third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, say
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
 <!--
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
 -->
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property
   !   "extra.class.path" (which can be defined locally using say
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath, add tests.dir and tests.etc.dir so that
   !   resources may be located there -->
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!--  {Example package1} -->
    <!--  {Example package2} -->

    <!-- {More critical dependencies} -->

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here. 
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <classpath refid="classpath"/>
      <compilerarg value="-proc:none" compiler="javac1.6"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
      <exclude name="**/{Retired1.java}"/>
      <exclude name="**/{Retired2.java}"/>
      <exclude name="**/*.html"/>
      <exclude name="**/*.properties*"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/{package.support.files}"/>
        <include name="**/{more.package.support.files}"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
 <!--
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>
 -->

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
        <attribute name="Main-Class" value="uk.ac.starlink.coco.Coco"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>

  </target>

 <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>COCO - celestial coordinate conversion </title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink COCO - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="${name}/${name}.jar"/>
         <extension name="PAL" href="pal.jnlp"/>
       </resources>
       <application_desc main_class="uk.ac.starlink.coco.Coco"/>
     </jnlp>

     <!-- May be needed as a component so provide that too -->
     <jnlp toFile="${dist.lib}/${name}-parts.jnlp" href="${name}-parts.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>COCO - celestial coordinate conversion </title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink COCO - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="${name}/${name}.jar"/>
         <extension name="PAL" href="pal.jnlp"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <!-- <mkdir dir="${dist.bin.pkg}"/> -->
    <mkdir dir="${dist.lib.pkg}"/>
    <!-- <mkdir dir="${dist.docs.pkg}"/> -->
    <!-- <mkdir dir="${dist.etc.pkg}"/> -->

    <!-- Copy any configuration/helper scripts etc. -->
  <!--
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>
  -->

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
  <!--
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>
  -->

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
  <!--
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>
  -->

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <!--<zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>-->
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <!--<zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>-->

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <!--<tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>-->
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <!--<tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>-->

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
    <!-- <mkdir dir="${star.bin.pkg}"/> -->
    <mkdir dir="${star.lib.pkg}"/>
    <!-- <mkdir dir="${star.etc.pkg}"/> -->
    <mkdir dir="${star.docs.pkg}"/>

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
  <!--
    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>
  -->

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory-->
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <!-- <mkdir dir="${dist.bin.pkg}"/> -->
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <!-- <mkdir dir="${dist.etc.pkg}"/> -->

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          description="-> does nothing"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/JUnit*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   CONNECT build file
 !
 !   This file describes how to build and install {Package} from
 !   source and binary releases. {Package} is a class library
 !   (i.e. provides an API and related documentation).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for CONNECT" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="CONNECT"/>
  <property name="name" value="connect"/>
  <property name="version" value="0.1"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.connect"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.4"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Any achitecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase"
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/"/>

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Installed jar files.
   !
   !   Name all the installed jar files of other packages that we depend on.
   !
   !   When compiling under Java 1.4 these will be used to produce a full
   !   classpath that is equivalent to that generated when these are
   !   referenced as optional bundled packages by the JVM.
   !   When compiling under Java 1.5 (and probably later) this is just
   !   a simple path of these jar files, as the expansion to a full optional
   !   bundled package classpath is performed by the compiler
   !
   !   What that all means is that the manifest classpaths of these jar files
   !   are honoured, the plain compiler pre Java 1.5 didn't do that. When Java
   !   1.4 is no longer used the extclasspath type can be replaced by a simple
   !   path.
   !-->
  <extclasspath id="installed.classpath">

    <!-- UTIL -->
    <pathelement location="${star.jar.dir}/util/util.jar"/>

  </extclasspath>

  <!-- Local build system jar files.
   !
   !   Name all the jar files of other packages that we depend on, which have
   !   not been installed (should be same packages as in installed.classpath).
   !-->
  <extclasspath id="built.jarpath">

    <pathelement location="${star.build.dir}/util/lib/util/util.jar"/>

  </extclasspath>

  <!-- Find all local third party jars files.
   !
   !   Normally these will be kept in their own third party package, but may
   !   be kept here temporarily, say if there are version conflicts that
   !   cannot be addressed. They are installed with the package jar files and
   !   should be entered into the main jar file manifest.
   !-->
  <path id="package.jars">
 <!--
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
 -->
  </path>

  <!-- Create the local build system CLASSPATH.
   !
   !   Create the classpath used when building this package as part of a full
   !   build system without any dependency on any installed or external jar
   !   files.
   !
   !   Classes compiled in the local build tree will be in the "build/classes"
   !   part of each package. Third party packages, have do not have any source
   !   code, just jar files, will have their jar files in their "dist"
   !   directories (usually lib/{package_name}).
   !
   !   So the full built classpath is created by constructing a path
   !   consisting of:
   !
   !      - all third party jar files in this package
   !      - all build/classes directories in the local build system (these
   !        will have the most recent class files)
   !      - all jar files named in built.jarpath, i.e. named local build
   !        system jar files (these can be normal packages in the "dist" state
   !        or third party packages)
   !      - all jar files in the "dist" directories of all packages in the
   !        local build system (these are necessary to make sure that the jar
   !        files in the previous part have their dependencies fulfilled,
   !        without having them all installed)
   !-->
  <path id="built.classpath">

    <!-- Third party jars held by this package -->
    <path refid="package.jars"/>

    <!-- All classes in the local build system -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent jars in the local build system -->
    <path refid="built.jarpath"/>

    <!-- All "dist" jar files to make sure everything is resolved, including
     !   relative URLs of the local packages, without installation -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

  </path>

  <!-- User-defined CLASSPATH.
   !
   !   This is set by the property "extra.class.path" (which can be defined
   !   locally using say -Dextra.class.path=$CLASSPATH on the command line
   !   or by setting the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Create the full CLASSPATH used during compilation.
   !
   !   This is created from the user-defined classpath, followed by the
   !   classpath for building against the local system, followed by the
   !   classpath for building against an installed system.
   !-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- Create the JUnit tests CLASSPATH.
   ! 
   !   Note that in addition to the build/classes and build/tests directory
   !   we also add tests.dir and tests.etc.dir so that resources may be
   !   located there. The full classpath is also used.
   !-->  
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    ============
   !    Library path
   !    ============
   !    Used by test targets for locating native libraries.
   !-->
  <path id="tests-libpath.id">
    <pathelement path="${java.library.path}"/>
    <pathelement location="${star.jar.dir}/${os.arch}"/>
  </path>
  <property name="tests-libpath" refid="tests-libpath.id"/>

  <!--
   !    ===============
   !    Extension tasks
   !    ===============
   !    Add any local or extension ANT tasks that are required. Local
   !    tasks should be moved into the ANT package if used outside of this
   !    package. 
   !-->
  <taskdef resource="axis-tasks.properties" classpathref="classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !
   !    Minimalist check of the required dependencies so that the build will
   !    not proceed if some basic dependencies are not present on the
   !    classpath. Optional components could also be checked here.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!-- UTIL -->
    <available property="util.present"
               classpathref="classpath"
               classname="uk.ac.starlink.util.DataSource"/>
    <fail message="No UTIL available" unless="util.present"/>

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
      <include name="**/*.java"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${src.dir}/resources"/>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
 <!--
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>
 -->

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this class library.
     !   This goes into "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">

      <information>
         <title>CONNECT - connection to remote resources</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink CONNECT - Webstart edition"</description>
         <offline_allowed/>
       </information>

       <security>
          <all_permissions/>
       </security>

       <resources>
         <j2se version="1.5+"/>

         <!-- Define the main library jar file -->
         <jar href="${name}/${name}.jar"/>

         <!-- Name any extension packages we directly depend on -->
         <extension name="UTIL" href="util.jnlp"/>
       </resources>

       <!-- This is a component -->
       <component_desc/>

     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
 <!--   <mkdir dir="${dist.bin.pkg}"/> -->
    <mkdir dir="${dist.lib.pkg}"/>
 <!--   <mkdir dir="${dist.docs.pkg}"/> -->
 <!--   <mkdir dir="${dist.etc.pkg}"/> -->

    <!-- Copy any configuration/helper scripts etc. -->
 <!--
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>
 -->

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
 <!--
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>
 -->

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
 <!--
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>
 -->

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
 <!--   <mkdir dir="${star.bin.pkg}"/> -->
    <mkdir dir="${star.lib.pkg}"/>
 <!--   <mkdir dir="${star.etc.pkg}"/> -->
 <!--   <mkdir dir="${star.docs.pkg}"/> -->

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

 <!--
    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>
 -->

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory-->
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <mkdir dir="${dist.etc.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   Datanode build file
 !
 !   This file describes how to build and install Datanode from
 !   source and binary releases. Datanode is a class library
 !   (i.e. provides an API and related documentation).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for Datanode" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="Datanode"/>
  <property name="name" value="datanode"/>
  <property name="version" value="1.0"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.datanode"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.4"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Any achitecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase"
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/treeview/"/>

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Installed jar files.
   !
   !   Name all the installed jar files of other packages that we depend on.
   !
   !   When compiling under Java 1.4 these will be used to produce a full
   !   classpath that is equivalent to that generated when these are
   !   referenced as optional bundled packages by the JVM.
   !   When compiling under Java 1.5 (and probably later) this is just
   !   a simple path of these jar files, as the expansion to a full optional
   !   bundled package classpath is performed by the compiler
   !
   !   What that all means is that the manifest classpaths of these jar files
   !   are honoured, the plain compiler pre Java 1.5 didn't do that. When Java
   !   1.4 is no longer used the extclasspath type can be replaced by a simple
   !   path.
   !-->
  <extclasspath id="installed.classpath">

    <!-- Array -->
    <pathelement location="${star.jar.dir}/array/array.jar"/>
 
    <!-- Table -->
    <pathelement location="${star.jar.dir}/table/table.jar"/>
 
    <!-- JNIAST -->
    <pathelement location="${star.jar.dir}/jniast/jniast.jar"/>
 
    <!-- TAMFITS -->
    <pathelement location="${star.jar.dir}/tamfits/tamfits.jar"/>

    <!-- FITS -->
    <pathelement location="${star.jar.dir}/fits/fits.jar"/>

    <!-- JNIHDS -->
    <pathelement location="${star.jar.dir}/jnihds/hds.jar"/>

    <!-- HDS -->
    <pathelement location="${star.jar.dir}/hds/hds.jar"/>

    <!-- NDX -->
    <pathelement location="${star.jar.dir}/ndx/ndx.jar"/>

    <!-- VOTable -->
    <pathelement location="${star.jar.dir}/votable/votable.jar"/>

    <!-- Util -->
    <pathelement location="${star.jar.dir}/util/util.jar"/>

  </extclasspath>

  <!-- Local build system jar files.
   !
   !   Name all the jar files of other packages that we depend on, which have
   !   not been installed (should be same packages as in installed.classpath).
   !-->
  <extclasspath id="built.jarpath">

    <pathelement
       location="${star.build.dir}/array/lib/array/array.jar"/>
    <pathelement
       location="${star.build.dir}/table/lib/table/table.jar"/>
    <pathelement
       location="${star.build.dir}/jniast/lib/jniast/jniast.jar"/>
    <pathelement
       location="${star.build.dir}/tamfits/lib/tamfits/tamfits.jar"/>
    <pathelement
       location="${star.build.dir}/jnihds/lib/jnihds/jnihds.jar"/>
    <pathelement
       location="${star.build.dir}/hds/lib/hds/hds.jar"/>
    <pathelement
       location="${star.build.dir}/ndx/lib/ndx/ndx.jar"/>
    <pathelement
       location="${star.build.dir}/votable/lib/votable/votable.jar"/>
    <pathelement
       location="${star.build.dir}/util/lib/util/util.jar"/>

  </extclasspath>

  <!-- Find all local third party jars files.
   !
   !   Normally these will be kept in their own third party package, but may
   !   be kept here temporarily, say if there are version conflicts that
   !   cannot be addressed. They are installed with the package jar files and
   !   should be entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  </path>

  <!-- Create the local build system CLASSPATH.
   !
   !   Create the classpath used when building this package as part of a full
   !   build system without any dependency on any installed or external jar
   !   files.
   !
   !   Classes compiled in the local build tree will be in the "build/classes"
   !   part of each package. Third party packages, have do not have any source
   !   code, just jar files, will have their jar files in their "dist"
   !   directories (usually lib/{package_name}).
   !
   !   So the full built classpath is created by constructing a path
   !   consisting of:
   !
   !      - all third party jar files in this package
   !      - all build/classes directories in the local build system (these
   !        will have the most recent class files)
   !      - all jar files named in built.jarpath, i.e. named local build
   !        system jar files (these can be normal packages in the "dist" state
   !        or third party packages)
   !      - all jar files in the "dist" directories of all packages in the
   !        local build system (these are necessary to make sure that the jar
   !        files in the previous part have their dependencies fulfilled,
   !        without having them all installed)
   !-->
  <path id="built.classpath">

    <!-- Third party jars held by this package -->
    <path refid="package.jars"/>

    <!-- All classes in the local build system -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent jars in the local build system -->
    <path refid="built.jarpath"/>

    <!-- All "dist" jar files to make sure everything is resolved, including
     !   relative URLs of the local packages, without installation -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

  </path>

  <!-- User-defined CLASSPATH.
   !
   !   This is set by the property "extra.class.path" (which can be defined
   !   locally using say -Dextra.class.path=$CLASSPATH on the command line
   !   or by setting the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Create the full CLASSPATH used during compilation.
   !
   !   This is created from the user-defined classpath, followed by the
   !   classpath for building against the local system, followed by the
   !   classpath for building against an installed system.
   !-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- Create the JUnit tests CLASSPATH.
   ! 
   !   Note that in addition to the build/classes and build/tests directory
   !   we also add tests.dir and tests.etc.dir so that resources may be
   !   located there. The full classpath is also used.
   !-->  
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    ============
   !    Library path
   !    ============
   !    Used by test targets for locating native libraries.
   !-->
  <path id="tests-libpath.id">
    <pathelement path="${java.library.path}"/>
    <pathelement location="${star.jar.dir}/${os.arch}"/>
  </path>
  <property name="tests-libpath" refid="tests-libpath.id"/>

  <!--
   !    ===============
   !    Extension tasks
   !    ===============
   !    Add any local or extension ANT tasks that are required. Local
   !    tasks should be moved into the ANT package if used outside of this
   !    package. 
   !-->
  <taskdef resource="axis-tasks.properties" classpathref="classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !
   !    Minimalist check of the required dependencies so that the build will
   !    not proceed if some basic dependencies are not present on the
   !    classpath. Optional components could also be checked here.
   !-->
  <target name="check_packages"
          depends="really_check_packages"
          unless="runonly.install">

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <target name="really_check_packages"
          if="but_its_too_slow">

    <!-- Need Array -->
    <available property="array.present"
               classpathref="classpath"
               classname="uk.ac.starlink.array.NDArray"/>
    <fail message="No Array available" unless="array.present"/>

    <!-- Need Table -->
    <available property="table.present"
               classpathref="classpath"
               classname="uk.ac.starlink.table.StarTable"/>
    <fail message="No Table available" unless="table.present"/>

    <!-- Need JNIAST -->
    <available property="jniast.present"
               classpathref="classpath"
               classname="uk.ac.starlink.ast.Grf"/>
    <fail message="No JNIAST available" unless="jniast.present"/>

    <!-- Need TAMFITS -->
    <available property="tamfits.present"
               classpathref="classpath"
               classname="nom.tam.fits.Header"/>
    <fail message="No TAMFITS available" unless="tamfits.present"/>

    <!-- Need FITS -->
    <available property="fits.present"
               classpathref="classpath"
               classname="uk.ac.starlink.fits.MappedFile"/>
    <fail message="No FITS available" unless="fits.present"/>


    <!-- Need JNIHDS -->
    <available property="jnihds.present"
               classpathref="classpath"
               classname="uk.ac.starlink.hds.HDSObject"/>
    <fail message="No JNIHDS available" unless="jnihds.present"/>

    <!-- Need HDS -->
    <available property="hds.present"
               classpathref="classpath"
               classname="uk.ac.starlink.hds.ArrayStructure"/>
    <fail message="No HDS available" unless="hds.present"/>

    <!-- Need NDX -->
    <available property="ndx.present"
               classpathref="classpath"
               classname="uk.ac.starlink.ndx.Ndx"/>
    <fail message="No NDX available" unless="ndx.present"/>

    <!-- Need VOTable -->
    <available property="votable.present"
               classpathref="classpath"
               classname="uk.ac.starlink.votable.VOTable"/>
    <fail message="No VOTable available" unless="votable.present"/>

    <!-- Need Util -->
    <available property="util.present"
               classpathref="classpath"
               classname="uk.ac.starlink.util.TestCase"/>
    <fail message="No Util available" unless="util.present"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <classpath refid="classpath"/>
      <compilerarg value="-proc:none" compiler="javac1.6"/>

      <include name="**/*.java"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${src.dir}/resources"/>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
       <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
    </signjar>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this class library.
     !   This goes into "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">

      <information>
         <title>Datanode - node infrastructure for Treeview</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink Datanode - Webstart edition"</description>
         <offline_allowed/>
       </information>

       <security>
          <all_permissions/>
       </security>

       <resources>
         <j2se version="1.5+"/>

         <!-- Define the main library jar file -->
         <jar href="${name}/${name}.jar"/>

         <!-- And dependencies -->
         <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"
                                    excludes="${name}/${name}.jar"/>
         <extension name="UTIL" href="util.jnlp"/>
         <extension name="ARRAY" href="array.jnlp"/>
         <extension name="TABLE" href="table.jnlp"/>
         <extension name="JNIAST" href="jniast.jnlp"/>
         <extension name="TAMFITS" href="tamfits.jnlp"/>
         <extension name="FITS" href="fits.jnlp"/>
         <extension name="JNIHDS" href="jnihds.jnlp"/>
         <extension name="HDS" href="hds.jnlp"/>
         <extension name="NDX" href="ndx.jnlp"/>
         <extension name="VOTABLE" href="votable.jnlp"/>
         <extension name="CONNECT" href="connect.jnlp"/>
         <extension name="ASTROGRID" href="astrogrid.jnlp"/>
         <extension name="SRB" href="srb.jnlp"/>
       </resources>

       <!-- This is a component -->
       <component_desc/>

     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <!-- <mkdir dir="${dist.bin.pkg}"/> -->
    <mkdir dir="${dist.lib.pkg}"/>
    <!-- <mkdir dir="${dist.docs.pkg}"/> -->
    <!-- <mkdir dir="${dist.etc.pkg}"/> -->

    <!-- Copy any configuration/helper scripts etc. -->
 <!--
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>
  -->

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
 <!--
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>
  -->

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
 <!--
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>
  -->

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
    <!-- <mkdir dir="${star.bin.pkg}"/> -->
    <mkdir dir="${star.lib.pkg}"/>
    <!-- <mkdir dir="${star.etc.pkg}"/> -->
    <!-- <mkdir dir="${star.docs.pkg}"/> -->

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

 <!--
    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>
 -->

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory-->
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <mkdir dir="${dist.etc.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          description="-> no tests here - use tests in Treeview package"/>
  <!-- <target name="test" depends="run-tests"/> -->

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/JUnit*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   DIVA build file
 !
 !   This file describes how to build the DIVA package 
 !   from a source release. It requires Apache ANT and a Java 
 !   Development Kit.
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> install a runonly distribution into Starlink tree
 !      jars             -> creates the package jar file
 !      javadocs         -> creates the API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> does nothing at present
 !
 !   Authors:
 !      Peter W. Draper (01-SEP-2003)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for DIVA" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="DIVA"/>
  <property name="name" value="diva"/>
  <property name="version" value="1.0-1"/>

  <!-- The Java package name -->
  <property name="package.name" value="diva"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://embedded.eecs.berkeley.edu/diva/"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that 
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may 
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed). 
   !-->
  <extclasspath id="installed.classpath">

     <pathelement location="${star.jar.dir}/util/util.jar"/>

  </extclasspath>
  
  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">

    <pathelement location="${star.build.dir}/util/lib/util/util.jar"/>

  </extclasspath>

  <!-- Local third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, so
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->
  
  </path>

  <!-- Extra user-defined classpath. This is set by the property 
   !   "extra.class.path" (which can be defined locally using say 
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>
  
  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
    <path refid="local.classpath"/>
    <path refid="built.classpath"/>
    <path refid="installed.classpath"/>
  </path>
    
  <!-- JUnit tests classpath -->
  <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>
  
  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages" 
          unless="runonly.install">

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>


  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>
  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images) should also be copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           optimize="${optimize}">

      <classpath refid="classpath"/>

      <!-- Exclude any Java files in the source tree that should not be
       !   compiled -->
      <exclude name="**/*_old.java"/>

    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/images/**"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs) on and, if
   !  appropriate, defines the application entrance point. The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
       <manifest>
          <attribute name="Built-By" value="${user.name}"/>
          <attribute name="Class-Path" value="${jar.class.path}"/>
       </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
     </signjar>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>DIVA</title>
         <vendor>Ptolemy and JavaTime at EECS</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"DIVA - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <!--<mkdir dir="${dist.bin.pkg}"/>-->
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <!--<mkdir dir="${dist.etc.pkg}"/>-->

    <!-- Copy any startup scripts etc. -->
    <!--<copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>-->

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}" maxparallel="50"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}" maxparallel="50"/>
    <!--<chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>-->

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution 
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <!--<zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>-->
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <!--<zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>-->

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <!--<tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>-->
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <!--<tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>-->

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>
    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz" 
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2" 
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <!--<delete dir="${dist.bin}"/>-->
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <!--<delete dir="${dist.etc}"/>-->

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   !  and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <!--<mkdir dir="${star.bin.pkg}"/>-->
    <mkdir dir="${star.lib.pkg}"/>
    <!--<mkdir dir="${star.etc.pkg}"/>-->
    <mkdir dir="${star.docs.pkg}"/>

    <!--<loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>-->

    <!--<chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>-->

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory. 
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <!--<mkdir dir="${dist.bin.pkg}"/>-->
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <!--<mkdir dir="${dist.etc.pkg}"/>-->

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall" 
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  The documentation is created from the Java sources. Should also
   !  extend this to include the possibility of other miscellaneous
   !  documentation (FAQs etc.).
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">
    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>
  </target>

  <!--
   !   ==========================================
   !   Creates the API documentation java sources
   !   ==========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   ! 
   !  Application packages should only make public those parts of
   !  their internal APIs that they are prepared to support. Consider
   !  adding such code to proper class libraries (such as util).
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/*_old.java"/>
      </fileset>
    </copy>
  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   ! Note these are not JUnit based
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">
    <mkdir dir="${build.tests}"/>
    
    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           deprecation="${deprecation}" >
      <classpath refid="tests-classpath"/>
    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          description="-> does nothing"/>

  <!-- RUN up UI for graphics toolkit (for testing/inspecting) -->
  <target name="testui"
          depends="build">

    <!-- Run up from the local build, enable for remote JPDA debugging-->
    <java classname="uk.ac.starlink.diva.TestDrawActions" fork="true">
      <classpath refid="classpath"/>
      <jvmarg value="-Xdebug"/>
      <jvmarg value="-Xnoagent"/>
      <jvmarg value="-Djava.compiler=NONE"/>
      <jvmarg value="-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=7005"/>
    </java>
  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   FITS build file
 !
 !   This file describes how to build the FITS package from a source
 !   release. It requires Apache ANT and a Java Development Kit.
 !
 !   In addition FITS may have requirements for other "core" and
 !   "third-party" packages to complete the compilation and any
 !   testing.
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> install a runonly distribution into Starlink tree
 !      jars             -> creates the package jar file
 !      javadocs         -> creates the API documentation
 !      javadoc-sources  -> make source files for release API documention
 !!
 !! test targets yet to be done.
 !!
 !   Authors:
 !      Peter W. Draper (2-JUL-2002)
 !      Mark Taylor (13-AUG-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for FITS" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!-- Directory containing native libraries. -->
  <property name="star.lib.arch" value="${star.install}/lib/${os.arch}"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="FITS"/>
  <property name="name" value="fits"/>
  <property name="version" value="0.1"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.fits"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.5"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="true"/>
  <property name="junit.filtertrace" value="off"/>
  <property name="junit.summary" value="no"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that 
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may 
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed). 
   !-->
  <extclasspath id="installed.classpath">

    <!-- JUnit -->
    <pathelement location="${star.jar.dir}/junit/junit.jar"/>

    <!-- TAMFITS -->
    <pathelement location="${star.jar.dir}/tamfits/tamfits.jar"/>

    <!-- Array -->
    <pathelement location="${star.jar.dir}/array/array.jar"/>

    <!-- NDX -->
    <pathelement location="${star.jar.dir}/ndx/ndx.jar"/>

    <!-- JNIAST -->
    <pathelement location="${star.jar.dir}/jniast/jniast.jar"/>

    <!-- Table -->
    <pathelement location="${star.jar.dir}/table/table.jar"/>

    <!-- Util -->
    <pathelement location="${star.jar.dir}/util/util.jar"/>

  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">
    <pathelement location="${star.build.dir}/junit/lib/junit/junit.jar"/>
    <pathelement location="${star.build.dir}/tamfits/lib/tamfits/tamfits.jar"/>
    <pathelement location="${star.build.dir}/array/lib/array/array.jar"/>
    <pathelement location="${star.build.dir}/ndx/lib/ndx/ndx.jar"/>
    <pathelement location="${star.build.dir}/jniast/lib/jniast/jniast.jar"/>
    <pathelement location="${star.build.dir}/table/lib/table/table.jar"/>
    <pathelement location="${star.build.dir}/util/lib/util/util.jar"/>
  </extclasspath>

  <path id="built.classpath">

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->
  
  </path>

  <!-- Extra user-defined classpath. This is set by the property 
   !   "extra.class.path" (which can be defined locally using say 
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
    <path refid="local.classpath"/>
    <path refid="built.classpath"/>
    <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath -->
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>
  <property name="build.tests.loc" location="${build.tests}"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages" 
          unless="runonly.install">

    <!--  Need TAMFITS -->
    <available property="tamfits.present"
               classpathref="classpath"
               classname="nom.tam.fits.Fits"/>
    <fail message="No TAMFITS available" unless="tamfits.present"/>

    <!--  Need Array -->
    <available property="array.present"
               classpathref="classpath"
               classname="uk.ac.starlink.array.NDArray"/>
    <fail message="No Array available" unless="array.present"/>

    <!--  Need NDX -->
    <available property="ndx.present"
               classpathref="classpath"
               classname="uk.ac.starlink.ndx.Ndx"/>
    <fail message="No NDX available" unless="ndx.present"/>

    <!--  Need JNIAST -->
    <available property="jniast.present"
               classpathref="classpath"
               classname="uk.ac.starlink.ast.Grf"/>
    <fail message="No JNIAST available" unless="jniast.present"/>

    <!--  Need Table -->
    <available property="table.present"
               classpathref="classpath"
               classname="uk.ac.starlink.table.StarTable"/>
    <fail message="No Table available" unless="table.present"/>

    <available property="util.present"
               classpathref="classpath"
               classname="uk.ac.starlink.util.SourceReader"/>
    <fail message="No Util available" unless="util.present"/>

    <!--  Would like JUnit for testing -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images) should also be copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

      <!-- Exclude any Java files in the source tree that should not be
       !   compiled -->
      <exclude name="**/README*"/>
    </javac>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs) on and, if
   !  appropriate, defines the application entrance point. The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <zip destfile="${dist.lib.pkg}/${name}_src.zip" basedir="${java.dir}"/>

    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>FITS</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink FITS classes - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="fits/fits.jar"/>
         <extension name="TAMFITS" href="tamfits.jnlp"/>
         <extension name="ARRAY" href="array.jnlp"/>
         <extension name="HDX" href="hdx.jnlp"/>
         <extension name="NDX" href="ndx.jnlp"/>
         <extension name="JNIAST" href="jniast.jnlp"/>
         <extension name="TABLE" href="table.jnlp"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution 
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <!--<zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>-->
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <!--<zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>-->

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <!--<tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>-->
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <!--<tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>-->

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>
    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz" 
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2" 
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories. 
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory. 
     !   Note exact format is required.-->
   <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

    <!-- Make sure that the expected file structure exists, some
         of these files can be missing if originally empty -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Do normal install, but with many targets switched off-->
    <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}" failonerror="false"/>

  </target>


  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  The documentation is created from the Java sources. Should also
   !  extend this to include the possibility of other miscellaneous
   !  documentation (FAQs etc.).
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
         <exclude name="**/support/*"/>
         <exclude name="**/testcases/*"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>
  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">
    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>
  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->

    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/support/*"/>
          <exclude name="**/makefile"/>
          <exclude name="**/testcases/*"/>
          <exclude name="**/VERSION"/>
          <exclude name="**/README"/>
          <exclude name="**/.*"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">
    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >
      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="tests-classpath"/>
    </javac>
  </target>


  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">
      <classpath refid="tests-classpath"/>

      <sysproperty key="java.io.tmpdir" value="${build.tests.loc}"/>
      <sysproperty key="java.library.path" value="${star.lib.arch}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="plain" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test*"/>
        </fileset>
      </batchtest>

    </junit>
  </target>


  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">
      <sysproperty key="java.io.tmpdir" value="${build.tests}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="java.library.path" value="${star.lib.arch}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>
    </junit>
  </target>



  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   ! 
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "../project.dtd">

<!--
 !   FROG build file
 !
 !   This file describes how to build the FROG package from a source
 !   release. It requires Apache ANT and a Java Development Kit.
 !
 !   In addition FROG may have requirements for other "core" and
 !   "third-party" packages to complete the compilation and any
 !   testing.
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> configures the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> install a runonly distribution into Starlink tree
 !      jars             -> creates the package jar file
 !      javadocs         -> creates the API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> run up FROG from local build
 !
 !   Authors:
 !      Alasidar Allan (Starlink, University of Exeter)
 !      Peter W. Draper (Starlink, Durham University)
 !
 !   History:
 !     26-NOV-2002 (AA):
 !        Modified to build FROG.
 !     26-JUL-2002 (PWD):
 !        Original Version used to build SPLAT.
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for FROG" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar and shareable library tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="FROG"/>
  <property name="name" value="frog"/>
  <property name="version" value="0.7.0"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.frog"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>
  <property name="build.jni" value="${build.dir}/jni"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- JNIAST -->
    <pathelement location="${star.jar.dir}/jniast/jniast.jar"/>

    <!-- NDArray-->
    <pathelement location="${star.jar.dir}/array/array.jar"/>

    <!-- Help-->
    <pathelement location="${star.jar.dir}/help/help.jar"/>
    
    <!-- HDX -->
    <!--<pathelement location="${star.jar.dir}/hdx/hdx.jar"/>-->

    <!-- SOAP Server -->
    <pathelement location="${star.jar.dir}/soapserver/lib/soapserver/soapserver.jar"/>
  
  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">
    <pathelement location="${star.build.dir}/array/lib/array/array.jar"/>
    <pathelement location="${star.build.dir}/jniast/lib/jniast/jniast.jar"/>
    <!--<pathelement location="${star.build.dir}/hdx/lib/hdx/hdx.jar"/>-->
    <pathelement location="${star.build.dir}/soapserver/lib/soapserver/soapserver.jar"/>
  </extclasspath>

  <!-- Local third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, so
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property 
   !   "extra.class.path" (which can be defined locally using say 
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
    <path refid="local.classpath"/>
    <path refid="built.classpath"/>
    <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath -->
  <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!--  Need NDArray -->
    <available property="array.present"
               classpathref="classpath"
               classname="uk.ac.starlink.array.NDArray"/>

    <fail message="No NDArray available" unless="array.present"/>

    <!--  Need JNIAST -->
    <available property="jniast.present"
               classpathref="classpath"
               classname="uk.ac.starlink.ast.Grf"/>

    <fail message="No JNIAST available" unless="jniast.present"/>

    <!--  Need NDX -->
    <available property="ndx.present"
               classpathref="classpath"
               classname="uk.ac.starlink.ndx.Ndx"/>

    <fail message="No NDX available" unless="ndx.present"/>

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>
  </target>


  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>

  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images) should also be copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           optimize="${optimize}">

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/deploy.wsdd"/>
        <include name="**/images/**"/>
        <include name="help/**"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>

    <!-- Build any shareable libraries needed to support this package.
     !   This goes straight into the distribution directory to save on
     !   space, and to make it immediately available to locally built
     !   packages. None at present so skipped  -->
    <!--antcall target="execute_mk_script">
      <param name="mk.action" value="build"/>
    </antcall-->

  </target>

  <!--
   !  ===================================
   !  Execute shareable library MK script
   !  ===================================
   !
   !  Execute the "mk" script that creates the package shareable
   !  library. The action performed is controlled by the "mk.action"
   !  property that should be defined before an antcall to this
   !  target.
   !-->
  <target name="execute_mk_script">

    <!-- Execute the given action for all known operating system types.
     !   This uses modified mk and makefiles from an old-style system
     !   which should be stored in ${src.jni.dir} along with the source
     !   code. Note some of these OS names seem to change from time to
     !   time and across JVMs, so beware. Clearly this is not portable.
     !-->

    <!-- Copy all source code into the build directory (keeps any
     !   intermediary files out of the source tree) -->
    <copy todir="${build.jni}">
      <fileset dir="${src.jni.dir}" includes="*"/>
    </copy>
    <chmod perm="ugo+rx" dir="${build.jni}" includes="*"/>

    <!-- Local and installed versions of any shareable libraries that we
     !   require to resolve against in a form for the UNIX "ld" command
     !-->
    <property name="jniast.share"
        value="-L${star.jar.dir} -L${star.build.dir}/jniast/lib -ljniast"/>
    <property name="java.shareables" value="${jniast.share}"/>

    <mkdir dir="${dist.lib}"/>
    
    <echo message="java.home=${java.home}"/>
    
    <exec dir="${build.jni}" executable="${build.jni}/mk" os="Linux">
      <env key="SYSTEM" value="ix86_Linux"/>
      <env key="JAVA_SYSTEM" value="linux"/>
      <env key="JAVA_HOME" value="${java.home}/.."/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${dist.lib}"/>
      <arg line="${mk.action}"/>
    </exec>

    <exec dir="${build.jni}" executable="${build.jni}/mk" os="SunOS">
      <env key="SYSTEM" value="sun4_Solaris"/>
      <env key="JAVA_SYSTEM" value="solaris"/>
      <env key="JAVA_HOME" value="${java.home}/.."/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${dist.lib}"/>
      <arg line="${mk.action}"/>
    </exec>

    <exec dir="${build.jni}" executable="${build.jni}/mk" os="OSF1">
      <env key="SYSTEM" value="alpha_OSF1"/>
      <env key="JAVA_SYSTEM" value="alpha"/>
      <env key="JAVA_HOME" value="${java.home}/.."/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${dist.lib}"/>
      <arg line="${mk.action}"/>
    </exec>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs) on and, if
   !  appropriate, defines the application entrance point. The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Main-Class"
                   value="uk.ac.starlink.frog.FrogMain"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
       <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
    </signjar>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>FROG - A Time Series Analysis Package</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink FROG - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="frog/frog.jar"/>
         <extension name="FROG-PARTS" href="${name}-parts.jnlp"/>
         <extension name="ASTGUI" href="astgui.jnlp"/>
         <extension name="ARRAY" href="array.jnlp"/>
         <extension name="JNIAST" href="jniast.jnlp"/>
         <extension name="FITS" href="fits.jnlp"/>
         <extension name="HDS" href="hds.jnlp"/>
         <extension name="HELP" href="help.jnlp"/>
         <extension name="TABLE" href="table.jnlp"/>
         <extension name="TOPCAT-PARTS" href="topcat-parts.jnlp"/>
       </resources>
       <application_desc main_class="uk.ac.starlink.frog.FrogMain"/>
     </jnlp>

     <!-- May be needed as a component so provide that too -->
     <jnlp toFile="${dist.lib}/${name}-parts.jnlp" href="${name}-parts.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>FROG - A Time Series Analysis Package</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink FROG - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin.pkg}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <mkdir dir="${dist.etc.pkg}"/>

    <!-- Copy any startup scripts etc. -->
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>
    <chmod perm="ugo+rx" dir="${dist.lib}" type="file" includes="libfrog*"
           failonerror="${chmod.fail}"/>
  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>
    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>

    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin.pkg}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.etc.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory. 
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.bin.pkg}
</echo>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
        <include name="**/libfrog.*"/>
      </fileset>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <mkdir dir="${dist.etc.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall" 
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  The documentation is created from the Java sources. Should also
   !  extend this to include the possibility of other miscellaneous
   !  documentation (FAQs etc.).
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
         <exclude name="**/*.gif"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">
    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>
  </target>

  <!--
   !   ==========================================
   !   Creates the API documentation java sources
   !   ==========================================
   !
   !  Does nothing.
   !-->
  <target name="javadoc-sources"
          description="-> does nothing">
  </target>


  <!-- Pattern for javadoc-sources when enabled -->
  <!-- Exclude broken and test files etc. from the document -->
  <fileset dir="${java.dir}" defaultexcludes="yes">
        <include name="**/*.java"/>
        <exclude name="**/*.gif"/>
  </fileset>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   ! Note these are not JUnit based
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">
<!--
    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           deprecation="${deprecation}" >
      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="tests-classpath"/>
    </javac>
 -->
  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   ! Note these are not JUnit based.
   !-->
  <target name="test"
          depends="compile-tests">
    <!-- Run up FROG from the local build -->
  <!--
   ! Test commented out as it's not a unit test, fails when headless,
   ! and never returns (MBT).
   !
   !<java classname="uk.ac.starlink.frog.FrogMain" fork="true">
   !  <classpath refid="tests-classpath"/>
   !  <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
   !</java>
   !-->
  </target>
  <target name="testui"
          depends="compile-tests">
    <!-- Run up FROG from the local build -->
    <java classname="uk.ac.starlink.frog.FrogMain" fork="true">
      <classpath refid="tests-classpath"/>
    </java>
  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   HDS build file
 !
 !   This file describes how to build the HDS package from a source
 !   release. It requires Apache ANT and a Java Development Kit.
 !
 !   In addition HDS may have requirements for other "core" and
 !   "third-party" packages to complete the compilation and any
 !   testing.
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> install a runonly distribution into Starlink tree
 !      jars             -> creates the package jar file
 !      javadocs         -> creates the API documentation
 !      javadoc-sources  -> make source files for release API documention
 !!
 !! test targets yet to be done.
 !!
 !   Authors:
 !      Peter W. Draper (2-JUL-2002)
 !      Mark Taylor (13-AUG-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for HDS" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- Directory containing native libraries. -->
  <property name="star.lib.arch" value="${star.install}/lib/${os.arch}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="HDS"/>
  <property name="name" value="hds"/>
  <property name="version" value="0.1"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.hds"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.4"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="true"/>
  <property name="junit.filtertrace" value="off"/>
  <property name="junit.summary" value="no"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that 
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may 
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed). 
   !-->
  <extclasspath id="installed.classpath">

    <!-- JUnit -->
    <pathelement location="${star.jar.dir}/junit/junit.jar"/>

    <!-- JNIHDS -->
    <pathelement location="${star.jar.dir}/jnihds/jnihds.jar"/>

    <!-- NDX -->
    <pathelement location="${star.jar.dir}/ndx/ndx.jar"/>
    
  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">
    <pathelement location="${star.build.dir}/junit/lib/junit/junit.jar"/>
    <pathelement location="${star.build.dir}/jnihds/lib/jnihds/jnihds.jar"/>
  </extclasspath>

  <path id="built.classpath">

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->
  
  </path>

  <!-- Extra user-defined classpath. This is set by the property 
   !   "extra.class.path" (which can be defined locally using say 
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath -->
  <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>
  <property name="classpath.value" refid="classpath"/>
  <property name="local.classpath.value" refid="local.classpath"/>
  <property name="built.classpath.value" refid="built.classpath"/>
  <property name="installed.classpath.value" refid="installed.classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages" 
          unless="runonly.install">

    <!--  Need JNIHDS -->
    <available property="jnihds.present"
               classpathref="classpath"
               classname="uk.ac.starlink.hds.HDSObject"/>

    <fail message="No JNIHDS available" unless="jnihds.present"/>

    <!--  Would like JUnit for testing -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images) should also be copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

      <!-- Exclude any Java files in the source tree that should not be
       !   compiled -->
      <exclude name="**/README*"/>
    </javac>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs) on and, if
   !  appropriate, defines the application entrance point. The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <zip destfile="${dist.lib.pkg}/${name}_src.zip" basedir="${java.dir}"/>
   
    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>HDS API</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink ${Name} - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="hds/hds.jar"/>
         <extension name="JNIHDS" href="jnihds.jnlp"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution 
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <!--<zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>-->
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <!--<zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>-->

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <!--<tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>-->
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <!--<tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>-->

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>
    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz" 
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2" 
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories. 
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory. 
     !   Note exact format is required.-->
   <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

    <!-- Make sure that the expected file structure exists, some
         of these files can be missing if originally empty -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Do normal install, but with many targets switched off-->
    <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}" failonerror="false"/>

  </target>


  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  The documentation is created from the Java sources. Should also
   !  extend this to include the possibility of other miscellaneous
   !  documentation (FAQs etc.).
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             source="${source.version}"
             windowtitle="${Name} API"
             doctitle="${Name}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
         <exclude name="**/support/*"/>
         <exclude name="**/testcases/*"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>
  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">
    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>
  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->

    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/support/*"/>
          <exclude name="**/makefile"/>
          <exclude name="**/testcases/*"/>
          <exclude name="**/VERSION"/>
          <exclude name="**/README"/>
          <exclude name="**/.*"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">
    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >
      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="tests-classpath"/>
    </javac>
  </target>


  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">
      <classpath refid="tests-classpath"/>

      <sysproperty key="java.io.tmpdir" value="${build.tests}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="java.library.path" value="${star.lib.arch}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="plain" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test*"/>
        </fileset>
      </batchtest>

    </junit>
  </target>


  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">
      <sysproperty key="java.io.tmpdir" value="${build.tests}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="java.library.path" value="${star.lib.arch}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>
    </junit>
  </target>



  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   ! 
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>
<!DOCTYPE project SYSTEM "../project.dtd">

<!--
 !   HDX build file
 !
 !   This file describes how to build the HDX package from a source
 !   release. It requires Apache ANT and a Java Development Kit.
 !
 !   In addition HDX may have requirements for other "core" and
 !   "third-party" packages to complete the compilation and any
 !   testing.
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> install a runonly distribution into Starlink tree
 !      jars             -> creates the package jar file
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !!
 !! test targets yet to be done.
 !!
 !   Authors:
 !      Peter W. Draper (2-JUL-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for HDX" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.install}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url"
    value="http://java.sun.com/j2se/${java.specification.version}/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="HDX"/>
  <property name="name" value="hdx"/>
  <property name="version" value="0.1"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.hdx"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="true"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="on"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that 
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may 
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed). 
   !-->
  <extclasspath id="installed.classpath">

    <!-- FITS -->
    <pathelement location="${star.jar.dir}/fits/fits.jar"/>
    
    <!-- HDS -->
    <pathelement location="${star.jar.dir}/hds/hds.jar"/>

    <!-- JNIAST -->
    <pathelement location="${star.jar.dir}/jniast/jniast.jar"/>
    
  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">
    <pathelement location="${star.build.dir}/fits/lib/fits/fits.jar"/>
    <pathelement location="${star.build.dir}/jniast/lib/jniast/jniast.jar"/>
  </extclasspath>

  <!-- Local third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, so
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <!--<fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>-->
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->
  
  </path>

  <!-- Extra user-defined classpath. This is set by the property 
   !   "extra.class.path" (which can be defined locally using say 
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath -->
 <path id="tests-classpath">
    <!-- XXX ARGH  How do I tell JUnit about my excluded.properties file? -->
    <!--
    <pathelement location="${src.jars.dir}/junit/runner/excluded.properties"/>
    <pathelement location="${src.jars.dir}/junit/runner"/>
    <pathelement location="${src.jars.dir}"/>
    -->
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    ============
   !    Library path
   !    ============
   !    Used by test targets for locating native libraries.
   !-->
  <path id="tests-libpath.id">
    <pathelement path="${java.library.path}"/>
    <pathelement location="${star.jar.dir}/${os.arch}"/>
  </path>
  <property name="tests-libpath" refid="tests-libpath.id"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages" 
          unless="runonly.install">

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images) should also be copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages, build_sources"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac deprecation="${deprecation}"
        source="1.4"
        destdir="${build.classes}"
        debug="${debug}"
        srcdir="${build.java}"
        optimize="${optimize}">

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

      <!-- Exclude any Java files in the source tree that should not be
       !   compiled -->
      <!--<exclude name="**/NdxDomImpl.java"/> -->
      <exclude name="**/README*"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/normalize-hdx.xslt"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <!--<copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>-->

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs) on and, if
   !  appropriate, defines the application entrance point. The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>HDX</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink HDX - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="${name}/${name}.jar"/>
         <extension name="UTIL" href="util.jnlp"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <!--<mkdir dir="${dist.bin.pkg}"/>-->
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <!--<mkdir dir="${dist.etc.pkg}"/>-->

    <!-- Copy any startup scripts etc. -->
    <!--<copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>-->

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
    <!--<copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>-->

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
    <!--<chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>-->

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution 
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <!--<zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>-->
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <!--<zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>-->

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <!--<tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>-->
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <!--<tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>-->

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>
    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz" 
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2" 
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <!--<delete dir="${dist.bin}"/>-->
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <!--<delete dir="${dist.etc}"/>-->

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories. 
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <!--<mkdir dir="${star.bin.pkg}"/>-->
    <mkdir dir="${star.lib.pkg}"/>
    <!--<mkdir dir="${star.etc.pkg}"/>-->
    <mkdir dir="${star.docs.pkg}"/>

    <!--<loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>-->

    <!--<chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>-->

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory. 
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory-->
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <!--<mkdir dir="${dist.bin.pkg}"/>-->
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <!--<mkdir dir="${dist.etc.pkg}"/>-->

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall" 
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  The documentation is created from the Java sources. Should also
   !  extend this to include the possibility of other miscellaneous
   !  documentation (FAQs etc.).
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
      	     source="1.4">
      <!-- classpathref="classpath" probably useful eventually, but
      MASSIVELY confuses things as long as there are any hdx.jar files
      elsewhere in the classpath -->

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
        <include name="**"/>
        <exclude name="**/support/*"/>
        <exclude name="**/testcases/*"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">
    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>
  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          depends="build_sources"
          description="-> make source files for release API documention"/>

  <!-- 
   !  Processes the raw source files to produce compilable java.
   !  This massages the source in different ways according to whether
   !  we are running JDK1.5 or 1.4.  These implement different levels
   !  of the DOM specification, and the DOM implementation has to be
   !  written differently in each case.
   !-->
  <target name="build_sources">

    <!-- Set the value of the uncomment.pattern property to "DOM3" under
     !   JDK1.5 or something which isn't going to crop up in the source 
     !   under 1.4. Use one of the new Java 1.5 classes to test for this. -->
    <condition property="uncomment.pattern" value="DOM3">
        <available classname="java.lang.ProcessBuilder" />
    </condition>
    <condition property="uncomment.pattern" value="NOT_APPEARING">
      <not>
        <isset property="uncomment.pattern"/>
      </not>
    </condition>
 
    <!-- Copy/edit the source files to the build tree from where they will
     !   be compiled.  Any source lines which start "//" followed by the
     !   value of the ucomment.pattern string will be uncommented, otherwise
     !   they will be left alone. -->
    <mkdir dir="${build.java}"/>
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/NdxDomImpl.java"/>
          <exclude name="**/support/*"/>
          <exclude name="**/makefile"/>
          <exclude name="**/testcases/*"/>
          <exclude name="**/VERSION"/>
          <exclude name="**/README"/>
      </fileset>
      <filterchain>
        <tokenfilter>
          <linetokenizer/>
          <replaceregex pattern="^//${uncomment.pattern} " replace=""/>
        </tokenfilter>
      </filterchain>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac deprecation="${deprecation}" 
      source="1.4"
      destdir="${build.tests}"
      debug="${debug}"
      srcdir="${tests.dir}">

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath-value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="Hdx.properties"
                   value="${tests.etc.dir}/Hdx.properties"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <!--formatter type="brief" usefile="true"/-->
      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <!-- <include name="**/JUnit*"/> -->
          <include name="**/*Test.java"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value" 
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   ! 
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>

<!-- Local Variables: -->
<!-- mode: xml -->
<!-- sgml-indent-data: t -->
<!-- sgml-indent-step: 2 -->
<!-- End: -->
<?xml version="1.0"?>

<!--
 !   Help build file
 !
 !   This file describes how to build and install Help from
 !   source and binary releases. Help is a class library
 !   (i.e. provides an API and related documentation).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (13-FEB-2004)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for Help" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="HELP"/>
  <property name="name" value="help"/>
  <property name="version" value="1.0"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.help"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.4"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Any achitecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- {Other packages} -->
    <!--<pathelement location="${star.jar.dir}/{package1}/{package1.jar}"/>-->

  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">

    <!--<pathelement 
       location="${star.build.dir}/{package1}/lib/{package1}/{package1.jar}"/>-->

  </extclasspath>

  <!-- "Local" third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, say
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property
   !   "extra.class.path" (which can be defined locally using say
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath, add tests.dir and tests.etc.dir so that
   !   resources may be located there -->
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    ============
   !    Library path
   !    ============
   !    Used by test targets for locating native libraries.
   !-->
  <path id="tests-libpath.id">
    <pathelement path="${java.library.path}"/>
    <pathelement location="${star.jar.dir}/${os.arch}"/>
  </path>
  <property name="tests-libpath" refid="tests-libpath.id"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!--  {Example package1} -->
    <!--<available property="{package1}.present"
               classpathref="classpath"
               classname="uk.ac.starlink.{package1}.{MainClass}"/>
    <fail message="No {package1} available" unless="{package1}.present"/>-->

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here. 
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
      <!--<exclude name="**/{Retired1.java}"/>-->
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/images/**"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Sign all jar files, except those signed by a third party -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip" 
               excludes="**/jhall.jar"/>
    </signjar>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this class library.
     !   This goes into "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">

      <information>
         <title>Help - help utilities package</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink Help - Webstart edition"</description>
         <offline_allowed/>
       </information>

       <security>
          <all_permissions/>
       </security>

       <resources>
         <j2se version="1.5+"/>
         <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip" 
                  excludes="**/jhall.jar"/>
         <extension name="JAVAHELP" href="javahelp.jnlp"/>
       </resources>

       <!-- This is a component -->
       <component_desc/>

    </jnlp>

    <!-- Javahelp is signed by SUN so needs its own JNLP file -->
    <jnlp toFile="${dist.lib}/javahelp.jnlp" href="javahelp.jnlp"
          codebase="${webstart.codebase}">

      <information>
         <title>Javahelp</title>
         <vendor>SUN</vendor>
         <homepage href="http://java.sun.com/products/javahelp"/>
         <description>"Javahelp - Webstart edition"</description>
         <offline_allowed/>
       </information>

       <security>
          <all_permissions/>
       </security>

       <resources>
         <j2se version="1.5+"/>
         <fileset dir="${dist.lib}" includes="**/jhall.jar"/>
       </resources>

       <!-- This is a component -->
       <component_desc/>

     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <!--<mkdir dir="${dist.bin.pkg}"/>-->
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <!--<mkdir dir="${dist.etc.pkg}"/>-->

    <!-- Copy any configuration/helper scripts etc. -->
    <!--<copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>-->

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
    <!--<chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>-->

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <!--<zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>-->
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <!--<zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>-->

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <!--<tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>-->
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <!--<tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>-->

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <!--<delete dir="${dist.bin}"/>-->
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <!--<delete dir="${dist.etc}"/>-->

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
    <!--<mkdir dir="${star.bin.pkg}"/>-->
    <mkdir dir="${star.lib.pkg}"/>
    <!--<mkdir dir="${star.etc.pkg}"/>-->
    <mkdir dir="${star.docs.pkg}"/>

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
    <!--<loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>-->

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory-->
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <!--<mkdir dir="${dist.bin.pkg}"/>-->
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <!--<mkdir dir="${dist.etc.pkg}"/>-->

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/JUnit*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   !  =====================
   !  Run non-JUnit UI test
   !  =====================
   ! 
   ! Use this to test interaction with a UI.
   !-->
  <target name="uitest"
          depends="compile-tests"
          description="Run up UI for testing">

    <!-- copy helpsets -->
    <copy todir="${build.tests}">
      <fileset dir="${tests.dir}">
        <exclude name="**/*.java"/>
      </fileset>
    </copy>

    <java classname="TestHelpFrame" fork="true">
      <classpath refid="tests-classpath"/>
    </java>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   JAIUtil build file
 !
 !   This file describes how to build and install JAIUtil from
 !   source and binary releases. JAIUtil is a class library
 !   (i.e. provides an API and related documentation).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for JAIUtil" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="JAIUtil"/>
  <property name="name" value="jaiutil"/>
  <property name="version" value="1.1"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.jaiutil"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="true"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- HDX -->
    <pathelement location="${star.jar.dir}/hdx/hdx.jar"/>

    <!-- NDX -->
    <pathelement location="${star.jar.dir}/ndx/ndx.jar"/>

    <!-- Array -->
    <pathelement location="${star.jar.dir}/array/array.jar"/>

  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">

    <pathelement location="${star.build.dir}/hdx/lib/hdx/hdx.jar"/>
    <pathelement location="${star.build.dir}/ndx/lib/ndx/ndx.jar"/>
    <pathelement location="${star.build.dir}/array/lib/array/array.jar"/>

  </extclasspath>

  <!-- "Local" third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, say
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <!--<fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>-->
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property
   !   "extra.class.path" (which can be defined locally using say
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath, add tests.dir and tests.etc.dir so that
   !   resources may be located there -->
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!-- HDX -->
    <available property="hdx.present"
               classpathref="classpath"
               classname="uk.ac.starlink.hdx.HdxContainer"/>

    <fail message="No HDX available" unless="hdx.present"/>

    <!-- NDX -->
    <available property="ndx.present"
               classpathref="classpath"
               classname="uk.ac.starlink.ndx.Ndx"/>

    <fail message="No NDX available" unless="ndx.present"/>

    <!-- Array -->
    <available property="array.present"
               classpathref="classpath"
               classname="uk.ac.starlink.array.NDArray"/>

    <fail message="No Array available" unless="array.present"/>

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here. 
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           optimize="${optimize}">

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
      <exclude name="**/ImageDisplay.java"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <!--<copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/{package.support.files}"/>
        <include name="**/{more.package.support.files}"/>
      </fileset>
    </copy>-->

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <!--<mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>-->

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>
   
    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>
  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>JAIUTIL</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink JAIUTIL - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="jaiutil/jaiutil.jar"/>
         <extension name="HDX" href="hdx.jnlp"/>
         <extension name="NDX" href="ndx.jnlp"/>
         <extension name="ARRAY" href="array.jnlp"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <!--<mkdir dir="${dist.bin.pkg}"/>-->
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <!--<mkdir dir="${dist.etc.pkg}"/>-->

    <!-- Copy any configuration/helper scripts etc. -->
    <!--<copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>-->

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
    <!--<copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>-->

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
    <!--<chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>-->

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <!--<zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>-->
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <!--<zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>-->

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <!--<tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>-->
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <!--<tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>-->

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <!--<delete dir="${dist.bin}"/>-->
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <!--<delete dir="${dist.etc}"/>-->

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <!--<property name="star.bin" value="${star.install}/bin"/>-->
    <property name="star.lib" value="${star.install}/lib"/>
    <!--<property name="star.etc" value="${star.install}/etc"/>-->
    <property name="star.docs" value="${star.install}/docs"/>
    <!--<property name="star.bin.pkg" value="${star.bin}/${name}"/>-->
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <!--<property name="star.etc.pkg" value="${star.etc}/${name}"/>-->
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <!--<mkdir dir="${star.bin.pkg}"/>-->
    <mkdir dir="${star.lib.pkg}"/>
    <!--<mkdir dir="${star.etc.pkg}"/>-->
    <mkdir dir="${star.docs.pkg}"/>

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
    <!--<loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>-->

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory-->
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <!--<mkdir dir="${dist.bin.pkg}"/>-->
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <!--<mkdir dir="${dist.etc.pkg}"/>-->

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             classpathref="classpath">

      <!-- Exclude broken and test files etc. from the document -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
          <exclude name="**/ImageDisplay.java"/>
          <exclude name="**/MyTileCache.java"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           deprecation="${deprecation}" >

      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          description="-> does nothing"/>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="uitest"
          depends="run-tests"
          description="-> run JUnit tests (UI)"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/JUnit*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <classpath refid="tests-classpath"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

  <!-- 
   ! Run up JSwat. Only works at Durham as pdraper...
   !-->
  <target name="jswat"
          depends="compile-tests">

    <path id="jswat-classpath">
       <path refid="tests-classpath"/>
       <pathelement 
           location="/loc/pwdb/pdraper/java/jswat/jswat-2.10/jswat.jar"/>
       <pathelement location="/stardev/java/jdk-1.4.0_01/lib/tools.jar"/>
    </path> 
    <java classname="com.bluemarsh.jswat.Main" fork="true">
      <classpath refid="jswat-classpath"/>
    </java>
  </target>


</project>
<?xml version="1.0"?>

<!--
 !  Jetty build file
 !
 !   This file describes how to install the local Jetty package from its
 !   released state. It requires Apache ANT and a Java Development Kit.
 !
 !   The main targets are:
 !
 !      build            -> makes copies of local files that will be modified
 !      clean            -> removes local copies
 !      deinstall        -> undo the install target
 !      dist             -> makes package into dist state
 !      export           -> creates the full distribution archives
 !      export-runonly   -> same as export
 !      export-source    -> same as export
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> same as install
 !      jars             -> add manifest and sign jar files
 !      javadocs         -> does nothing
 !      javadoc-sources  -> does nothing
 !
 !   The targets that do nothing are provided for compatibility with
 !   the normal build system.
 !!
 !! test targets yet to be done.
 !!
 !   Authors:
 !      Peter W. Draper (9-JUL-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for Jetty" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directort by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="Jetty"/>
  <property name="name" value="jetty"/>
  <property name="version" value="5.1.1"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>
  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing any unmodified jars of this package -->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Distribution directories, these are the actual state of this
   !   package at all times -->
  <property name="dist.dir" value="${basedir}"/>

  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase"
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://jetty.mortbay.org/jetty/"/>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

  </target>

  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !   Just makes local copies of the package jar files so that they
   !   can be safely modified.
   !-->
  <target name="build"
          depends="prepare"
          description="-> make local copies of files for modification">

    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>

  </target>

  <!--
   !   ===========================
   !   Create the package jar file
   !   ===========================
   !
   !   This just updates the manifest and signs with using the local
   !   keystore.
   !-->
  <target name="jars"
          depends="build"
          description="-> packages jar files">

    <!-- Add the manifest to the main jar file. -->
    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/org.mortbay.jetty.jar" basedir="${dist.dir}"
         update="true" excludes="**">

      <!-- Create the manifest, note wraps in column 80 so avoid
       !   this. TODO: perform this task automatically?-->
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
    </signjar>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>Jetty://</title>
         <vendor>Mort Bay Consulting</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Jetty:// - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =============================
   !   Create the local distribution
   !   =============================
   !
   !  Nothing to do, this package is permanently in this condition.
   !-->
  <target name="dist"
          depends="jars,webstart"
          description="-> make package ready for distribution">
  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  package.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  Same as export, except for the name.
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

    <antcall target="create_archives">
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. Same as export, except for the
   !  name.
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

    <antcall target="create_archives">
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required.
   ! For this package these are all the same just set the property
   ! "archive.name" to define what name to use for the outfile
   ! files. The archives are also written into the directory
   ! ${star.archive.dir} (the local directory by default).
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>
    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib"/>

    </zip>

    <tar longfile="gnu" destfile="${archive.name}.tar">

      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib"/>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>
  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !
   !   Removes copies of jar files.
   !-->
  <target name="clean"
          description="-> removes local copies">

    <delete dir="${dist.lib}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the package into another set of directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>

    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}"/>
    </loggedcopy>
   <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   =========================================
   !
   ! Same as install.
   !-->
  <target name="install-runonly"
          description="-> install distribution into Starlink tree">

     <antcall target="install"/>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   ! that were copied into place by the install target.
   !-->
 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Does nothing.
   !-->
  <target name="javadocs"
          description="-> does nothing">
  </target>

  <!--
   !   ==========================================
   !   Creates the API documentation java sources
   !   ==========================================
   !
   !  Does nothing.
   !-->
  <target name="javadoc-sources"
          description="-> does nothing">
  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          description="-> does nothing"/>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   JNIAST build file
 !
 !   This file describes how to build the JNIAST package from a source
 !   release. It requires Apache ANT and a Java Development Kit.
 !
 !      build            -> compiles the source code
 !      build-native     -> builds native libraries from C sources
 !      build-source     -> builds java source code from perl and AST
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> install a runonly distribution into Starlink tree
 !      jars             -> creates the package jar file
 !      javadocs         -> creates the API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit tests
 !
 !   Authors:
 !      Peter W. Draper (2-JUL-2002)
 !      Mark Taylor (31-JUL-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for JNIAST" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!-- The environment CLASSPATH is ignored by Ant tasks. -->
  <property name="build.sysclasspath" value="ignore"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <!-- Note this version is the same as the lowest version of AST required
   !   for this package to build and run normally.  Higher versions of
   !   AST may be desirable e.g. if they contain bugfixes.  The test
   !   target may fail if a particular version, later than this, is
   !   not installed (is this sensible behaviour?) -->
  <property name="Name" value="JNIAST"/>
  <property name="name" value="jniast"/>
  <property name="version" value="5.1"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.ast"/>
  <property name="package.path" value="uk/ac/starlink/ast"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.4"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="true"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.jni" location="${build.dir}/jni"/>
  <property name="build.lib" location="${build.dir}/lib"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants -->
  <property name="dist.dir" value="${basedir}"/>

  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.dir}/bin/${name}"/>
  <property name="dist.lib.pkg" value="${dist.dir}/lib/${name}"/>
  <property name="dist.docs.pkg" value="${dist.dir}/docs/${name}"/>
  <property name="dist.etc.pkg" value="${dist.dir}/etc/${name}"/>
  <property name="dist.javadocs" value="${dist.dir}/docs/${name}/javadocs"/>

  <!-- Architecture-specific files (shared libraries) -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>
  <property name="src.lib.arch" value="${src.jars.dir}/${os.arch}"/>
  <property name="build.lib.arch" value="${build.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!-- Non-standard source file directories -->
  <property name="src.ast" value="${src.dir}/ast"/>
  <property name="src.jni" value="${src.dir}/jni"/>
  <property name="src.perl" value="${src.dir}/perl"/>
  <property name="jdk" value="${java.home}/.."/>
  <property name="stardev" value="/stardev"/>

  <!-- Non-standard build file directories -->
  <property name="build.jni" value="${build.dir}/jni"/>

  <!-- Non-standard files -->
  <property name="perl" value="perl"/>
  <property name="ast.fac.err" value="fac_1521_err"/>
  <property name="shared.object" value="lib${name}.so"/>
  <property name="link.script" value="${name}_libraries"/>

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- Util -->
    <pathelement location="${star.jar.dir}/util/util.jar"/>

  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">
    <pathelement location="${star.build.dir}/util/lib/util/util.jar"/>
  </extclasspath>

  <path id="built.classpath">

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property 
   !   "extra.class.path" (which can be defined locally using say 
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
    <path refid="local.classpath"/>
    <path refid="built.classpath"/>
    <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath -->
  <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!-- Need Util -->
    <available property="util.present"
               classpathref="classpath"
               classname="uk.ac.starlink.util.Loader"/>
    <fail message="No Util available" unless="util.present"/>

    <!-- Need JUnit for testcases, not essential -->
    <condition property="testframework.present">
      <and>
        <available classpathref="tests-classpath"
                   classname="junit.framework.TestCase"/>
        <available classpathref="tests-classpath"
                   classname="uk.ac.starlink.util.TestCase"/>
      </and>
    </condition>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images) should also be copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages, build_classes, unpack_jni"
          unless="runonly.install"
          description="-> compiles the source code">

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}" includes="[none]"/>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <!--
     !  <mkdir dir="${dist.lib.pkg}"/>
     !  <copy todir="${dist.lib.pkg}">
     !  </copy>
     !-->

  </target>

  <!-- Build the java class files. -->
  <target name="build_classes">
    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}"
           optimize="${optimize}">
      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

      <!-- Exclude any Java files in the source tree that should not be
       !   compiled -->
      <exclude name="**/retired_code/*"/>
      <exclude name="**/*Test*"/>
    </javac>
  </target>


  <!-- Pulls the architecture-specific shared libraries out of the source
   !   jar files in which they live.  These jar files are in the CVS
   !   repository, they are not built as part of the normal build target.
   !   The one specific to the build-time architecture can be built
   !   using the 'build-native' target, but this requires more than the
   !   basic CVS files to work (e.g. it needs the stardev classic libraries).
   !-->
  <target name="unpack_jni">
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="i386"/>
    </antcall>
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="sparc"/>
    </antcall>
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="x86"/>
    </antcall>
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="ppc"/>
    </antcall>
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="amd64"/>
    </antcall>
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="x86_64"/>
    </antcall>
  </target>

  <!-- Architecture-specific JNI jar file unpacker -->
  <target name="unpack_jni_arch">
    <unjar src="${src.jars.dir}/${unpack.arch}/${name}_libs.jar"
           dest="${dist.lib}/${unpack.arch}">
      <patternset excludes="META-INF*/*"/>
    </unjar>
  </target>

  <!--
   !  ==================================================
   !  Builds all secondary source files from true source
   !  ==================================================
   !
   !  This processes Perl 'true' source files to generate some of the java
   !  source files and C source files.  Since it requires Perl, it is
   !  not a dependency of any of the other public targets, and is not
   !  be invoked as part of the normal build process.  It should be 
   !  invoked when the perl source files have been changed, and the
   !  resulting new 'source' files (in src/main and src/jni) checked in.
   !-->
  <target name="build-source"
          description="-> builds java source code from Perl and AST">

    <!-- Build the java classes which correspond to AST classes -->
    <antcall target="perl_to_java">
      <param name="pj.class" value="AstObject"/>
      <param name="pj.cfile" value="object.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="Box"/>
      <param name="pj.cfile" value="box.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="Channel"/>
      <param name="pj.cfile" value="channel.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="Circle"/>
      <param name="pj.cfile" value="circle.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="CmpFrame"/>
      <param name="pj.cfile" value="cmpframe.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="CmpMap"/>
      <param name="pj.cfile" value="cmpmap.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="CmpRegion"/>
      <param name="pj.cfile" value="cmpregion.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="DSBSpecFrame"/>
      <param name="pj.cfile" value="dsbspecframe.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="Ellipse"/>
      <param name="pj.cfile" value="ellipse.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="FitsChan"/>
      <param name="pj.cfile" value="fitschan.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="FluxFrame"/>
      <param name="pj.cfile" value="fluxframe.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="Frame"/>
      <param name="pj.cfile" value="frame.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="FrameSet"/>
      <param name="pj.cfile" value="frameset.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="GrismMap"/>
      <param name="pj.cfile" value="grismmap.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="Interval"/>
      <param name="pj.cfile" value="interval.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="KeyMap"/>
      <param name="pj.cfile" value="keymap.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="LutMap"/>
      <param name="pj.cfile" value="lutmap.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="Mapping"/>
      <param name="pj.cfile" value="mapping.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="MathMap"/>
      <param name="pj.cfile" value="mathmap.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="MatrixMap"/>
      <param name="pj.cfile" value="matrixmap.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="NullRegion"/>
      <param name="pj.cfile" value="nullregion.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="PcdMap"/>
      <param name="pj.cfile" value="pcdmap.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="PermMap"/>
      <param name="pj.cfile" value="permmap.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="Plot"/>
      <param name="pj.cfile" value="plot.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="Polygon"/>
      <param name="pj.cfile" value="polygon.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="PolyMap"/>
      <param name="pj.cfile" value="polymap.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="PointList"/>
      <param name="pj.cfile" value="pointlist.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="Prism"/>
      <param name="pj.cfile" value="prism.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="RateMap"/>
      <param name="pj.cfile" value="ratemap.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="Region"/>
      <param name="pj.cfile" value="region.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="SelectorMap"/>
      <param name="pj.cfile" value="selectormap.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="ShiftMap"/>
      <param name="pj.cfile" value="shiftmap.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="SlaMap"/>
      <param name="pj.cfile" value="slamap.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="SkyFrame"/>
      <param name="pj.cfile" value="skyframe.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="SpecFluxFrame"/>
      <param name="pj.cfile" value="specfluxframe.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="SpecFrame"/>
      <param name="pj.cfile" value="specframe.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="SpecMap"/>
      <param name="pj.cfile" value="specmap.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="SphMap"/>
      <param name="pj.cfile" value="sphmap.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="Stc"/>
      <param name="pj.cfile" value="stc.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="StcCatalogEntryLocation"/>
      <param name="pj.cfile" value="stccatalogentrylocation.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="StcObsDataLocation"/>
      <param name="pj.cfile" value="stcobsdatalocation.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="StcResourceProfile"/>
      <param name="pj.cfile" value="stcresourceprofile.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="StcSearchLocation"/>
      <param name="pj.cfile" value="stcsearchlocation.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="SwitchMap"/>
      <param name="pj.cfile" value="switchmap.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="TimeFrame"/>
      <param name="pj.cfile" value="timeframe.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="TimeMap"/>
      <param name="pj.cfile" value="timemap.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="TranMap"/>
      <param name="pj.cfile" value="tranmap.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="UnitMap"/>
      <param name="pj.cfile" value="unitmap.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="WcsMap"/>
      <param name="pj.cfile" value="wcsmap.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="WinMap"/>
      <param name="pj.cfile" value="winmap.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="XmlChan"/>
      <param name="pj.cfile" value="xmlchan.c"/>
    </antcall>
    <antcall target="perl_to_java">
      <param name="pj.class" value="ZoomMap"/>
      <param name="pj.cfile" value="zoommap.c"/>
    </antcall>

    <!-- Build AstException C source -->
    <exec executable="${perl}"
          output="${src.jni}/AstException.c"
          logError="yes"
          failonerror="yes">
      <arg file="${src.perl}/AstException.pl"/>
      <arg value="-c"/>
      <arg file="${src.ast}/${ast.fac.err}"/>
    </exec>

    <!-- Build AstException Java source -->
    <exec executable="${perl}" 
          output="${java.dir}/${package.path}/AstException.java"
          logError="yes"
          failonerror="yes">
      <arg file="${src.perl}/AstException.pl"/>
      <arg value="-java"/>
      <arg file="${src.ast}/${ast.fac.err}"/>
    </exec>

    <!-- Build miscellaneous Java sources -->
    <exec executable="${perl}"
          output="${java.dir}/${package.path}/UinterpCalculator.java"
          logError="yes"
          failonerror="yes">
      <arg file="${src.perl}/UinterpCalculator.pl"/> 
    </exec>

  </target>

  <!-- Processes a perl file and AST C source file to generate a java source
   !   file.
   !   Parameters are:
   !      pj.class:  class of java source file to produce
   !      pj.cfile:  name of AST C source input file
   !-->
  <target name="perl_to_java">
    <echo message="Generating ${pj.class}.java"/>
    <exec executable="${perl}"
          output="${java.dir}/${package.path}/${pj.class}.java"
          logError="yes"
          failonerror="yes">
      <arg value="-I${src.perl}"/>
      <arg file="${src.perl}/${pj.class}.pl"/>
      <arg file="${src.ast}/${pj.cfile}"/>
    </exec>
  </target>


  <!--
   !  ============================================
   !  Build the native shared library from sources
   !  ============================================
   !
   !  This does the actual build of the shared library for the build-time
   !  architecture, and requires a stardev installation.  It is not a
   !  dependency of any of the other public targets, and should not be
   !  invoked as part of the normal build process.  It should be invoked
   !  periodically (when AST or JNIAST changes), once on each of the
   !  supported platforms, and the resulting new 'source' files 
   !  (shared library jar files) checked in.
   !
   !  Note that the C compilations may fail if an attempt is made to
   !  compile against the wrong AST version.
   !-->
  <target name="build-native"
          depends="assemble_jni"
          description="-> builds native library from C sources">

    <!-- Extract the existing libraries from the jar file. There may
     !   be more than one library per architecture (i386 Linux and OS X)
     !   and we want to keep the other libraries. The datestamps should 
     !   be in the past otherwise this will fail
     !-->
    <unjar dest="${build.lib.arch}">
      <fileset file="${src.lib.arch}/${name}_libs.jar"/>
    </unjar>


    <!-- Build the library -->
    <antcall target="execute_mk_script">
      <param name="mk.action" value="shared"/>
    </antcall>

    <!-- Jar it up and copy it into the source tree ready for CVS checkin -->
    <jar destfile="${src.lib.arch}/${name}_libs.jar"
         basedir="${build.lib.arch}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
      </manifest>
    </jar>
  </target>


  <!--
   !  ===================================
   !  Execute shareable library MK script
   !  ===================================
   !  Execute the "mk" script that creates the package shareable
   !  library. The action performed is controlled by the "mk.action"
   !  property that should be defined before an antcall to this
   !  target.
   !-->
  <target name="execute_mk_script">

    <!-- Execute the given action for all known operating system types.
     !   This uses modified mk and makefiles from an old-style system
     !   which should be stored in ${src.jni} along with the source
     !   code. Note some of these OS names seem to change from time to
     !   time and across JVMs, so beware. Clearly this is not portable.
     !   Since the different OSs are detected and catered for here,
     !   it would be possible to remove the mk step fairly easily and
     !   make could be invoked directly from here, if preferred.
     !-->

    <!-- Local and installed versions of any shareable libraries that we
     !   require to resolve against in a form for the UNIX "ld" command
     !-->
    <property name="java.shareables" value=""/>

    <mkdir dir="${build.lib.arch}"/>

    <echo message="java.home=${java.home}"/>

    <exec dir="${build.jni}" executable="${build.jni}/mk" os="Linux"
          failonerror="yes">
      <env key="SYSTEM" value="ix86_Linux"/>
      <env key="JAVA_SYSTEM" value="linux"/>
      <env key="STARLINK" value="${stardev}"/>
      <env key="ADDLIBS" value="-L${stardev.add}/lib"/>
      <env key="ADDINCS" value="-I${stardev.add}/include"/>
      <env key="ADDCFLAGS" value="${stardev.addcflags}"/>
      <env key="JDK" value="${jdk}"/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${build.lib.arch}"/>
      <arg line="${mk.action}"/>
    </exec>

    <exec dir="${build.jni}" executable="${build.jni}/mk" os="SunOS"
          failonerror="yes">
      <env key="SYSTEM" value="sun4_Solaris"/>
      <env key="JAVA_SYSTEM" value="${os.arch}"/>
      <env key="STARLINK" value="${stardev}"/>
      <env key="ADDLIBS" value="-L${stardev.add}/lib"/>
      <env key="ADDINCS" value="-I${stardev.add}/include"/>
      <env key="ADDCFLAGS" value="${stardev.addcflags}"/>
      <env key="JDK" value="${jdk}"/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${build.lib.arch}"/>
      <arg line="${mk.action}"/>
    </exec>

    <exec dir="${build.jni}" executable="${build.jni}/mk" os="Mac OS X"
          failonerror="yes" >
      <env key="SYSTEM" value="MacOSX"/>
      <env key="JAVA_SYSTEM" value="${os.arch}"/>
      <env key="STARLINK" value="${stardev}"/>
      <env key="ADDLIBS" value="-L${stardev.add}/lib"/>
      <env key="ADDINCS" value="-I${stardev.add}/include"/>
      <env key="ADDCFLAGS" value="${stardev.addcflags}"/>
      <env key="JDK" value="${jdk}"/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${build.lib.arch}"/>
      <env key="STARJAVA_LIB" value="${star.install}/lib/${os.arch}"/>
      <arg line="${mk.action}"/>
    </exec>

    <exec dir="${build.jni}" executable="${build.jni}/mk" os="OSF1"
          failonerror="yes">
      <env key="SYSTEM" value="alpha_OSF1"/>
      <env key="JAVA_SYSTEM" value="alpha"/>
      <env key="STARLINK" value="${stardev}"/>
      <env key="ADDLIBS" value="-L${stardev.add}/lib"/>
      <env key="ADDINCS" value="-I${stardev.add}/include"/>
      <env key="ADDCFLAGS" value="${stardev.addcflags}"/>
      <env key="JDK" value="${jdk}"/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${build.lib.arch}"/>
      <arg line="${mk.action}"/>
    </exec>

  </target>


  <!--
   !   Put all the source files required for compilation of the shared
   !   library in the build directory.  Some of these are copied directly
   !   from source directories, some are generated from perl source
   !   or using javah from class files.
   !-->
  <target name="assemble_jni" depends="prepare, build_classes">

    <copy todir="${build.jni}">
      <fileset dir="${src.jni}" includes="*.c *.h makefile mk ${link.script}"/>
      <fileset dir="${src.ast}" includes="grf.h"/>
      <fileset dir="${src.ast}" includes="ast_link"/>
    </copy>

    <chmod perm="ugo+rx">
      <fileset dir="${build.jni}" includes="mk ${link.script} ast_link"/>
    </chmod>

    <javah classpath="${build.classes}" destdir="${build.jni}" verbose="yes">
      <class name="${package.name}.AstException"/>
      <class name="${package.name}.AstObject"/>
      <class name="${package.name}.Box"/>
      <class name="${package.name}.Channel"/>
      <class name="${package.name}.Circle"/>
      <class name="${package.name}.CmpFrame"/>
      <class name="${package.name}.CmpMap"/>
      <class name="${package.name}.CmpRegion"/>
      <class name="${package.name}.DSBSpecFrame"/>
      <class name="${package.name}.Ellipse"/>
      <class name="${package.name}.FitsChan"/>
      <class name="${package.name}.FluxFrame"/>
      <class name="${package.name}.Frame"/>
      <class name="${package.name}.FrameSet"/>
      <class name="${package.name}.GrismMap"/>
      <class name="${package.name}.Interval"/>
      <class name="${package.name}.IntraMap"/>
      <class name="${package.name}.KeyMap"/>
      <class name="${package.name}.LutMap"/>
      <class name="${package.name}.Mapping"/>
      <class name="${package.name}.MathMap"/>
      <class name="${package.name}.MatrixMap"/>
      <class name="${package.name}.NullRegion"/>
      <class name="${package.name}.PcdMap"/>
      <class name="${package.name}.PermMap"/>
      <class name="${package.name}.Plot"/>
      <class name="${package.name}.Polygon"/>
      <class name="${package.name}.PolyMap"/>
      <class name="${package.name}.PointList"/>
      <class name="${package.name}.Prism"/>
      <class name="${package.name}.RateMap"/>
      <class name="${package.name}.Region"/>
      <class name="${package.name}.SelectorMap"/>
      <class name="${package.name}.ShiftMap"/>
      <class name="${package.name}.SkyFrame"/>
      <class name="${package.name}.SlaMap"/>
      <class name="${package.name}.SpecFluxFrame"/>
      <class name="${package.name}.SpecFrame"/>
      <class name="${package.name}.SpecMap"/>
      <class name="${package.name}.SphMap"/>
      <class name="${package.name}.Stc"/>
      <class name="${package.name}.StcCatalogEntryLocation"/>
      <class name="${package.name}.StcObsDataLocation"/>
      <class name="${package.name}.StcResourceProfile"/>
      <class name="${package.name}.StcSearchLocation"/>
      <class name="${package.name}.SwitchMap"/>
      <class name="${package.name}.TimeFrame"/>
      <class name="${package.name}.TimeMap"/>
      <class name="${package.name}.TranMap"/>
      <class name="${package.name}.UnitMap"/>
      <class name="${package.name}.WcsMap"/>
      <class name="${package.name}.WinMap"/>
      <class name="${package.name}.ZoomMap"/>
      <class name="${package.name}.grf.GrfEscape"/>
    </javah>
  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of components are also required these should be created
   !  here too. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs).
   !  Builds a jar of the java source too.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar" basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Architecture dependent jar files (shareable libraries for
     !   webstart) -->
    <copy todir="${dist.lib}">
       <fileset dir="${src.jars.dir}" includes="**/*.jar **/*.zip"/>
    </copy>

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
    </signjar>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>JNIAST - Java Native Interface to AST</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink JNIAST - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="${name}/${name}.jar"/>
         <extension name="UTIL" href="util.jnlp"/>
       </resources>

       <!-- Linux -->
       <resources os="Linux" arch="i386">
         <nativelib href="i386/${name}_libs.jar"/>
       </resources>
       <resources os="Linux" arch="amd64">
         <nativelib href="amd64/${name}_libs.jar"/>
       </resources>

       <!-- IBM Linux -->
       <resources os="Linux" arch="x86">
         <nativelib href="i386/${name}_libs.jar"/>
       </resources>

       <!-- Windows -->
       <resources os="Windows">
          <nativelib href="x86/${name}_libs.jar"/>
       </resources>

       <!-- SUN Solaris -->
       <resources os="SunOS" arch="sparc">
         <nativelib href="sparc/${name}_libs.jar"/>
       </resources>

       <!-- Mac OS X -->
       <resources os="Mac OS X" arch="ppc">
         <nativelib href="ppc/${name}_libs.jar"/>
       </resources>
       <resources os="Mac OS X" arch="i386">
         <nativelib href="i386/${name}_libs.jar"/>
       </resources>
       <resources os="Mac OS X" arch="x86_64">
         <nativelib href="x86_64/${name}_libs.jar"/>
       </resources>
       <resources os="Mac OS X" arch="ppc64">
         <nativelib href="ppc64/${name}_libs.jar"/>
       </resources>

       <component_desc/>
    </jnlp>
  </target>

  <!--
   !   =============================
   !   Create the local distribution
   !   =============================
   !
   !  Creates a local distribution in the directory "dist.dir"
   !  (usually the current directory). Installations are based on this
   !  distribution. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have source).
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> creates the local binary distribution">

    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.lib.arch}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Set permissions on contents of distribution directory -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}-${os.name}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall> 

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin-${os.name}.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

    <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !
   ! For binary archives which contain platform-dependent code (e.g.
   ! shareable libraries) the operating system name is appended to
   | the archive name.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <condition property="os.spec" value="-${os.name}">
      <isset property="binary.required"/>
    </condition>
    <condition property="os.spec" value="">
      <not>
        <isset property="binary.required"/>
      </not>
    </condition>

    <zip destfile="${star.archive.dir}/${archive.name}${os.spec}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <property name="tarfile.name" value="${archive.name}${os.spec}.tar"/>
    <tar longfile="gnu" destfile="${tarfile.name}">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
      </tarfileset>
    </tar>

    <gzip zipfile="${star.archive.dir}/${tarfile.name}.gz" 
          src="${tarfile.name}"/>
    <bzip2 zipfile="${star.archive.dir}/${tarfile.name}.bz2"
           src="${tarfile.name}"/>
    <delete file="${tarfile.name}"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>
    <mkdir dir="${star.lib.arch}"/>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
        <include name="**/*.so"/>
        <include name="**/*.dll"/>
        <include name="**/*.jnilib"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory. 
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   =========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

    <!-- Make sure that the expected file structure exists, some
         of these files can be missing if originally empty -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.lib.arch}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Do normal install, but with many targets switched off-->
    <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   ! that were copied into place by the install target.
   !-->
 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall" 
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}" failonerror="false"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  The documentation is created from the Java sources. Should also
   !  extend this to include the possibility of other miscellaneous
   !  documentation (FAQs etc.).
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             source="${source.version}"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             classpathref="classpath">

      <!-- Exclude broken and test files etc. from the document -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">
    <mkdir dir="${build.java}"/>
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes"/>
    </copy>
  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="testframework.present">
    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >
      <classpath refid="tests-classpath"/>
      <compilerarg value="-proc:none" compiler="javac1.6"/>
    </javac>
  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests">

    <fail unless="testframework.present"
          message="Test framework is not present"/>

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">
      <classpath refid="tests-classpath"/>

      <sysproperty key="java.library.path" value="${dist.lib.arch}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="plain" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test*"/>
          <exclude name="uk/ac/starlink/TestCase.java"/>
        </fileset>
      </batchtest>

    </junit>
  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <fail unless="testframework.present"
          message="Test framework is not present"/>

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">
      <sysproperty key="java.library.path" value="${dist.lib.arch}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>
    </junit>
  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   JNIHDS build file
 !
 !   This file describes how to build the JNIHDS package from a source
 !   release. It requires Apache ANT and a Java Development Kit.
 !
 !      build            -> compiles the source code
 !      build-native     -> builds native libraries from C sources
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> install a runonly distribution into Starlink tree
 !      jars             -> creates the package jar file
 !      javadocs         -> creates the API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit tests
 !
 !   Authors:
 !      Peter W. Draper (2-JUL-2002)
 !      Mark Taylor (6-AUG-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for JNIHDS" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!-- The environment CLASSPATH is ignored by Ant tasks. -->
  <property name="build.sysclasspath" value="ignore"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="JNIHDS"/>
  <property name="name" value="jnihds"/>
  <property name="version" value="0.5"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.hds"/>
  <property name="package.path" value="uk/ac/starlink/hds"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="true"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.sdf"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.jni" location="${build.dir}/jni"/>
  <property name="build.lib" location="${build.dir}/lib"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants -->
  <property name="dist.dir" value="${basedir}"/>

  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.dir}/bin/${name}"/>
  <property name="dist.lib.pkg" value="${dist.dir}/lib/${name}"/>
  <property name="dist.docs.pkg" value="${dist.dir}/docs/${name}"/>
  <property name="dist.etc.pkg" value="${dist.dir}/etc/${name}"/>
  <property name="dist.javadocs" value="${dist.dir}/docs/${name}/javadocs"/>

  <!-- Architecture-specific files (shared libraries) -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>
  <property name="src.lib.arch" value="${src.jars.dir}/${os.arch}"/>
  <property name="build.lib.arch" value="${build.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!-- Non-standard source file directories -->
  <property name="src.ast" value="${src.dir}/ast"/>
  <property name="src.jni" value="${src.dir}/jni"/>
  <property name="jdk" value="${java.home}/.."/>
  <property name="stardev" value="/stardev"/>

  <!-- Non-standard files -->
  <property name="shared.object" value="lib${name}.so"/>
  <property name="link.script" value="${name}_libraries"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- Util -->
    <pathelement location="${star.jar.dir}/util/util.jar"/>

  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">
    <pathelement location="${star.build.dir}/util/lib/util/util.jar"/>
  </extclasspath>

  <path id="built.classpath">

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property
   !   "extra.class.path" (which can be defined locally using say
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
    <path refid="local.classpath"/>
    <path refid="built.classpath"/>
    <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath -->
  <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!-- Need Util -->
    <available property="util.present"
               classpathref="classpath"
               classname="uk.ac.starlink.util.Loader"/>
    <fail message="No Util available" unless="util.present"/>

    <!-- Need JUnit for testcases, not essential -->
    <condition property="testframework.present">
      <and>
        <available classpathref="tests-classpath"
                   classname="junit.framework.TestCase"/>
        <available classpathref="tests-classpath"
                   classname="uk.ac.starlink.util.TestCase"/>
      </and>
    </condition>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images) should also be copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages, build_classes, unpack_jni"
          unless="runonly.install"
          description="-> compiles the source code">

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}" includes="[none]"/>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <!--
     !  <mkdir dir="${dist.lib.pkg}"/>
     !  <copy todir="${dist.lib.pkg}">
     !  </copy>
     !-->

  </target>


  <!-- Pulls the architecture-specific shared libraries out of the source
   !   jar file in which they live.  These jar files are in the CVS 
   !   repository, they are not built as part of the normal build target. 
   !   The one specific to the build-time architecture can be built 
   !   using the "build-native" target, but this requires more than the
   !   basic CVS files to work (e.g. it needs the stardev classic libraries).
   !-->
  <target name="unpack_jni">
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="i386"/>
    </antcall>
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="sparc"/>
    </antcall>
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="x86"/>
    </antcall>
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="ppc"/>
    </antcall> 
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="amd64"/>
    </antcall>
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="x86_64"/>
    </antcall>

    <!-- In case the current architecture is not one of those named above,
     !   make sure that gets done too. -->
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="${os.arch}"/>
    </antcall>

  </target>

  <!-- Architecture-specific JNI jar file unpacker -->
  <target name="unpack_jni_arch">
    <unjar src="${src.jars.dir}/${unpack.arch}/${name}_libs.jar"
           dest="${dist.lib}/${unpack.arch}">
      <patternset excludes="META-INF*/*"/>
    </unjar>
  </target>


  <!-- Build the java class files. -->
  <target name="build_classes">
    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           optimize="${optimize}">

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

      <!-- Exclude any Java files in the source tree that should not be
       !   compiled -->
      <exclude name="**/retired_code/*"/>
    </javac>
  </target>


  <!--
   !  ============================================
   !  Build the native shared library from sources
   !  ============================================
   !
   !  This does the actual build of the shared library, and requires
   !  a stardev installation.  It is not a dependency of any of the 
   !  other public targets, and should not be invoked as part of the
   !  normal build process.  It should be invoked periodically 
   !  (when JNIHDS or HDS changes), once on each of the supported
   !  platforms, and the resulting new 'source' files (shared library
   !  jar files) checked in.
   !-->
  <target name="build-native" 
          depends="assemble_jni"
          description="-> builds native libaries from C sources">

    <!-- Extract the existing libraries from the jar file. There may
     !   be more than one library per architecture (i386 Linux and OS X)
     !   and we want to keep the other libraries. The datestamps should 
     !   be in the past otherwise this will fail
     !-->
    <unjar dest="${build.lib.arch}">
      <fileset file="${src.lib.arch}/${name}_libs.jar"/>
    </unjar>

    <!-- Build the library -->
    <antcall target="execute_mk_script">
      <param name="mk.action" value="shared"/>
    </antcall>

    <!-- Jar it up and copy it into the source tree ready for CVS checkin -->
    <mkdir dir="${src.lib.arch}"/>
    <jar destfile="${src.lib.arch}/${name}_libs.jar"
         basedir="${build.lib.arch}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
      </manifest>
    </jar>
  </target>


  <!--
   !  ===================================
   !  Execute shareable library MK script
   !  ===================================
   !  Execute the "mk" script that creates the package shareable
   !  library. The action performed is controlled by the "mk.action"
   !  property that should be defined before an antcall to this
   !  target.
   !-->
  <target name="execute_mk_script">

    <!-- Execute the given action for all known operating system types.
     !   This uses modified mk and makefiles from an old-style system
     !   which should be stored in ${src.jni} along with the source
     !   code. Note some of these OS names seem to change from time to
     !   time and across JVMs, so beware. Clearly this is not portable.
     !-->

    <!-- Local and installed versions of any shareable libraries that we
     !   require to resolve against in a form for the UNIX "ld" command
     !-->
    <property name="java.shareables" value=""/>

    <mkdir dir="${build.lib.arch}"/>

    <echo message="java.home=${java.home}"/>

    <exec dir="${build.jni}" executable="${build.jni}/mk" os="Linux"
          failonerror="yes">
      <env key="SYSTEM" value="ix86_Linux"/>
      <env key="JAVA_SYSTEM" value="linux"/>
      <env key="STARLINK" value="${stardev}"/>
      <env key="JDK" value="${jdk}"/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${build.lib.arch}"/>
      <arg line="${mk.action}"/>
    </exec>

    <exec dir="${build.jni}" executable="${build.jni}/mk" os="SunOS"
          failonerror="yes">
      <env key="SYSTEM" value="sun4_Solaris"/>
      <env key="JAVA_SYSTEM" value="solaris"/>
      <env key="STARLINK" value="${stardev}"/>
      <env key="JDK" value="${jdk}"/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${build.lib.arch}"/>
      <arg line="${mk.action}"/>
    </exec>

     <exec dir="${build.jni}" executable="${build.jni}/mk" os="Mac OS X"
           failonerror="yes">
       <env key="SYSTEM" value="MacOSX"/>
       <env key="JAVA_SYSTEM" value="${os.arch}"/>
       <env key="STARLINK" value="${stardev}"/>
       <env key="ADDLIBS" value="-L${stardev.add}/lib"/>
       <env key="ADDINCS" value="-I${stardev.add}/include"/>
       <env key="JDK" value="${jdk}"/>
       <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
       <env key="TARGET_LIB" value="${build.lib.arch}"/>
       <env key="STARJAVA_LIB" value="${star.install}/lib/${os.arch}"/>
       <arg line="${mk.action}"/>
     </exec>

    <exec dir="${build.jni}" executable="${build.jni}/mk" os="OSF1"
          failonerror="yes">
      <env key="SYSTEM" value="alpha_OSF1"/>
      <env key="JAVA_SYSTEM" value="alpha"/>
      <env key="STARLINK" value="${stardev}"/>
      <env key="JDK" value="${jdk}"/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${build.lib.arch}"/>
      <arg line="${mk.action}"/>
    </exec>

  </target>

  <!--
   !   Put all the source files required for compilation of the shared
   !   library in the build directory.  Some of these are copied directly
   !   from source directories, some are generated using javah from
   !   class files.
   !-->
  <target name="assemble_jni" depends="build_classes" unless="jni.assembled">

    <copy todir="${build.jni}">
      <fileset dir="${src.jni}" includes="*.c *.h makefile mk ${link.script}"/>
    </copy>
    <chmod perm="ugo+rx">
      <fileset dir="${build.jni}" includes="mk ${link.script}"/>
    </chmod>

    <javah classpath="${build.classes}" destdir="${build.jni}" verbose="yes">
      <class name="${package.name}.HDSObject"/>
    </javah>
  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of components are also required these should be created
   !  here too. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs).
   !  Builds a jar of the java source too.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar" basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Architecture dependent jar files (shareable libraries for
     !   webstart) -->
    <copy todir="${dist.lib}">
       <fileset dir="${src.jars.dir}" includes="**/*.jar **/*.zip"/>
    </copy>

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
    </signjar>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>JNIHDS - Java Native Interface to HDS</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink JNIHDS - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="${name}/${name}.jar"/>
         <extension name="UTIL" href="util.jnlp"/>
       </resources>

       <!-- Linux -->
       <resources os="Linux" arch="i386">
         <nativelib href="i386/${name}_libs.jar"/>
       </resources>
       <resources os="Linux" arch="amd64">
         <nativelib href="amd64/${name}_libs.jar"/>
       </resources>


       <!-- IBM Linux -->
       <resources os="Linux" arch="x86">
         <nativelib href="i386/${name}_libs.jar"/>
       </resources>

       <!-- Windows -->
       <resources os="Windows">
          <nativelib href="x86/${name}_libs.jar"/>
       </resources>

       <!-- SUN Solaris -->
       <resources os="SunOS" arch="sparc">
         <nativelib href="sparc/${name}_libs.jar"/>
       </resources>

       <!-- Mac OS X -->
       <resources os="Mac OS X" arch="ppc">
          <nativelib href="ppc/${name}_libs.jar"/>
       </resources> 
       <resources os="Mac OS X" arch="i386">
          <nativelib href="i386/${name}_libs.jar"/>
       </resources> 
       <resources os="Mac OS X" arch="x86_64">
         <nativelib href="x86_64/${name}_libs.jar"/>
       </resources>
       <resources os="Mac OS X" arch="ppc64">
         <nativelib href="ppc64/${name}_libs.jar"/>
       </resources>

       <component_desc/>
    </jnlp>
  </target>


  <!--
   !   =============================
   !   Create the local distribution
   !   =============================
   !
   !  Creates a local distribution in the directory "dist.dir"
   !  (usually the current directory). Installations are based on this
   !  distribution. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have source).
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> creates the local binary distribution">

    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.lib.arch}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Set permissions on contents of distribution directory -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}-${os.name}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin-${os.name}.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

    <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !
   ! For binary archives which contain platform-dependent code (e.g.
   ! shareable libraries) the operating system name is appended to
   | the archive name.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <condition property="os.spec" value="-${os.name}">
      <isset property="binary.required"/>
    </condition>
    <condition property="os.spec" value="">
      <not>
        <isset property="binary.required"/>
      </not>
    </condition>

    <zip destfile="${star.archive.dir}/${archive.name}${os.spec}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <property name="tarfile.name" value="${archive.name}${os.spec}.tar"/>
    <tar longfile="gnu" destfile="${tarfile.name}">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
      </tarfileset>
    </tar>

    <gzip zipfile="${star.archive.dir}/${tarfile.name}.gz"
          src="${tarfile.name}"/>
    <bzip2 zipfile="${star.archive.dir}/${tarfile.name}.bz2"
           src="${tarfile.name}"/>
    <delete file="${tarfile.name}"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>
    <mkdir dir="${star.lib.arch}"/>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
        <include name="**/*.so"/>
        <include name="**/*.dll"/>
        <include name="**/*.jnilib"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   =========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

    <!-- Make sure that the expected file structure exists, some
         of these files can be missing if originally empty -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.lib.arch}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Do normal install, but with many targets switched off-->
    <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   ! that were copied into place by the install target.
   !-->
 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}" failonerror="false"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  The documentation is created from the Java sources. Should also
   !  extend this to include the possibility of other miscellaneous
   !  documentation (FAQs etc.).
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->

    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes"/>
    </copy>

  </target>


  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="testframework.present">
    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           deprecation="${deprecation}" >
      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="tests-classpath"/>
    </javac>

    <copy todir="${build.tests}">
      <fileset dir="${tests.dir}" excludes="**/*.java"/>
    </copy>
  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests">

    <fail unless="testframework.present"
          message="Test framework is not present"/>

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">
      <classpath refid="tests-classpath"/>

      <sysproperty key="java.library.path" value="${dist.lib.arch}"/>
      <sysproperty key="java.io.tmpdir" value="${build.tests}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="plain" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test*"/>
          <exclude name="uk/ac/starlink/TestCase.java"/>
        </fileset>
      </batchtest>

    </junit>
  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <fail unless="testframework.present"
          message="Test framework is not present"/>

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">
      <sysproperty key="java.library.path" value="${dist.lib.arch}"/>
      <sysproperty key="java.io.tmpdir" value="${build.tests}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>
    </junit>
  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   KAPPA build file
 !
 !   This file describes how to build the KAPPA package from a source
 !   release. It requires Apache ANT and a Java Development Kit.
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> install a runonly distribution into Starlink tree
 !      jars             -> creates the package jar file
 !      javadocs         -> creates the API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit tests
 !
 !   Authors:
 !      Peter W. Draper (2-JUL-2002)
 !      Mark Taylor (6-AUG-2002)
 !      Alan Chipperfield (19-SEP-2003)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for KAPPA" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/starjava)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/starjava)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!-- The environment CLASSPATH is ignored by Ant tasks. -->
  <property name="build.sysclasspath" value="ignore"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="KAPPA"/>
  <property name="name" value="kappa"/>
  <property name="version" value="0.1"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.kappa"/>
  <property name="package.path" value="uk/ac/starlink/kappa"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="true"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.sdf"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.jni" location="${build.dir}/jni"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants -->
  <property name="dist.dir" value="${basedir}"/>

  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.dir}/bin/${name}"/>
  <property name="dist.lib.pkg" value="${dist.dir}/lib/${name}"/>
  <property name="dist.docs.pkg" value="${dist.dir}/docs/${name}"/>
  <property name="dist.etc.pkg" value="${dist.dir}/etc/${name}"/>
  <property name="dist.javadocs" value="${dist.dir}/docs/${name}/javadocs"/>

  <!-- Architecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!-- Non-standard source file directories -->
  <property name="src.jni" value="${src.dir}/jni"/>
  <property name="jdk" value="${java.home}/.."/>
  <property name="stardev" value="/stardev"/>

  <!-- We need access to libraries etc which are not part of the public
   !   interface of the package.
   !   For some reason for KAPPA they are present in /star/sources/kappa -->
  <property name="classic.build.dir" value="/stardev/sources"/>
  <property name="classic.build.dir.${name}"
            value="${classic.build.dir}/${name}"/>

  <!-- Non-standard build file directories -->
  <property name="build.jni" value="${build.dir}/jni"/>

  <!-- Non-standard files -->
  <property name="shared.object" value="lib${Name}.so"/>
  <property name="link.script" value="${Name}_libraries"/>



  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- JPCS -->
    <pathelement location="${star.jar.dir}/jpcs/jpcs.jar"/>
    <!-- STARTASK -->
    <pathelement location="${star.jar.dir}/startask/startask.jar"/>

  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">
    <pathelement location="${star.build.dir}/jpcs/lib/jpcs/jpcs.jar"/>
    <pathelement location="${star.build.dir}/startask/lib/startask/startask.jar"/>
  </extclasspath>

  <path id="built.classpath">

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property 
   !   "extra.class.path" (which can be defined locally using say 
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
    <path refid="local.classpath"/>
    <path refid="built.classpath"/>
    <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath -->
  <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!-- Need JPCS -->
    <available property="jpcs.present"
               classpathref="classpath"
               classname="uk.ac.starlink.jpcs.Dtask"/>
    <fail message="No JPCS available" unless="jpcs.present"/>

    <!-- Need STARTASK -->
    <available property="startask.present"
               classpathref="classpath"
               classname="uk.ac.starlink.startask.ShellRunner"/>
    <fail message="No STARTASK available" unless="startask.present"/>

    <!-- Need JUnit for testcases, not essential -->
    <condition property="testframework.present">
      <and>
        <available classpathref="tests-classpath"
                   classname="junit.framework.TestCase"/>
        <available classpathref="tests-classpath"
                   classname="uk.ac.starlink.util.TestCase"/>
      </and>
    </condition>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images) should also be copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages, build_classes, build_jni"
          unless="runonly.install"
          description="-> compiles the source code">

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}" includes="${package.path}/support/*"/>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <!--
     !  <mkdir dir="${dist.lib.pkg}"/>
     !  <copy todir="${dist.lib.pkg}">
     !  </copy>
     !-->

  </target>


  <!-- Build the java class files. -->
  <target name="build_classes">
    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           optimize="${optimize}">

      <classpath refid="classpath"/>

      <!-- Exclude any Java files in the source tree that should not be
       !   compiled -->
      <exclude name="**/retired_code/*"/>
    </javac>
  </target>

  <!-- Build any shareable libraries needed to support this package.
   !   This goes straight into the distribution directory to save on
   !   space, and to make it immediately available to locally build
   !   packages  -->
  <target name="build_jni" depends="assemble_jni">
    <antcall target="execute_mk_script">
      <param name="mk.action" value="shared"/>
    </antcall>
  </target>


  <!--
   !  ===================================
   !  Execute shareable library MK script
   !  ===================================
   !  Execute the "mk" script that creates the package shareable
   !  library. The action performed is controlled by the "mk.action"
   !  property that should be defined before an antcall to this
   !  target.
   !-->
  <target name="execute_mk_script">

    <!-- Execute the given action for all known operating system types.
     !   This uses modified mk and makefiles from an old-style system
     !   which should be stored in ${src.jni} along with the source
     !   code. Note some of these OS names seem to change from time to
     !   time and across JVMs, so beware. Clearly this is not portable.
     !-->

    <!-- Local and installed versions of any shareable libraries that we
     !   require to resolve against in a form for the UNIX "ld" command
     !-->
    <property name="java.shareables" value=""/>

    <mkdir dir="${dist.lib.arch}"/>

    <echo message="java.home=${java.home}"/>

    <exec dir="${build.jni}" executable="${build.jni}/mk" os="Linux"
          failonerror="yes">
      <env key="SYSTEM" value="ix86_Linux"/>
      <env key="JAVA_SYSTEM" value="linux"/>
      <env key="STARLINK" value="${stardev}"/>
      <env key="JDK" value="${jdk}"/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${dist.lib.arch}"/>
      <env key="ADDLIBS"
       value=
       "-L${classic.build.dir.kappa} -L${dist.lib.arch}
        -L${star.install}/lib/${os.arch}
        -L${star.dir}/lib/${os.arch}"/>
      <arg line="${mk.action}"/>
    </exec>

    <exec dir="${build.jni}" executable="${build.jni}/mk" os="SunOS"
          failonerror="yes">
      <env key="SYSTEM" value="sun4_Solaris"/>
      <env key="JAVA_SYSTEM" value="solaris"/>
      <env key="STARLINK" value="${stardev}"/>
      <env key="JDK" value="${jdk}"/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${dist.lib.arch}"/>
      <env key="ADDLIBS"
       value=
       "-L${classic.build.dir.kappa} -L${dist.lib.arch}
        -L${star.install}/lib/${os.arch}
        -L${star.dir}/lib/${os.arch}"/>
      <arg line="${mk.action}"/>
    </exec>

    <exec dir="${build.jni}" executable="${build.jni}/mk" os="OSF1"
          failonerror="yes">
      <env key="SYSTEM" value="alpha_OSF1"/>
      <env key="JAVA_SYSTEM" value="alpha"/>
      <env key="STARLINK" value="${stardev}"/>
      <env key="JDK" value="${jdk}"/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${dist.lib.arch}"/>
      <env key="ADDLIBS"
       value=
       "-L${classic.build.dir.kappa} -L${dist.lib.arch}
        -L${star.install}/lib/${os.arch}
        -L${star.dir}/lib/${os.arch}"/>
      <arg line="${mk.action}"/>
    </exec>

  </target>

  <!--
   !   Put all the source files required for compilation of the shared
   !   library in the build directory.  Some of these are copied directly
   !   from source directories, some are generated using javah from 
   !   class files.
   !-->
  <target name="assemble_jni" depends="build_classes" unless="jni.assembled">

    <copy todir="${build.jni}">
      <fileset dir="${src.jni}"
               includes="*.f *.c *.h makefile mk ${link.script}"/>
    </copy>

    <chmod perm="ugo+rx">
      <fileset dir="${build.jni}" includes="mk ${link.script}"/>
    </chmod>

    <javah
     classpath="${build.classes}:${star.jar.dir}/jpcs/jpcs.jar"
     destdir="${build.jni}" verbose="yes">
      <class name="${package.name}.${Name}"/>
    </javah>
  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of components are also required these should be created
   !  here too. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs).
   !  Builds a jar of the java source too.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar" basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Main-Class" value="${package.name}.${Name}"/>
        <attribute name="Class-Path" 
                   value="${jar.class.path}"/>
      </manifest>
    </jar>

    <zip destfile="${dist.lib.pkg}/${name}_src.zip" basedir="${java.dir}"/>

  </target>

  <!--
   !   =============================
   !   Create the local distribution
   !   =============================
   !
   !  Creates a local distribution in the directory "dist.dir"
   !  (usually the current directory). Installations are based on this
   !  distribution. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have source).
   !-->
  <target name="dist"
          depends="build,jars,javadocs"
          unless="runonly.install"
          description="-> creates the local binary distribution">

    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.lib.arch}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Set permissions on contents of distribution directory -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           excludes="build/**" failonerror="${chmod.fail}"/>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}-${os.name}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall> 

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin-${os.name}.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

    <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !
   ! For binary archives which contain platform-dependent code (e.g.
   ! shareable libraries) the operating system name is appended to
   | the archive name.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <condition property="os.spec" value="-${os.name}">
      <isset property="binary.required"/>
    </condition>
    <condition property="os.spec" value="">
      <not>
        <isset property="binary.required"/>
      </not>
    </condition>

    <zip destfile="${star.archive.dir}/${archive.name}${os.spec}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <property name="tarfile.name" value="${archive.name}${os.spec}.tar"/>
    <tar longfile="gnu" destfile="${tarfile.name}">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
      </tarfileset>
    </tar>

    <gzip zipfile="${star.archive.dir}/${tarfile.name}.gz" 
          src="${tarfile.name}"/>
    <bzip2 zipfile="${star.archive.dir}/${tarfile.name}.bz2"
           src="${tarfile.name}"/>
    <delete file="${tarfile.name}"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>
    <mkdir dir="${star.lib.arch}"/>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
        <include name="**/*.so"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory. 
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   =========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

    <!-- Make sure that the expected file structure exists, some
         of these files can be missing if originally empty -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.lib.arch}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Do normal install, but with many targets switched off-->
    <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   ! that were copied into place by the install target.
   !-->
 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall" 
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}" failonerror="false"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  The documentation is created from the Java sources. Should also
   !  extend this to include the possibility of other miscellaneous
   !  documentation (FAQs etc.).
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->

    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes"/>
    </copy>

  </target>


  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="testframework.present">
    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           deprecation="${deprecation}" >
      <classpath refid="tests-classpath"/>
    </javac>
  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests">

    <fail unless="testframework.present"
          message="Test framework is not present"/>

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">
      <classpath refid="tests-classpath"/>

      <sysproperty key="java.library.path" value="${dist.lib.arch}"/>
      <sysproperty key="java.io.tmpdir" value="${build.tests}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>

      <formatter type="plain" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test*"/>
          <exclude name="uk/ac/starlink/TestCase.java"/>
        </fileset>
      </batchtest>

    </junit>
  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <fail unless="testframework.present"
          message="Test framework is not present"/>

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">
      <sysproperty key="java.library.path" value="${dist.lib.arch}"/>
      <sysproperty key="java.io.tmpdir" value="${build.tests}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <classpath refid="tests-classpath"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>
    </junit>
  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   JPCS build file
 !
 !   This file describes how to build the JPCS package from a source
 !   release. It requires Apache ANT and a Java Development Kit.
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> install a runonly distribution into Starlink tree
 !      jars             -> creates the package jar file
 !      javadocs         -> creates the API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit tests
 !
 !   Authors:
 !      Peter W. Draper (2-JUL-2002)
 !      Mark Taylor (6-AUG-2002)
 !      Alan Chipperfield (19-SEP-2003)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for JPCS" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/starjava)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/starjava)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!-- The environment CLASSPATH is ignored by Ant tasks. -->
  <property name="build.sysclasspath" value="ignore"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="JPCS"/>
  <property name="name" value="jpcs"/>
  <property name="version" value="0.1"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.jpcs"/>
  <property name="package.path" value="uk/ac/starlink/jpcs"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="true"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.sdf"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.jni" location="${build.dir}/jni"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants -->
  <property name="dist.dir" value="${basedir}"/>

  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.dir}/bin/${name}"/>
  <property name="dist.lib.pkg" value="${dist.dir}/lib/${name}"/>
  <property name="dist.docs.pkg" value="${dist.dir}/docs/${name}"/>
  <property name="dist.etc.pkg" value="${dist.dir}/etc/${name}"/>
  <property name="dist.javadocs" value="${dist.dir}/docs/${name}/javadocs"/>

  <!-- Architecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!-- Non-standard source file directories -->
  <property name="src.jni" value="${src.dir}/jni"/>
  <property name="jdk" value="${java.home}/.."/>
  <property name="stardev" value="/stardev"/>

  <!-- Non-standard build file directories -->
  <property name="build.jni" value="${build.dir}/jni"/>

  <!-- Non-standard files -->
  <property name="shared.object" value="libsubpar.so"/>
  <!-- <property name="link.script" value="${Name}_libraries"/>  -->



  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- Xerces -->
    <pathelement location="${star.jar.dir}/xercesImpl.jar"/>

  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">
    <pathelement location="${star.build.dir}/jpcs/lib/jpcs/jpcs.jar"/>
  </extclasspath>

  <path id="built.classpath">

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property 
   !   "extra.class.path" (which can be defined locally using say 
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
    <path refid="local.classpath"/>
    <path refid="built.classpath"/>
    <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath -->
  <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!-- Need SAX -->
  <!--  <available property="sax.present"
               classpathref="classpath"
               classname="org.apache.xerces/parsers/SAXParser"/>
    <fail message="No SAX available" unless="sax.present"/> -->

    <!-- Need JUnit for testcases, not essential -->
    <condition property="testframework.present">
      <and>
        <available classpathref="tests-classpath"
                   classname="junit.framework.TestCase"/>
        <available classpathref="tests-classpath"
                   classname="uk.ac.starlink.util.TestCase"/>
      </and>
    </condition>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images) should also be copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages, build_classes, build_jni"
          unless="runonly.install"
          description="-> compiles the source code">

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}" includes="${package.path}/support/*"/>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <!--
     !  <mkdir dir="${dist.lib.pkg}"/>
     !  <copy todir="${dist.lib.pkg}">
     !  </copy>
     !-->

  </target>


  <!-- Build the java class files. -->
  <target name="build_classes">
    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           optimize="${optimize}">

      <classpath refid="classpath"/>

      <!-- Exclude any Java files in the source tree that should not be
       !   compiled -->
      <exclude name="**/retired_code/*"/>
    </javac>
  </target>

  <!-- Build any shareable libraries needed to support this package.
   !   This goes straight into the distribution directory to save on
   !   space, and to make it immediately available to locally build
   !   packages  -->
  <target name="build_jni" depends="assemble_jni">
    <antcall target="execute_mk_script">
      <param name="mk.action" value="shared"/>
    </antcall>
  </target>


  <!--
   !  ===================================
   !  Execute shareable library MK script
   !  ===================================
   !  Execute the "mk" script that creates the package shareable
   !  library. The action performed is controlled by the "mk.action"
   !  property that should be defined before an antcall to this
   !  target.
   !-->
  <target name="execute_mk_script">

    <!-- Execute the given action for all known operating system types.
     !   This uses modified mk and makefiles from an old-style system
     !   which should be stored in ${src.jni} along with the source
     !   code. Note some of these OS names seem to change from time to
     !   time and across JVMs, so beware. Clearly this is not portable.
     !-->

    <!-- Local and installed versions of any shareable libraries that we
     !   require to resolve against in a form for the UNIX "ld" command
     !-->
    <property name="java.shareables" value=""/>

    <mkdir dir="${dist.lib.arch}"/>

    <echo message="java.home=${java.home}"/>

    <exec dir="${build.jni}" executable="${build.jni}/mk" os="Linux"
          failonerror="yes">
      <env key="SYSTEM" value="ix86_Linux"/>
      <env key="JAVA_SYSTEM" value="linux"/>
      <env key="STARLINK" value="${stardev}"/>
      <env key="JDK" value="${jdk}"/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${dist.lib.arch}"/>
      <arg line="${mk.action}"/>
    </exec>

    <exec dir="${build.jni}" executable="${build.jni}/mk" os="SunOS"
          failonerror="yes">
      <env key="SYSTEM" value="sun4_Solaris"/>
      <env key="JAVA_SYSTEM" value="solaris"/>
      <env key="STARLINK" value="${stardev}"/>
      <env key="JDK" value="${jdk}"/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${dist.lib.arch}"/>
      <arg line="${mk.action}"/>
    </exec>

    <exec dir="${build.jni}" executable="${build.jni}/mk" os="OSF1"
          failonerror="yes">
      <env key="SYSTEM" value="alpha_OSF1"/>
      <env key="JAVA_SYSTEM" value="alpha"/>
      <env key="STARLINK" value="${stardev}"/>
      <env key="JDK" value="${jdk}"/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${dist.lib.arch}"/>
      <arg line="${mk.action}"/>
    </exec>

  </target>

  <!--
   !   Put all the source files required for compilation of the shared
   !   library in the build directory.  These are copied directly
   !   from source directories.
   !-->
  <target name="assemble_jni" depends="build_classes" unless="jni.assembled">

    <copy todir="${build.jni}">
    <!--  <fileset dir="${src.jni}"
               includes="*.f *.c *.h makefile mk ${link.script}"/> -->
      <fileset dir="${src.jni}"
               includes="*.f *.c *.h makefile mk"/> 
    </copy>

    <chmod perm="ugo+rx">
    <!--  <fileset dir="${build.jni}" includes="mk ${link.script}"/> -->
      <fileset dir="${build.jni}" includes="mk"/>
    </chmod>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of components are also required these should be created
   !  here too. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs).
   !  Builds a jar of the java source too.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar" basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/> 
      </manifest>
    </jar>

    <zip destfile="${dist.lib.pkg}/${name}_src.zip" basedir="${java.dir}"/>

  </target>

  <!--
   !   =============================
   !   Create the local distribution
   !   =============================
   !
   !  Creates a local distribution in the directory "dist.dir"
   !  (usually the current directory). Installations are based on this
   !  distribution. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have source).
   !-->
  <target name="dist"
          depends="build,jars,javadocs"
          unless="runonly.install"
          description="-> creates the local binary distribution">

    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.lib.arch}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Set permissions on contents of distribution directory -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           excludes="build/**" failonerror="${chmod.fail}"/>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}-${os.name}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall> 

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin-${os.name}.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

    <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !
   ! For binary archives which contain platform-dependent code (e.g.
   ! shareable libraries) the operating system name is appended to
   | the archive name.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <condition property="os.spec" value="-${os.name}">
      <isset property="binary.required"/>
    </condition>
    <condition property="os.spec" value="">
      <not>
        <isset property="binary.required"/>
      </not>
    </condition>

    <zip destfile="${star.archive.dir}/${archive.name}${os.spec}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <property name="tarfile.name" value="${archive.name}${os.spec}.tar"/>
    <tar longfile="gnu" destfile="${tarfile.name}">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
      </tarfileset>
    </tar>

    <gzip zipfile="${star.archive.dir}/${tarfile.name}.gz" 
          src="${tarfile.name}"/>
    <bzip2 zipfile="${star.archive.dir}/${tarfile.name}.bz2"
           src="${tarfile.name}"/>
    <delete file="${tarfile.name}"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>
    <mkdir dir="${star.lib.arch}"/>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
        <include name="**/*.so"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory. 
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   =========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

    <!-- Make sure that the expected file structure exists, some
         of these files can be missing if originally empty -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.lib.arch}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Do normal install, but with many targets switched off-->
    <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   ! that were copied into place by the install target.
   !-->
 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall" 
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}" failonerror="false"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  The documentation is created from the Java sources. Should also
   !  extend this to include the possibility of other miscellaneous
   !  documentation (FAQs etc.).
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             classpathref="classpath"
             additionalparam="-breakiterator">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->

    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes"/>
    </copy>

  </target>


  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="testframework.present">
    <mkdir dir="${build.tests}"/>

 <!-- There are currently no tests. -->
 <!--
    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           deprecation="${deprecation}" >
      <classpath refid="tests-classpath"/>
    </javac>
 -->
  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests">

 <!-- There are currently no tests -->
 <!--
    <fail unless="testframework.present"
          message="Test framework is not present"/>

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">
      <classpath refid="tests-classpath"/>

      <sysproperty key="java.library.path" value="${dist.lib.arch}"/>
      <sysproperty key="java.io.tmpdir" value="${build.tests}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="plain" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test*"/>
          <exclude name="uk/ac/starlink/TestCase.java"/>
        </fileset>
      </batchtest>

    </junit>
 -->
  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <fail unless="testframework.present"
          message="Test framework is not present"/>

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">
      <sysproperty key="java.library.path" value="${dist.lib.arch}"/>
      <sysproperty key="java.io.tmpdir" value="${build.tests}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>
    </junit>
  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !  JSAMP build file
 !
 !   This file describes how to build and install the JSAMP
 !   package from its binary release. JSAMP is a pre-built third
 !   party package that is permanently in the "dist" configuration.
 !
 !   The main targets are:
 !
 !      build            -> makes copies of local files that will be modified
 !      clean            -> removes local copies
 !      deinstall        -> undo the install target
 !      dist             -> makes package into dist state

 !      export           -> creates the full distribution archives
 !      export-runonly   -> same as export
 !      export-source    -> same as export
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> same as install
 !      jars             -> add manifest and signs jar files
 !      javadocs         -> does nothing
 !      javadoc-sources  -> does nothing
 !      test             -> may run a test for checking package function
 !
 !   The targets that do nothing are provided for compatibility with
 !   the normal build system.
 !
 !   Authors:
 !      Peter W. Draper (16-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for JSAMP" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good idea as names
   !   are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="JSAMP"/>
  <property name="name" value="jsamp"/>
  <property name="version" value="1.3-4"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing any unmodified jars of this package -->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Distribution directories, these are the actual state of this
   !   package at all times -->
  <property name="dist.dir" value="${basedir}"/>

  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase"
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page"
            value="http://deployer.astrogrid.org/software/jsamp/index.html"/>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

  </target>

  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !-->
  <target name="build"
          depends="prepare"
          description="-> make local copies of files for modification">

    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>

  </target>

  <!--
   !   ===========================
   !   Create the package jar file
   !   ===========================
   !

   !  Update the manifest of the package main jar file, if
   !  needed. This is typically the jar file with the main package
   !  classes. If this package has more than one such jar file, then
   !  update them all.
   !
   !  Packages whose jar files are not already signed (by the
   !  originator) should be signed here.
   !-->
  <target name="jars" depends="build">

    <!-- Add the manifest to the jar file, just an update -->
 <!--
    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar" basedir="${dist.dir}"
         update="true" excludes="**">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>
  -->

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
    </signjar>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package.
     !   This goes into "dist.lib".
     !-->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">

      <information>
         <title>JSAMP - SAMP toolkit</title>
         <vendor>AstroGrid</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>JSAMP - Webstart edition</description>
         <offline_allowed/>
      </information>

      <security>
        <all_permissions/>
      </security>

      <resources>
        <j2se version="1.5+"/>
        <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
      </resources>

      <component_desc/>

     </jnlp>

  </target>

  <!--
   !   =============================
   !   Create the local distribution
   !   =============================
   !-->
  <target name="dist"
          depends="jars,webstart"
          description="-> make package ready for distribution">
    <mkdir dir="${dist.bin}"/>
    <copy todir="${dist.bin}">
      <fileset dir="${script.dir}"/>
    </copy>
  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  package.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  Same as export, except for the name.
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

    <antcall target="create_archives">
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. Same as export, except for the
   !  name.
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

    <antcall target="create_archives">
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required.
   ! For this package these are all the same just set the property
   ! "archive.name" to define what name to use for the outfile
   ! files. The archives are also written into the directory
   ! ${star.archive.dir} (the local directory by default).
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>
    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib"/>

    </zip>

    <tar longfile="gnu" destfile="${archive.name}.tar">

      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.lib}" prefix="${name}/lib"/>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   ! Does nothing.
   !-->
  <target name="clean"
          description="-> removes local copies">

    <delete dir="${dist.lib}"/>
    <delete dir="${dist.bin}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the package into another set of directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.bin" value="${star.install}/bin"/>

    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>
    <mkdir dir="${star.bin}"/>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>
    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   =========================================
   !
   ! Same as install.
   !-->
  <target name="install-runonly"
          description="-> install distribution into Starlink tree">

     <antcall target="install"/>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   ! that were copied into place by the install target.
   !-->

 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Does nothing.
   !-->
  <target name="javadocs"
          description="-> does nothing">
  </target>

  <!--
   !   ==========================================
   !   Creates the API documentation java sources
   !   ==========================================
   !
   !  Does nothing.
   !-->
  <target name="javadoc-sources"
          description="-> does nothing">
  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          description="-> does nothing"/>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   JSky build file
 !
 !   This file describes how to build and install JSky from
 !   source and binary releases. JSky is primarily a class library
 !   (i.e. provides an API and related documentation) although
 !   it does have a user interface (jskycat).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (22-AUG-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->
<project name="Build file for JSky" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="JSKY"/>
  <property name="name" value="jsky"/>
  <property name="version" value="2.0"/>

  <!-- The Java package name -->
  <property name="package.name" value="jsky"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>
  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://archive.eso.org/jsky/"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that 
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may 
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed). 
   !-->
  <extclasspath id="installed.classpath">

    <!-- TAMFITS, use proper version rather than JSky release -->
    <pathelement location="${star.jar.dir}/tamfits/tamfits.jar"/>

    <!-- DIVA, use proper version rather than JSky release -->
    <pathelement location="${star.jar.dir}/diva/diva.jar"/>

  </extclasspath>
  
  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">
    <pathelement location="${star.build.dir}/tamfits/lib/tamfits/tamfits.jar"/>
    <pathelement location="${star.build.dir}/diva/lib/diva/diva.jar"/>
  </extclasspath>

  <!-- "Local" third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, say
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->
  
  </path>

  <!-- Extra user-defined classpath. This is set by the property 
   !   "extra.class.path" (which can be defined locally using say 
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>
  
  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
    <path refid="local.classpath"/>
    <path refid="built.classpath"/>
    <path refid="installed.classpath"/>
  </path>
    
  <!-- JUnit tests classpath, add tests.dir and tests.etc.dir so that
   !   resources may be located there -->
  <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>
  
  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages" 
          unless="runonly.install">

  </target>


  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here. 
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           optimize="${optimize}">

      <classpath refid="classpath"/>

      <include name="**/*.java"/>

      <!-- Exclude any Java files in the source tree that should not be
       !   compiled -->
      <!-- <exclude name=""/>-->
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="resources/**"/>
        <include name="**/*.properties"/>
        <include name="**/*.tcl"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Main-Class" value="jsky.app.jskycat.JSkyCat"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
    </signjar>

  </target>


 <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>JSKY - Java Components for Astronomy</title>
         <vendor>ESO</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"JSky - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="${name}/${name}.jar"/>
         <extension name="JSKY-PARTS" href="${name}-parts.jnlp"/>
       </resources>
       <application_desc main_class="jsky.app.jskycat.JSkyCat"/>
     </jnlp>

     <!-- May be needed as a component so provide that too -->
     <jnlp toFile="${dist.lib}/${name}-parts.jnlp" href="${name}-parts.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>JSKY - Java Components for Astronomy</title>
         <vendor>ESO</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"JSky - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
         <extension name="DIVA" href="diva.jnlp"/>
         <extension name="TAMFITS" href="tamfits.jnlp"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin.pkg}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <!--<mkdir dir="${dist.etc.pkg}"/>-->

    <!-- Copy any startup scripts etc. -->
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}" maxparallel="50"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}" maxparallel="50"/>
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}"
           maxparallel="50">
       <fileset dir="${dist.bin}"/>
    </chmod>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution 
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <!--<zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>-->

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <!--<tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>-->

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>
    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz" 
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2" 
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <!--<delete dir="${dist.etc}"/>-->

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin.pkg}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <!--<mkdir dir="${star.etc.pkg}"/>-->
    <mkdir dir="${star.docs.pkg}"/>

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>
  
    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <!--<mkdir dir="${dist.etc.pkg}"/>-->

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall" 
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <group title="${Name} API" packages="${package.name}*"/>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}" 
            packagelistLoc="${javaapi.lis}"/>

    </javadoc>
  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">
    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <include name="**/*.java"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   ! Note these are not JUnit based
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">
    <mkdir dir="${build.tests}"/>
    
    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           deprecation="${deprecation}" >
      <classpath refid="tests-classpath"/>
    </javac>
  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="compile-tests">
  </target>

  <target name="fullui"
          depends="compile-tests">
    <java classname="jsky.app.jskycat.JSkyCat" fork="true">
      <classpath refid="tests-classpath"/>
    </java>
  </target>


  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   JUnit build file
 !
 !   This file describes how to install the local JUnit package from its
 !   released state. It requires Apache ANT and a Java Development Kit.
 !
 !   The main targets are:
 !
 !      build            -> makes copies of local files that will be modified
 !      clean            -> removes local copies
 !      deinstall        -> undo the install target
 !      dist             -> makes package into dist state
 !      export           -> creates the full distribution archives
 !      export-runonly   -> same as export
 !      export-source    -> same as export
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> same as install
 !      jars             -> add manifest and sign jar files
 !      javadocs         -> does nothing
 !      javadoc-sources  -> does nothing
 !
 !   The targets that do nothing are provided for compatibility with
 !   the normal build system.
 !
 !   Authors:
 !      Peter W. Draper (02-AUG-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for JUnit" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="JUnit"/>
  <property name="name" value="junit"/>
  <property name="version" value="3.7"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing any unmodified jars of this package -->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Distribution directories, these are the actual state of this
   !   package at all times -->
  <property name="dist.dir" value="${basedir}"/>

  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  
  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://junit.org"/>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

  </target>

  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !   Just makes local copies of the package jar files so that they
   !   can be safely modified.
   !-->
  <target name="build"
          depends="prepare"
          description="-> make local copies of files for modification">

    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>

  </target>

  <!--
   !   ===========================
   !   Create the package jar file
   !   ===========================
   !
   !   This just updates the manifest and signs with using the local
   !   keystore.
   !-->
  <target name="jars"
          depends="build"
          description="-> packages jar files">

    <!-- Add the manifest to the main jar file, just an update -->
    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/junit.jar" basedir="${dist.dir}"
         update="true" excludes="**">

      <!-- Create the manifest -->
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
      </manifest>
      
    </jar>

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
    </signjar>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>JUNIT</title>
         <vendor>Junit.org</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"JUNIT - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="${name}/${name}.jar"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =============================
   !   Create the local distribution
   !   =============================
   !
   !  Nothing to do, this package is permanently in this condition.
   !-->
  <target name="dist"
          depends="jars,webstart"
          description="-> make package ready for distribution">       
  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  package.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  Same as export, except for the name.
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

    <antcall target="create_archives">
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. Same as export, except for the
   !  name.
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

    <antcall target="create_archives">
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required.
   ! For this package these are all the same just set the property
   ! "archive.name" to define what name to use for the outfile
   ! files. The archives are also written into the directory
   ! ${star.archive.dir} (the local directory by default).
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>
    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib"/>
      <zipfileset dir="${src.dir}" prefix="${name}/src"/>

    </zip>

    <tar longfile="gnu" destfile="${archive.name}.tar">

      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib"/>
      <tarfileset dir="${src.dir}" prefix="${name}/src"/>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz" 
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2" 
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>
  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !
   !   Removes copies of jar files.
   !-->
  <target name="clean"
          description="-> removes local copies">

    <delete dir="${dist.lib}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the package into another set of directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>

    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory. 
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   =========================================
   !
   ! Same as install.
   !-->
  <target name="install-runonly"
          description="-> install distribution into Starlink tree">

     <antcall target="install"/>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   ! that were copied into place by the install target. Does nothing
   ! if the installation log is not present.
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall" 
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Does nothing.
   !-->
  <target name="javadocs"
          description="-> does nothing">
  </target>

  <!--
   !   ==========================================
   !   Creates the API documentation java sources
   !   ==========================================
   !
   !  Does nothing.
   !-->
  <target name="javadoc-sources"
          description="-> does nothing">
  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          description="-> does nothing"/>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   Mirage build file
 !
 !   This file describes how to build and install Mirage
 !   from a source and binary release. Mirage is an application
 !   package, i.e. provides user-level commands and interfaces, as
 !   well as a programming API.
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for Mirage" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="Mirage"/>
  <property name="name" value="mirage"/>
  <property name="version" value="0.1"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.mirage"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="true"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.4"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default.
   !-->
  <property name="webstart.codebase"
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- Table -->
    <pathelement location="${star.jar.dir}/table/table.jar"/>

    <!-- Util -->
    <pathelement location="${star.jar.dir}/util/util.jar"/>

  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">

    <pathelement
       location="${star.build.dir}/table/lib/table/table.jar"/>
    <pathelement
       location="${star.build.dir}/util/lib/util/util.jar"/>

  </extclasspath>

  <!-- "Local" third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, say
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
<!--
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
-->
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property
   !   "extra.class.path" (which can be defined locally using say
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
    <path refid="local.classpath"/>
    <path refid="built.classpath"/>
    <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath, add tests.dir and tests.etc.dir so that
   !   resources may be located there -->
  <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!-- Table package -->
    <available property="table.present"
               classpathref="classpath"
               classname="uk.ac.starlink.table.StarTable"/>
    <fail message="No Table available" unless="table.present"/>

    <!-- Util package -->
    <available property="util.present"
               classpathref="classpath"
               classname="uk.ac.starlink.util.AuxClassLoader"/>
    <fail message="No Util available" unless="util.present"/>

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
        <token key="BUILT_BY" value="${user.name}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <classpath refid="classpath"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
      <exclude name="**/{Retired1.java}"/>
      <exclude name="**/{Retired2.java}"/>
      <exclude name="**/*.html"/>
      <exclude name="**/*.properties*"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/{package.support.files}"/>
        <include name="**/{more.package.support.files}"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
  <!--
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>
  -->

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs) on and
   !  defines the application entrance point. The jar files should be
   !  placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Main-Class"
                   value="uk.ac.starlink.mirage.MirageDriver"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>Mirage mediator classes</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink Mirage - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="${name}/${name}.jar"/>
         <extension name="TABLE" href="table.jnlp"/>
         <extension name="UTIL" href="util.jnlp"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin.pkg}"/>
    <mkdir dir="${dist.lib.pkg}"/>
  <!--  <mkdir dir="${dist.docs.pkg}"/> -->
  <!--  <mkdir dir="${dist.etc.pkg}"/> -->

    <!-- Copy any startup scripts etc. -->
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <!--<zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>-->
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <!--<zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>-->

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <!--<tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>-->
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <!--<tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>-->

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin.pkg}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <!--  <mkdir dir="${star.etc.pkg}"/> -->
    <mkdir dir="${star.docs.pkg}"/>

    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
  <!--   <mkdir dir="${dist.etc.pkg}"/> -->

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html">
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !
   !  Application packages should only make public those parts of
   !  their internal APIs that they are prepared to support. Consider
   !  adding such code to proper class libraries (such as util).
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          description="-> does nothing">
    <echo message="No tests defined"/>
  </target>
<!--
          depends="run-tests"
          description="-> run JUnit tests"/>
 !-->

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/JUnit*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   NDTools build file
 !
 !   This file describes how to build and install NDTools
 !   from a source and binary release. NDTools is an application
 !   package, i.e. provides user-level commands and interfaces, as
 !   well as a programming API.
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for NDTools" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="NDTools"/>
  <property name="name" value="ndtools"/>
  <property name="version" value="0.1"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.ndtools"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.4"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- NDX -->
    <pathelement location="${star.jar.dir}/ndx/ndx.jar"/>

    <!-- NDArray -->
    <pathelement location="${star.jar.dir}/array/array.jar"/>

    <!-- Task -->
    <pathelement location="${star.jar.dir}/task/task.jar"/>

  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">

    <pathelement
       location="${star.build.dir}/array/lib/array/array.jar"/>
    <pathelement
       location="${star.build.dir}/ndx/lib/ndx/ndx.jar"/>
    <pathelement
       location="${star.build.dir}/task/lib/task/task.jar"/>

  </extclasspath>

  <!-- "Local" third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, say
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
<!--
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
-->
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property
   !   "extra.class.path" (which can be defined locally using say
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
    <path refid="local.classpath"/>
    <path refid="built.classpath"/>
    <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath, add tests.dir and tests.etc.dir so that
   !   resources may be located there -->
  <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!--  NDX -->
    <available property="ndx.present"
               classpathref="classpath"
               classname="uk.ac.starlink.ndx.Ndx"/>

    <fail message="No NDX available" unless="ndx.present"/>

    <!--  NDArray -->
    <available property="ndarray.present"
               classpathref="classpath"
               classname="uk.ac.starlink.array.NDArray"/>
    <fail message="No NDArray available" unless="ndarray.present"/>
    

    <!--  Task -->
    <available property="task.present"
               classpathref="classpath"
               classname="uk.ac.starlink.task.Task"/>
    <fail message="No Task available" unless="task.present"/>


    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here. 
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <classpath refid="classpath"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
      <exclude name="**/{Retired1.java}"/>
      <exclude name="**/{Retired2.java}"/>
      <exclude name="**/*.html"/>
      <exclude name="**/*.properties*"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/{package.support.files}"/>
        <include name="**/{more.package.support.files}"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
<!--
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>
-->

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs) on and
   !  defines the application entrance point. The jar files should be
   !  placed directly in the distribution directories. 
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Main-Class" value="uk.ac.starlink.ndtools.NDTools"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <zip destfile="${dist.lib.pkg}/${name}_src.zip" basedir="${java.dir}"/>

    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>NDTOOLS - command line NDX tools</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink NDTOOLS - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="${name}/${name}.jar"/>
         <extension name="ARRAY" href="array.jnlp"/>
         <extension name="TASK" href="task.jnlp"/>
       </resources>
       <application_desc main_class="uk.ac.starlink.ndtools.NDTools"/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin.pkg}"/>
    <mkdir dir="${dist.lib.pkg}"/>

    <!-- Copy any startup scripts etc. -->
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <!--<zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>-->
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <!--<zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>-->

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <!--<tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>-->
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <!--<tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>-->

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin.pkg}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.etc.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.bin.pkg}
</echo>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <mkdir dir="${dist.etc.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html">
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   ! 
   !  Application packages should only make public those parts of
   !  their internal APIs that they are prepared to support. Consider
   !  adding such code to proper class libraries (such as util).
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          description="does nothing">
    <echo message="No tests defined"/>
  </target>
<!--
          depends="run-tests"
          description="-> run JUnit tests"/>
 !-->

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/JUnit*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>
<!DOCTYPE project SYSTEM "../project.dtd">

<!--
 !   NDX build file
 !
 !   This file describes how to build the NDX package from a source
 !   release. It requires Apache ANT and a Java Development Kit.
 !
 !   In addition NDX may have requirements for other "core" and
 !   "third-party" packages to complete the compilation and any
 !   testing.
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> install a runonly distribution into Starlink tree
 !      jars             -> creates the package jar file
 !      javadocs         -> creates the API documentation
 !      javadoc-sources  -> make source files for release API documention
 !!
 !! test targets yet to be done.
 !!
 !   Authors:
 !      Peter W. Draper (2-JUL-2002)        
 !      Mark Taylor (13-AUG-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for NDX" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- Directory containing native libraries. -->
  <property name="star.lib.arch" value="${star.install}/lib/${os.arch}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="NDX"/>
  <property name="name" value="ndx"/>
  <property name="version" value="0.2"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.ndx"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="true"/>
  <property name="junit.filtertrace" value="off"/>
  <property name="junit.summary" value="on"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that 
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may 
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an externally
   !   defined CLASSPATH can also be used as needed). 
   !-->
  <extclasspath id="installed.classpath">

    <!-- Array -->
    <pathelement location="${star.jar.dir}/array/array.jar"/>

    <!-- JNIAST -->
    <pathelement location="${star.jar.dir}/jniast/jniast.jar"/>

    <!-- Util -->
    <pathelement location="${star.jar.dir}/util/util.jar"/>

    <!-- JUnit -->
    <pathelement location="${star.jar.dir}/junit/junit.jar"/>

  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the external classpath.
   !-->
  <extclasspath id="built.jarpath">
    <!--
    I'm pretty sure that uk.ac.starlink.* aren't third-party!
    <pathelement location="${star.build.dir}/array/lib/array/array.jar"/>
    <pathelement location="${star.build.dir}/util/lib/util/util.jar"/>
    <pathelement location="${star.build.dir}/hds/lib/hds/hds.jar"/>
    -->
    <pathelement location="${star.build.dir}/junit/lib/junit/junit.jar"/>
    <pathelement location="${star.build.dir}/jniast/lib/jniast/jniast.jar"/>
  </extclasspath>

  <path id="built.classpath">

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->
  
  </path>

  <!-- Extra user-defined classpath. This is set by the property 
   !   "extra.class.path" (which can be defined locally using say 
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using local, built, installed order-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath -->
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages" 
          unless="runonly.install">

    <!--  Need Array -->
    <available property="array.present"
               classpathref="classpath"
               classname="uk.ac.starlink.array.NDArray"/>

    <fail message="No Array available" unless="array.present"/>

    <!--  Need JNIAST -->
    <available property="jniast.present"
               classpathref="classpath"
               classname="uk.ac.starlink.ast.Grf"/>

    <fail message="No JNIAST available" unless="jniast.present"/>

    <!--  Need Util -->
    <available property="util.present"
               classpathref="classpath"
               classname="uk.ac.starlink.util.SourceReader"/>

    <fail message="No Util available" unless="util.present"/>

    <!--  Would like JUnit for testing -->
    <condition property="testframework.present">
      <and>
        <available classpathref="tests-classpath"
                   classname="junit.framework.TestCase"/>
        <available classpathref="tests-classpath"
                   classname="uk.ac.starlink.util.TestCase"/>
      </and>
    </condition>
  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images) should also be copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
	   source="1.4"
           optimize="${optimize}">

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

      <!-- Exclude any Java files in the source tree that should not be
       !   compiled -->
      <exclude name="**/README*"/>
    </javac>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs) on and, if
   !  appropriate, defines the application entrance point. The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <zip destfile="${dist.lib.pkg}/${name}_src.zip" basedir="${java.dir}"/>

    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>

  </target>
  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>NDX API</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink NDX - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="ndx/ndx.jar"/>
         <extension name="ARRAY" href="array.jnlp"/>
         <extension name="JNIAST" href="jniast.jnlp"/>
         <extension name="HDX" href="hdx.jnlp"/>
       </resources>
       <component_desc/>
     </jnlp>
  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution 
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <!--<zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>-->
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <!--<zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>-->

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <!--<tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>-->
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <!--<tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>-->

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>
    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz" 
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2" 
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories. 
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory. 
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

    <!-- Make sure that the expected file structure exists, some
         of these files can be missing if originally empty -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Do normal install, but with many targets switched off-->
    <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}" failonerror="false"/>

  </target>


  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  The documentation is created from the Java sources. Should also
   !  extend this to include the possibility of other miscellaneous
   !  documentation (FAQs etc.).
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             source="1.4"
             windowtitle="${Name} API"
             doctitle="${Name}"
             classpathref="classpath">


      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
         <exclude name="**/support"/>
         <exclude name="**/testcases"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>
  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">
    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java **/*.html"/>
    </uptodate>
  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/support/*"/>
          <exclude name="**/makefile"/>
          <exclude name="**/testcases/*"/>
          <exclude name="**/VERSION"/>
          <exclude name="**/README"/>
          <exclude name="**/.*"/>
          <exclude name="**/*.swp"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="testframework.present">
    <mkdir dir="${build.tests}"/>

    <javac deprecation="${deprecation}"
           destdir="${build.tests}"
           debug="${debug}"
           srcdir="${tests.dir}">
      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="tests-classpath"/>
    </javac>
  </target>


  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="testframework.present">

    <junit printsummary="${junit.summary}"
           haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}"
           dir="${tests.etc.dir}"
           >

      <jvmarg value="-enableassertions"/>
      <!-- dir=... means we have that directory as the cwd when
           running the tests, so we can put test files there -->
      <classpath refid="tests-classpath"/>

      <sysproperty key="java.io.tmpdir" value="${build.tests}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="java.library.path" value="${star.lib.arch}"/>
      <sysproperty key="tests-classpath.value"
        value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="plain" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test*"/>
        </fileset>
      </batchtest>

    </junit>
  </target>


  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}"
          dir="${tests.etc.dir}">
      <jvmarg value="-enableassertions"/>
      <sysproperty key="java.io.tmpdir" value="${build.tests}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="java.library.path" value="${star.lib.arch}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>
    </junit>
  </target>



  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   ! 
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>

<!-- custom variables for emacs psgml mode (delete if you must, Mark!) -->
<!-- Local Variables: -->
<!-- mode: xml -->
<!-- sgml-indent-data: t -->
<!-- sgml-indent-step: 2 -->
<!-- End: -->
<?xml version="1.0"?>

<!--
 !   pal build file
 !
 !   This file describes how to build and install pal from
 !   source and binary releases. pal is a class library
 !   (i.e. provides an API and related documentation).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Roy Platon (08-JAN-2003)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for pal" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="PAL"/>
  <property name="name" value="pal"/>
  <property name="version" value="1.0-1"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.pal"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.4"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Any achitecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
           value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- {Other packages} -->

    <!-- {More packages} -->
  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">

    <!-- {More packages} -->
  </extclasspath>

  <!-- "Local" third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, say
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
 <!--
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  -->
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property
   !   "extra.class.path" (which can be defined locally using say
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath, add tests.dir and tests.etc.dir so that
   !   resources may be located there -->
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!--  {Example package1} -->
    <!--  {Example package2} -->

    <!-- {More critical dependencies} -->

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here. 
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
      <exclude name="**/{Retired1.java}"/>
      <exclude name="**/{Retired2.java}"/>
      <exclude name="**/*.html"/>
      <exclude name="**/*.properties*"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/{package.support.files}"/>
        <include name="**/{more.package.support.files}"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
 <!--
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>
 -->

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path"
            value=""/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>
  </target>


<!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
     <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>PAL - positional astronomy library</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink PAL - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="${name}/${name}.jar"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>


  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <!-- <mkdir dir="${dist.bin.pkg}"/> -->
    <mkdir dir="${dist.lib.pkg}"/>
    <!-- <mkdir dir="${dist.docs.pkg}"/> -->
    <!-- <mkdir dir="${dist.etc.pkg}"/> -->

    <!-- Copy any configuration/helper scripts etc. -->
  <!--
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>
  -->

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
  <!--
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>
  -->

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
  <!--
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>
  -->

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <!--<zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>-->
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <!--<zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>-->

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <!--<tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>-->
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <!--<tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>-->

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
    <!-- <mkdir dir="${star.bin.pkg}"/> -->
    <mkdir dir="${star.lib.pkg}"/>
    <!-- <mkdir dir="${star.etc.pkg}"/> -->
    <mkdir dir="${star.docs.pkg}"/>

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
  <!--
    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>
  -->

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory-->
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <mkdir dir="${dist.etc.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          description="-> does nothing"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/JUnit*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   PLASTIC build file
 !
 !   This file describes how to build and install PLASTIC from
 !   source and binary releases. PLASTIC is a class library
 !   (i.e. provides an API and related documentation).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for PLASTIC" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="PLASTIC"/>
  <property name="name" value="plastic"/>
  <property name="version" value="0.4+"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.plastic"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="true"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.4"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.docs" value="${build.dir}/docs"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>
  <property name="dist.www" value="${dist.dir}/www"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Any achitecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase"
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page"
            value="http://www.star.bristol.ac.uk/~mbt/plastic/"/>

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Installed jar files.
   !
   !   Name all the installed jar files of other packages that we depend on.
   !
   !   When compiling under Java 1.4 these will be used to produce a full
   !   classpath that is equivalent to that generated when these are
   !   referenced as optional bundled packages by the JVM.
   !   When compiling under Java 1.5 (and probably later) this is just
   !   a simple path of these jar files, as the expansion to a full optional
   !   bundled package classpath is performed by the compiler
   !
   !   What that all means is that the manifest classpaths of these jar files
   !   are honoured, the plain compiler pre Java 1.5 didn't do that. When Java
   !   1.4 is no longer used the extclasspath type can be replaced by a simple
   !   path.
   !-->
  <extclasspath id="installed.classpath">

    <pathelement location="${star.jar.dir}/util/util.jar"/>
    <pathelement location="${star.jar.dir}/xdoc/xdoc.jar"/>
  </extclasspath>

  <!-- Local build system jar files.
   !
   !   Name all the jar files of other packages that we depend on, which have
   !   not been installed (should be same packages as in installed.classpath).
   !-->
  <extclasspath id="built.jarpath">

    <pathelement location="${star.build.dir}/xdoc/lib/xdoc/xdoc.jar"/>
    <pathelement location="${star.build.dir}/util/lib/util/util.jar"/>
  </extclasspath>

  <!-- Find all local third party jars files.
   !
   !   Normally these will be kept in their own third party package, but may
   !   be kept here temporarily, say if there are version conflicts that
   !   cannot be addressed. They are installed with the package jar files and
   !   should be entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  </path>

  <!-- Create the local build system CLASSPATH.
   !
   !   Create the classpath used when building this package as part of a full
   !   build system without any dependency on any installed or external jar
   !   files.
   !
   !   Classes compiled in the local build tree will be in the "build/classes"
   !   part of each package. Third party packages, have do not have any source
   !   code, just jar files, will have their jar files in their "dist"
   !   directories (usually lib/{package_name}).
   !
   !   So the full built classpath is created by constructing a path
   !   consisting of:
   !
   !      - all third party jar files in this package
   !      - all build/classes directories in the local build system (these
   !        will have the most recent class files)
   !      - all jar files named in built.jarpath, i.e. named local build
   !        system jar files (these can be normal packages in the "dist" state
   !        or third party packages)
   !      - all jar files in the "dist" directories of all packages in the
   !        local build system (these are necessary to make sure that the jar
   !        files in the previous part have their dependencies fulfilled,
   !        without having them all installed)
   !-->
  <path id="built.classpath">

    <!-- Third party jars held by this package -->
    <path refid="package.jars"/>

    <!-- All classes in the local build system -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent jars in the local build system -->
    <path refid="built.jarpath"/>

    <!-- All "dist" jar files to make sure everything is resolved, including
     !   relative URLs of the local packages, without installation -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

  </path>

  <!-- User-defined CLASSPATH.
   !
   !   This is set by the property "extra.class.path" (which can be defined
   !   locally using say -Dextra.class.path=$CLASSPATH on the command line
   !   or by setting the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Create the full CLASSPATH used during compilation.
   !
   !   This is created from the user-defined classpath, followed by the
   !   classpath for building against the local system, followed by the
   !   classpath for building against an installed system.
   !-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- Create the JUnit tests CLASSPATH.
   ! 
   !   Note that in addition to the build/classes and build/tests directory
   !   we also add tests.dir and tests.etc.dir so that resources may be
   !   located there. The full classpath is also used.
   !-->  
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    ============
   !    Library path
   !    ============
   !    Used by test targets for locating native libraries.
   !-->
  <path id="tests-libpath.id">
    <pathelement path="${java.library.path}"/>
    <pathelement location="${star.jar.dir}/${os.arch}"/>
  </path>
  <property name="tests-libpath" refid="tests-libpath.id"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !
   !    Minimalist check of the required dependencies so that the build will
   !    not proceed if some basic dependencies are not present on the
   !    classpath. Optional components could also be checked here.
   !-->
  <target name="check_packages"
          unless="runonly.install">
    <!--
    <available property="{package1}.present"
               classpathref="classpath"
               classname="uk.ac.starlink.{package1}.{MainClass}"/>
    <fail message="No {package1} available" unless="{package1}.present"/>
    -->

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
      <exclude name="**/*.html"/>
      <exclude name="**/*.properties*"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${src.dir}/resources"/>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}">
         <include name="rmi-lite.jar"/>
         <include name="xmlrpc-2.0.jar"/>
         <include name="commons-codec-1.3.jar"/>
       </fileset>
    </copy>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
        <attribute name="Main-Class" value="uk.ac.starlink.plastic.PlasticDoc"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib.pkg}" includes="**/*.jar"
                                     excludes="**/microhub.jar"/>
    </signjar>

  </target>

  <!--
   !   ===============================================================
   !   Builds a jar file containing minimal classes for a working hub.
   !   ===============================================================
   !-->
  <target name="microhub"
          depends="jars"
          description="-> build microhub.jar file">
    <java classpath="${src.jars.dir}/proguard.jar"
          classname="proguard.ProGuard"
          fork="true">
      <arg value="-libraryjars"/>
           <arg value="&lt;java.home&gt;/lib/rt.jar"/>
      <arg value="-libraryjars"/>
           <arg value="&lt;java.home&gt;/lib/jsse.jar"/>
      <arg value="-libraryjars"/>
           <arg value="${src.jars.dir}/servletapi-2.2.jar"/>
      <arg value="-libraryjars"/>
           <arg value="${src.jars.dir}/rmi-lite.jar"/>
      <arg value="-injars"/>
           <arg value="${dist.lib.pkg}/plastic.jar(**.class)"/>
      <arg value="-injars"/>
           <arg value="${dist.lib.pkg}/commons-codec-1.3.jar(**.class)"/>
      <arg value="-injars"/>
           <arg value="${dist.lib.pkg}/xmlrpc-2.0.jar(**.class)"/>
      <arg value="-keep"/>
           <arg value="public class uk.ac.starlink.plastic.MinimalHub {public static void main(java.lang.String[]);}"/>
      <arg value="-outjars"/> <arg value="${build.dir}/microhub.jar"/>
      <arg value="-dontoptimize"/>
      <arg value="-dontobfuscate"/>
    </java>
    <unjar src="${build.dir}/microhub.jar" dest="${build.dir}/microclasses"/>
    <unjar src="${src.jars.dir}/rmi-lite.jar" dest="${build.dir}/microclasses"/>
    <unjar src="${dist.lib.pkg}/${name}.jar" dest="${build.dir}/microclasses">
      <patternset>
        <include name="org/votech/plastic/**"/>
      </patternset>
    </unjar>
    <delete file="${build.dir}/microhub.jar"/>
    <jar destfile="${dist.lib.pkg}/microhub.jar"
         basedir="${build.dir}/microclasses">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Main-Class" value="uk.ac.starlink.plastic.MinimalHub"/>
      </manifest>
    </jar>
  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this class library.
     !   This goes into "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">

      <information>
         <title>PLASTIC - support and utilities for the PLASTIC protocol</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink PLASTIC - Webstart edition"</description>
         <offline_allowed/>
       </information>

       <security>
          <all_permissions/>
       </security>

       <resources>
         <j2se version="1.5+"/>
         <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
       </resources>

       <!-- This is a component -->
       <component_desc/>

     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin.pkg}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <mkdir dir="${dist.etc.pkg}"/>

    <!-- Copy any configuration/helper scripts etc. -->
 <!--
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>
  -->

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
 <!--
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>
  -->

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>
    <delete dir="${dist.www}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin.pkg}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.etc.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory-->
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   =============================
   !   Prepare distribution web page
   !   =============================
   !-->
  <target name="www"
          depends="dist,microhub"
          description="-> Prepare files for distribution web page">
    <mkdir dir="${dist.www}"/>

    <copy todir="${dist.www}">
      <fileset dir="${dist.lib.pkg}"/>
    </copy>
    <mkdir dir="${dist.www}/images"/>
    <copy todir="${dist.www}/images">
      <fileset dir="${src.dir}/resources/uk/ac/starlink/plastic/"
               includes="*.gif"/>
    </copy>

    <java classname="uk.ac.starlink.util.SuperJar" failonerror="yes">
      <classpath refid="classpath"/>
      <arg value="-o"/><arg value="${dist.www}/${name}-full.jar"/>
      <arg value="${dist.www}/${name}.jar"/>
    </java>

    <zip destfile="${dist.www}/${name}-src.zip"
         basedir="${java.dir}"
         includes="**/*.java">
    </zip>

    <zip destfile="${dist.www}/${name}-javadocs.zip"
         basedir="${dist.docs.pkg}/javadocs">
    </zip>

    <unzip src="${dist.www}/${name}-javadocs.zip"
           dest="${dist.www}/javadocs/"/>       

    <java classname="uk.ac.starlink.xdoc.XalanProc"
          output="${dist.www}/index.html"
          dir="${dist.www}" fork="yes"
          logerror="yes"
          failonerror="yes">
      <classpath refid="classpath"/>
      <arg value="${star.dir}/etc/xdoc/xhtml.xslt"/>
      <arg value="${src.docs}/${name}.xhtml"/>
    </java>
  </target>

  <!--
   !   ================
   !   Deploy www files
   !   ================
   !-->
  <target name="install-www"
          depends="www"
          description="-> Deploy files to www page">
    <property name="plastic.www.dir" value="${user.home}/public_html/plastic"/>
    <delete dir="${plastic.www.dir}"/>
    <mkdir dir="${plastic.www.dir}"/>
    <copy todir="${plastic.www.dir}">
      <fileset dir="${dist.www}"/>
    </copy>
  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <mkdir dir="${dist.etc.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <tag name="xmlrpc" description="XML-RPC" enabled="true"/>
      <tag name="service" description="AstroGrid Service" enabled="false"/>
      <tag name="date" description="Date" enabled="false"/>
      <tag name="example" description="Example" enabled="true"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <sysproperty key="tests.withnet" value="${tests.withnet}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <sysproperty key="tests.withnet" value="${tests.withnet}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   RAYREG build file
 !
 !   This file describes how to build and install RAYREG from
 !   source and binary releases. RAYREG is a class library
 !   (i.e. provides an API and related documentation).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for RAYREG" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="RAYREG"/>
  <property name="name" value="rayreg"/>
  <property name="version" value="1.0"/>

  <!-- The Java package name -->
  <property name="package.name" value="{package.path}"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.5"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Any achitecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase"
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Installed jar files.
   !
   !   Name all the installed jar files of other packages that we depend on.
   !
   !   When compiling under Java 1.4 these will be used to produce a full
   !   classpath that is equivalent to that generated when these are
   !   referenced as optional bundled packages by the JVM.
   !   When compiling under Java 1.5 (and probably later) this is just
   !   a simple path of these jar files, as the expansion to a full optional
   !   bundled package classpath is performed by the compiler
   !
   !   What that all means is that the manifest classpaths of these jar files
   !   are honoured, the plain compiler pre Java 1.5 didn't do that. When Java
   !   1.4 is no longer used the extclasspath type can be replaced by a simple
   !   path.
   !-->
  <extclasspath id="installed.classpath">
    <pathelement location="${star.jar.dir}/axis/axis.jar"/>
  </extclasspath>

  <!-- Local build system jar files.
   !
   !   Name all the jar files of other packages that we depend on, which have
   !   not been installed (should be same packages as in installed.classpath).
   !-->
  <extclasspath id="built.jarpath">
    <pathelement location="${star.build.dir}/lib/axis/axis.jar"/>
  </extclasspath>

  <!-- Find all local third party jars files.
   !
   !   Normally these will be kept in their own third party package, but may
   !   be kept here temporarily, say if there are version conflicts that
   !   cannot be addressed. They are installed with the package jar files and
   !   should be entered into the main jar file manifest.
   !-->
  <path id="package.jars">
  <!--
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
   !-->
  </path>

  <!-- Create the local build system CLASSPATH.
   !
   !   Create the classpath used when building this package as part of a full
   !   build system without any dependency on any installed or external jar
   !   files.
   !
   !   Classes compiled in the local build tree will be in the "build/classes"
   !   part of each package. Third party packages, have do not have any source
   !   code, just jar files, will have their jar files in their "dist"
   !   directories (usually lib/{package_name}).
   !
   !   So the full built classpath is created by constructing a path
   !   consisting of:
   !
   !      - all third party jar files in this package
   !      - all build/classes directories in the local build system (these
   !        will have the most recent class files)
   !      - all jar files named in built.jarpath, i.e. named local build
   !        system jar files (these can be normal packages in the "dist" state
   !        or third party packages)
   !      - all jar files in the "dist" directories of all packages in the
   !        local build system (these are necessary to make sure that the jar
   !        files in the previous part have their dependencies fulfilled,
   !        without having them all installed)
   !-->
  <path id="built.classpath">

    <!-- Third party jars held by this package -->
    <path refid="package.jars"/>

    <!-- All classes in the local build system -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent jars in the local build system -->
    <path refid="built.jarpath"/>

    <!-- All "dist" jar files to make sure everything is resolved, including
     !   relative URLs of the local packages, without installation -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

  </path>

  <!-- User-defined CLASSPATH.
   !
   !   This is set by the property "extra.class.path" (which can be defined
   !   locally using say -Dextra.class.path=$CLASSPATH on the command line
   !   or by setting the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Create the full CLASSPATH used during compilation.
   !
   !   This is created from the user-defined classpath, followed by the
   !   classpath for building against the local system, followed by the
   !   classpath for building against an installed system.
   !-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- Create the JUnit tests CLASSPATH.
   ! 
   !   Note that in addition to the build/classes and build/tests directory
   !   we also add tests.dir and tests.etc.dir so that resources may be
   !   located there. The full classpath is also used.
   !-->  
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    ============
   !    Library path
   !    ============
   !    Used by test targets for locating native libraries.
   !-->
  <path id="tests-libpath.id">
    <pathelement path="${java.library.path}"/>
    <pathelement location="${star.jar.dir}/${os.arch}"/>
  </path>
  <property name="tests-libpath" refid="tests-libpath.id"/>

  <!--
   !    ===============
   !    Extension tasks
   !    ===============
   !    Add any local or extension ANT tasks that are required. Local
   !    tasks should be moved into the ANT package if used outside of this
   !    package. 
   !-->
  <taskdef resource="axis-tasks.properties" classpathref="classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !
   !    Minimalist check of the required dependencies so that the build will
   !    not proceed if some basic dependencies are not present on the
   !    classpath. Optional components could also be checked here.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!-- AXIS -->
    <available property="axis.present"
               classpathref="classpath"
               classname="org.apache.axis.client.Service"/>
    <fail message="No AXIS available" unless="axis.present"/>

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">
      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>
      <include name="**/*.java"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
 <!--
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/{package.support.files}"/>
        <include name="**/{more.package.support.files}"/>
      </fileset>
    </copy>
  !-->

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
 <!--
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>
  !-->

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">
    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Main-Class"
                   value="net.ivoa.registry.search.test.TestRegistryClient"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib.pkg}" includes="*.jar"/>
    </signjar>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this class library.
     !   This goes into "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">

      <information>
         <title>RAYREG - Registry access classes by Ray Plante</title>
         <vendor>NVO</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"RAYREG - Webstart edition"</description>
         <offline_allowed/>
       </information>

       <security>
          <all_permissions/>
       </security>

       <resources>
         <j2se version="1.5+"/>

         <!-- Define the main library jar file -->
         <jar href="${name}/${name}.jar"/>

         <!-- Name any extension packages we directly depend on -->
         <extension name="AXIS" href="axis.jnlp"/>
       </resources>

       <!-- This is a component -->
       <component_desc/>

     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin.pkg}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <mkdir dir="${dist.etc.pkg}"/>

    <!-- Copy any configuration/helper scripts etc. -->
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin.pkg}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.etc.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory-->
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <mkdir dir="${dist.etc.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

 <!--
    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <classpath refid="tests-classpath"/>

    </javac>
 -->

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

 <!--
    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/JUnit*"/>
        </fileset>
      </batchtest>

    </junit>
 -->

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   REGISTRY build file
 !
 !   This file describes how to build and install REGISTRY from
 !   source and binary releases.  REGISTRY is a class library
 !   (i.e. provides an API and related documentation).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for REGISTRY" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="REGISTRY"/>
  <property name="name" value="registry"/>
  <property name="version" value="1.2"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.registry"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.5"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Any achitecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase"
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/"/>

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Installed jar files.
   !
   !   Name all the installed jar files of other packages that we depend on.
   !
   !   When compiling under Java 1.4 these will be used to produce a full
   !   classpath that is equivalent to that generated when these are
   !   referenced as optional bundled packages by the JVM.
   !   When compiling under Java 1.5 (and probably later) this is just
   !   a simple path of these jar files, as the expansion to a full optional
   !   bundled package classpath is performed by the compiler
   !
   !   What that all means is that the manifest classpaths of these jar files
   !   are honoured, the plain compiler pre Java 1.5 didn't do that. When Java
   !   1.4 is no longer used the extclasspath type can be replaced by a simple
   !   path.
   !-->
  <extclasspath id="installed.classpath">

    <!-- {Other packages} -->
    <pathelement location="${star.jar.dir}/rayreg/rayreg.jar"/>

  </extclasspath>

  <!-- Local build system jar files.
   !
   !   Name all the jar files of other packages that we depend on, which have
   !   not been installed (should be same packages as in installed.classpath).
   !-->
  <extclasspath id="built.jarpath">

    <pathelement location="${star.build.dir}/rayreg/lib/rayreg/rayreg.jar"/>

  </extclasspath>

  <!-- Find all local third party jars files.
   !
   !   Normally these will be kept in their own third party package, but may
   !   be kept here temporarily, say if there are version conflicts that
   !   cannot be addressed. They are installed with the package jar files and
   !   should be entered into the main jar file manifest.
   !-->
  <path id="package.jars">
 <!--
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
 -->
  </path>

  <!-- Create the local build system CLASSPATH.
   !
   !   Create the classpath used when building this package as part of a full
   !   build system without any dependency on any installed or external jar
   !   files.
   !
   !   Classes compiled in the local build tree will be in the "build/classes"
   !   part of each package. Third party packages, have do not have any source
   !   code, just jar files, will have their jar files in their "dist"
   !   directories (usually lib/{package_name}).
   !
   !   So the full built classpath is created by constructing a path
   !   consisting of:
   !
   !      - all third party jar files in this package
   !      - all build/classes directories in the local build system (these
   !        will have the most recent class files)
   !      - all jar files named in built.jarpath, i.e. named local build
   !        system jar files (these can be normal packages in the "dist" state
   !        or third party packages)
   !      - all jar files in the "dist" directories of all packages in the
   !        local build system (these are necessary to make sure that the jar
   !        files in the previous part have their dependencies fulfilled,
   !        without having them all installed)
   !-->
  <path id="built.classpath">

    <!-- Third party jars held by this package -->
    <path refid="package.jars"/>

    <!-- All classes in the local build system -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent jars in the local build system -->
    <path refid="built.jarpath"/>

    <!-- All "dist" jar files to make sure everything is resolved, including
     !   relative URLs of the local packages, without installation -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

  </path>

  <!-- User-defined CLASSPATH.
   !
   !   This is set by the property "extra.class.path" (which can be defined
   !   locally using say -Dextra.class.path=$CLASSPATH on the command line
   !   or by setting the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Create the full CLASSPATH used during compilation.
   !
   !   This is created from the user-defined classpath, followed by the
   !   classpath for building against the local system, followed by the
   !   classpath for building against an installed system.
   !-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- Create the JUnit tests CLASSPATH.
   ! 
   !   Note that in addition to the build/classes and build/tests directory
   !   we also add tests.dir and tests.etc.dir so that resources may be
   !   located there. The full classpath is also used.
   !-->  
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    ============
   !    Library path
   !    ============
   !    Used by test targets for locating native libraries.
   !-->
  <path id="tests-libpath.id">
    <pathelement path="${java.library.path}"/>
    <pathelement location="${star.jar.dir}/${os.arch}"/>
  </path>
  <property name="tests-libpath" refid="tests-libpath.id"/>

  <!--
   !    ===============
   !    Extension tasks
   !    ===============
   !    Add any local or extension ANT tasks that are required. Local
   !    tasks should be moved into the ANT package if used outside of this
   !    package. 
   !-->
  <taskdef resource="axis-tasks.properties" classpathref="classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !
   !    Minimalist check of the required dependencies so that the build will
   !    not proceed if some basic dependencies are not present on the
   !    classpath. Optional components could also be checked here.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <compilerarg value="-Xlint:unchecked"/>
      <classpath refid="classpath"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
 <!--
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/{package.support.files}"/>
        <include name="**/{more.package.support.files}"/>
      </fileset>
    </copy>
 -->

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
 <!--
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>
 -->

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this class library.
     !   This goes into "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">

      <information>
         <title>REGISTRY - registry access classes</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink REGISTRY - Webstart edition"</description>
         <offline_allowed/>
       </information>

       <security>
          <all_permissions/>
       </security>

       <resources>
         <j2se version="1.5+"/>

         <!-- Define the main library jar file -->
         <jar href="${name}/${name}.jar"/>

         <!-- Name any extension packages we directly depend on -->
         <extension name="rayreg" href="rayreg.jnlp"/>
       </resources>

       <!-- This is a component -->
       <component_desc/>

     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin.pkg}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <mkdir dir="${dist.etc.pkg}"/>

    <!-- Copy any configuration/helper scripts etc. -->
 <!--
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>
 -->

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
 <!--
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>
  -->

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
 <!--
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>
 -->

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin.pkg}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.etc.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory-->
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <mkdir dir="${dist.etc.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">
<!--
    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <classpath refid="tests-classpath"/>

    </javac>
 -->

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

<!--
    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test*"/>
        </fileset>
      </batchtest>

    </junit>
 -->

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   rv build file
 !
 !   This file describes how to build and install rv from
 !   source and binary releases.
 !   rv is a application to Calculate radial velocities.
 !   (uses pal - Positional Astronomy Library).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Roy Platon (27-JAN-2003)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for rv" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="RV"/>
  <property name="name" value="rv"/>
  <property name="version" value="1.0"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.rv"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.4"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Any achitecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
           value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- {Other packages} -->
    <pathelement location="${star.jar.dir}/pal/pal.jar"/>

    <!-- {More packages} -->
  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">

    <!-- {More packages} -->
  </extclasspath>

  <!-- "Local" third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, say
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
 <!--
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
 -->
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property
   !   "extra.class.path" (which can be defined locally using say
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath, add tests.dir and tests.etc.dir so that
   !   resources may be located there -->
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!--  {Example package1} -->
    <!--  {Example package2} -->

    <!-- {More critical dependencies} -->

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here. 
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <classpath refid="classpath"/>
      <compilerarg value="-proc:none" compiler="javac1.6"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
      <exclude name="**/{Retired1.java}"/>
      <exclude name="**/{Retired2.java}"/>
      <exclude name="**/*.html"/>
      <exclude name="**/*.properties*"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/{package.support.files}"/>
        <include name="**/{more.package.support.files}"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
 <!--
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>
 -->

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
        <attribute name="Main-Class" value="uk.ac.starlink.rv.RV"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>RV - radial components of observer's velocity</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink RV - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="${name}/${name}.jar"/>
         <extension name="PAL" href="pal.jnlp"/>
       </resources>
       <application_desc main_class="uk.ac.starlink.rv.RV"/>
     </jnlp>

     <!-- May be needed as a component so provide that too -->
     <jnlp toFile="${dist.lib}/${name}-parts.jnlp" href="${name}-parts.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>RV - radial components of observer's velocity</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink RV - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="${name}/${name}.jar"/>
         <extension name="PAL" href="pal.jnlp"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <!-- <mkdir dir="${dist.bin.pkg}"/> -->
    <mkdir dir="${dist.lib.pkg}"/>
    <!-- <mkdir dir="${dist.docs.pkg}"/> -->
    <!-- <mkdir dir="${dist.etc.pkg}"/> -->

    <!-- Copy any configuration/helper scripts etc. -->
  <!--
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>
  -->

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
  <!--
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>
  -->

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
  <!--
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>
  -->

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <!--<zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>-->
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <!--<zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>-->

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <!--<tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>-->
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <!--<tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>-->

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
    <!-- <mkdir dir="${star.bin.pkg}"/> -->
    <mkdir dir="${star.lib.pkg}"/>
    <!-- <mkdir dir="${star.etc.pkg}"/> -->
    <mkdir dir="${star.docs.pkg}"/>

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
  <!-- 
    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>
  -->

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory-->
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <!-- <mkdir dir="${dist.bin.pkg}"/> -->
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <!-- <mkdir dir="${dist.etc.pkg}"/> -->

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          description="-> does nothing"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/JUnit*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   SOAPSERVER build file
 !
 !   This file describes how to build the SOAPSERVER package from a
 !   source release. It requires Apache ANT and a Java Development Kit.
 !
 !   In addition HDX may have requirements for other "core" and
 !   "third-party" packages to complete the compilation and any
 !   testing.
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> install a runonly distribution into Starlink tree
 !      jars             -> creates the package jar file
 !      javadocs         -> creates the API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs a simple test
 !
 !   Authors:
 !      Peter W. Draper (2-JUL-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for SOAPSERVER" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="SOAPSERVER"/>
  <property name="name" value="soapserver"/>
  <property name="version" value="0.4"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.soap"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that 
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may 
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed). 
   !-->
  <extclasspath id="installed.classpath">

    <!-- Jetty -->
    <pathelement location="${star.jar.dir}/jetty/org.mortbay.jetty.jar"/>
    
    <!-- Axis -->
    <pathelement location="${star.jar.dir}/axis/axis.jar"/>

  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">
    <pathelement location="${star.build.dir}/jetty/lib/jetty/org.mortbay.jetty.jar"/>
    <pathelement location="${star.build.dir}/axis/lib/axis/axis.jar"/>
  </extclasspath>

  <!-- Local third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, so
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <!--<fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>-->
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->
  
  </path>

  <!-- Extra user-defined classpath. This is set by the property 
   !   "extra.class.path" (which can be defined locally using say 
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>
  
  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
    <path refid="local.classpath"/>
    <path refid="built.classpath"/>
    <path refid="installed.classpath"/>
  </path>
  
  <!-- Tests classpath -->
  <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    
    <!-- Pick up any uninstalled resources -->
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    
    <!-- Include the full classpath -->
    <path refid="classpath"/>
  </path>
  
  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>
  
  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages" unless="runonly.install">

    <!-- Need Jetty and Axis... -->
    <available property="jetty.present"
               classpathref="classpath"
               classname="org.mortbay.http.HttpServer"/>
    <fail message="No Jetty available" unless="jetty.present"/>

    <available property="axis.present"
               classpathref="classpath"
               classname="org.apache.axis.AxisEngine"/>
    <fail message="No Axis available" unless="axis.present"/>

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images) should also be copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           optimize="${optimize}">

      <classpath refid="classpath"/>

      <!-- Exclude any Java files in the source tree that should not be
       !   compiled -->
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/deploy.wsdd"/>
        <include name="**/jetty.xml"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <!--<copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>-->

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs) on and, if
   !  appropriate, defines the application entrance point. The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>
   
    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>SOAPSERVER</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink SOAPSERVER - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="${name}/${name}.jar"/>
         <extension name="AXIS" href="axis.jnlp"/>
         <extension name="JETTY" href="jetty.jnlp"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin.pkg}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <!--<mkdir dir="${dist.etc.pkg}"/>-->

    <!-- Copy any startup scripts etc. -->
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
    <!--<copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>-->

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution 
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <!--<zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>-->

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <!--<tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>-->

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>
    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz" 
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2" 
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <!--<delete dir="${dist.etc}"/>-->

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories. 
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin.pkg}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <!--<mkdir dir="${star.etc.pkg}"/>-->
    <mkdir dir="${star.docs.pkg}"/>

    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory. 
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.bin.pkg}
</echo>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <!--<mkdir dir="${dist.etc.pkg}"/>-->

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall" 
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  The documentation is created from the Java sources. Should also
   !  extend this to include the possibility of other miscellaneous
   !  documentation (FAQs etc.).
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>
  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">
    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>
  </target>


  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->

    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/deploy.wsdd"/>
          <exclude name="**/jetty.xml"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   ! Note these are not JUnit based.
   !-->
  <target name="compile-tests"
          depends="build">
    
    <mkdir dir="${build.tests}"/>
    
    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           deprecation="${deprecation}" >
      <classpath refid="tests-classpath"/>
    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   ! Note these are not JUnit based.
   !-->
  <target name="test"
          description="does nothing"/>

  <target name="testserver"
          depends="compile-tests">
    
    <!-- Run a detached process that we can send a SOAP message to -->
    <echo message="Running up EchoServer..."/>
    <exec executable="src/testcases/runEchoServer.sh" 
          dir="." timeout="20000">
      <env key="CLASSPATH" value="${tests-classpath.value}"/>
    </exec>

    <!-- Wait for server socket to appear. Nice!-->
    <waitfor maxwait="20" maxwaitunit="second">
      <and>
        <socket server="localhost" port="8080"/>
        <http url="http://localhost:8080"/>
      </and>
    </waitfor>

    <!-- Talk to server -->
    <echo message="Sending a tomato"/>
    <java classname="EchoClient" fork="true">
      <classpath refid="tests-classpath"/>
      <arg value="tomato"/>
    </java>

    <!-- Make server exit -->
    <echo message="Sending an exit"/>
    <java classname="EchoClient" fork="true">
      <classpath refid="tests-classpath"/>
      <arg value="exit"/>
    </java>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   ! 
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   SOG build file
 !
 !   This file describes how to build the SOG package from a source
 !   release. It requires Apache ANT and a Java Development Kit.
 !
 !   In addition SOG may have requirements for other "core" and
 !   "third-party" packages to complete the compilation and any
 !   testing.
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> install a runonly distribution into Starlink tree
 !      jars             -> creates the package jar file
 !      javadocs         -> creates the API documentation
 !      javadoc-sources  -> does nothing
 !      test             -> run up SOG from local build
 !
 !   Authors:
 !      Peter W. Draper (9-JUL-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for SOG" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="SOG"/>
  <property name="name" value="sog"/>
  <property name="version" value="0.3"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.sog"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.4"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="true"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- JSky -->
    <pathelement location="${star.jar.dir}/jsky/jsky.jar"/>

    <!-- JNIAST -->
    <pathelement location="${star.jar.dir}/jniast/jniast.jar"/>

    <!-- NDArray-->
    <pathelement location="${star.jar.dir}/array/array.jar"/>

    <!-- DIVA -->
    <pathelement location="${star.jar.dir}/diva/diva.jar"/>

    <!-- JAIUtil -->
    <pathelement location="${star.jar.dir}/jaiutil/jaiutil.jar"/>

    <!-- SOAPSERVER -->
    <pathelement location="${star.jar.dir}/soapserver/soapserver.jar"/>

    <!-- ASTGUI -->
    <pathelement location="${star.jar.dir}/astgui/astgui.jar"/>

  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">
    <pathelement location="${star.build.dir}/jsky/lib/jsky/jsky.jar"/>
    <pathelement location="${star.build.dir}/array/lib/array/array.jar"/>
    <pathelement location="${star.build.dir}/fits/lib/fits/fits.jar"/>
    <pathelement location="${star.build.dir}/hds/lib/hds/hds.jar"/>
    <pathelement location="${star.build.dir}/diva/lib/diva/diva.jar"/>
    <pathelement location="${star.build.dir}/jniast/lib/jniast/jniast.jar"/>
    <pathelement location="${star.build.dir}/astgui/lib/astgui/astgui.jar"/>
  </extclasspath>

  <!-- Local third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, so
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <!--<fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>-->
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property
   !   "extra.class.path" (which can be defined locally using say
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
    <path refid="local.classpath"/>
    <path refid="built.classpath"/>
    <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath -->
  <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!--  Need NDArray -->
    <available property="array.present"
               classpathref="classpath"
               classname="uk.ac.starlink.array.NDArray"/>

    <fail message="No NDArray available" unless="array.present"/>

    <!--  Need JNIAST -->
    <available property="jniast.present"
               classpathref="classpath"
               classname="uk.ac.starlink.ast.Grf"/>

    <fail message="No JNIAST available" unless="jniast.present"/>

    <!--  Need NDX -->
    <available property="ndx.present"
               classpathref="classpath"
               classname="uk.ac.starlink.ndx.Ndx"/>

    <fail message="No NDX available" unless="ndx.present"/>

    <!--  Need JAIUtil -->
    <available property="jaiutil.present"
               classpathref="classpath"
               classname="uk.ac.starlink.jaiutil.HDXCodec"/>

    <fail message="No JAIUtil available" unless="jaiutil.present"/>

    <!--  Need JSky -->
    <available property="jsky.present"
               classpathref="classpath"
               classname="jsky.app.jskycat.JSkyCat"/>

    <fail message="No JSky classes available" unless="jsky.present"/>

    <!-- Need SOAPSERVER -->
    <available property="soapserver.present"
               classpathref="classpath"
               classname="uk.ac.starlink.soap.AppHttpSOAPServer"/>

    <fail message="No SOAPSERVER classes available" unless="soapserver.present"/>

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>
  </target>


  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images) should also be copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           source="${source.version}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           optimize="${optimize}">

      <classpath refid="classpath"/>
      <compilerarg value="-proc:none" compiler="javac1.6"/>

      <!-- Exclude any Java files in the source tree that should not be
       !   compiled -->
      <!-- <exclude name=""/>-->
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/deploy.wsdd"/>
        <include name="**/images/**"/>
        <include name="**/*.xml"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <!--<mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>-->

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs) on and, if
   !  appropriate, defines the application entrance point. The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Main-Class" value="uk.ac.starlink.sog.SOG"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
     </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
    </signjar>

  </target>

 <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>SoG - Son of GAIA</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>SoG - Webstart edition</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="${name}/${name}.jar"/>
         <extension name="SOG-PARTS" href="${name}-parts.jnlp"/>
       </resources>
       <application_desc main_class="uk.ac.starlink.sog.SOG"/>
     </jnlp>

     <!-- May be needed as a component so provide that too -->
     <jnlp toFile="${dist.lib}/${name}-parts.jnlp" href="${name}-parts.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>SoG - Son of GAIA</title>
         <vendor>ESO</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>SoG - Webstart edition</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="${name}/${name}.jar"/>
         <extension name="JSKY-PARTS" href="jsky-parts.jnlp"/>
         <extension name="ARRAY" href="array.jnlp"/>
         <extension name="NDX" href="ndx.jnlp"/>
         <extension name="JAIUTIL" href="jaiutil.jnlp"/>
         <extension name="HDS" href="hds.jnlp"/> 
         <extension name="JNIAST" href="jniast.jnlp"/>
         <extension name="SOAPSERVER" href="soapserver.jnlp"/>
         <extension name="ASTGUI" href="astgui.jnlp"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin.pkg}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <!--<mkdir dir="${dist.etc.pkg}"/>-->

    <!-- Copy any startup scripts etc. -->
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
    <!--<copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>-->

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <!--<zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>-->

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <!--<tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>-->

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>
    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <!--<delete dir="${dist.etc}"/>-->

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin.pkg}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <!--<mkdir dir="${star.etc.pkg}"/>-->
    <mkdir dir="${star.docs.pkg}"/>

    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.bin.pkg}
</echo>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <!--<mkdir dir="${dist.etc.pkg}"/>-->

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  The documentation is created from the Java sources. Should also
   !  extend this to include the possibility of other miscellaneous
   !  documentation (FAQs etc.).
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>
  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">
    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>
  </target>

  <!--
   !   ==========================================
   !   Creates the API documentation java sources
   !   ==========================================
   !
   !  Just copies the sources into the correct place.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documentation">
     <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->

    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/JUnit*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   ! Note these are not JUnit based.
   !-->
  <target name="fullui"
          depends="compile-tests">

    <!-- Run up SOG from the local build, setup to be debugged from socket -->
    <java classname="uk.ac.starlink.sog.SOG" fork="true">
      <classpath refid="tests-classpath"/>
      <jvmarg value="-Daxis.EngineConfigFactory=uk.ac.starlink.soap.AppEngineConfigurationFactory"/>
      <jvmarg value="-Daxis.ServerFactory=uk.ac.starlink.soap.AppAxisServerFactory"/>
      <jvmarg value="-Xdebug"/>
      <jvmarg value="-Xnoagent"/>
      <jvmarg value="-Djava.compiler=NONE"/>
      <jvmarg value="-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=7001"/>
      <arg line="-port 8082"/>
      <arg value="src/etc/data/cobe.xml"/>
    </java>

  </target>

  <target name="photomui"
          depends="compile-tests">

    <java classname="uk.ac.starlink.sog.photom.AperturePhotometryFrame" 
          fork="true">
      <classpath refid="tests-classpath"/>
      <jvmarg value="-Xdebug"/>
      <jvmarg value="-Xnoagent"/>
      <jvmarg value="-Djava.compiler=NONE"/>
      <jvmarg value="-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=7002"/>
    </java>

  </target>

  <target name="photomws"
          depends="compile-tests">

    <java classname="uk.ac.starlink.sog.photom.PhotomWS" 
          fork="true">
      <classpath refid="tests-classpath"/>
    </java>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "../project.dtd">

<!--
 !   SPLAT build file
 !
 !   This file describes how to build the SPLAT package from a source
 !   release. It requires Apache ANT and a Java Development Kit.
 !
 !   In addition SPLAT may have requirements for other "core" and
 !   "third-party" packages to complete the compilation and any
 !   testing.
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> configures the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> install a runonly distribution into Starlink tree
 !      jars             -> creates the package jar file
 !      javadocs         -> creates the API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      build-lineids    -> create the distributable line identifier jar file
 !      build-native     -> builds native library for current platform
 !      test             -> run up SPLAT from local build
 !
 !   Authors:
 !      Peter W. Draper (26-JUL-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for SPLAT" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar and shareable library tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!-- Web proxy configuration, you will usually override these in
   !   ~/.stardev.properties or .properties -->
  <property name="http.proxyPort" value="8080"/>
  <property name="http.proxyHost" value=""/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="SPLAT-VO"/>
  <property name="name" value="splat"/>
  <property name="version" value="3.10-0"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.splat"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.5"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="yes"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directory for miscellaneous files -->
  <property name="src.etc" value="${src.dir}/etc"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico,**/JavaHelpSearch/*"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>
  <property name="build.jni" value="${build.dir}/jni"/>
  <property name="build.lib" location="${build.dir}/lib"/>
  <property name="build.examples" value="${build.classes}/examples"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Architecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>
  <property name="src.lib.arch" value="${src.jars.dir}/${os.arch}"/>
  <property name="build.lib.arch" value="${build.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase"
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!-- Non-standard source file directories -->
  <property name="stardev" value="/star"/>

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <path id="installed.classpath">

    <!-- JNIAST -->
    <pathelement location="${star.jar.dir}/jniast/jniast.jar"/>

    <!-- NDArray-->
    <pathelement location="${star.jar.dir}/array/array.jar"/>

    <!-- DIVA -->
    <pathelement location="${star.jar.dir}/diva/diva.jar"/>

    <!-- HDX -->
    <pathelement location="${star.jar.dir}/hdx/hdx.jar"/>

    <!-- SOAPSERVER -->
    <pathelement location="${star.jar.dir}/soapserver/soapserver.jar"/>

    <!-- PAL -->
    <pathelement location="${star.jar.dir}/pal/pal.jar"/>

    <!-- ASTGUI -->
    <pathelement location="${star.jar.dir}/astgui/astgui.jar"/>

    <!-- TABLE -->
    <pathelement location="${star.jar.dir}/table/table.jar"/>

    <!-- VOTable -->
    <pathelement location="${star.jar.dir}/votable/votable.jar"/>

    <!-- VO -->
    <pathelement location="${star.jar.dir}/vo/vo.jar"/>

    <!-- PLASTIC -->
    <pathelement location="${star.jar.dir}/plastic/plastic.jar"/>

    <!-- HDS -->
    <pathelement location="${star.jar.dir}/hds/hds.jar"/>

    <!-- DATANODE -->
    <pathelement location="${star.jar.dir}/datanode/datanode.jar"/>

    <!-- JSKY -->
    <pathelement location="${star.jar.dir}/jsky/jsky.jar"/>

    <!-- HELP -->
    <pathelement location="${star.jar.dir}/help/help.jar"/>

    <!-- UTIL -->
    <pathelement location="${star.jar.dir}/util/util.jar"/>

  </path>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <path id="built.jarpath">
    <pathelement location="${star.build.dir}/array/lib/array/array.jar"/>
    <pathelement location="${star.build.dir}/jniast/lib/jniast/jniast.jar"/>
    <pathelement location="${star.build.dir}/hdx/lib/hdx/hdx.jar"/>
    <pathelement location="${star.build.dir}/diva/lib/diva/diva.jar"/>
    <pathelement location="${star.build.dir}/soapserver/lib/soapserver/soapserver.jar"/>
    <pathelement location="${star.build.dir}/pal/lib/pal/pal.jar"/>
    <pathelement location="${star.build.dir}/astgui/lib/astgui/astgui.jar"/>
    <pathelement location="${star.build.dir}/table/lib/table/table.jar"/>
    <pathelement location="${star.build.dir}/votable/lib/votable/votable.jar"/>
    <pathelement location="${star.build.dir}/vo/lib/vo/vo.jar"/>
    <pathelement location="${star.build.dir}/plastic/lib/plastic/plastic.jar"/>
    <pathelement location="${star.build.dir}/util/lib/util/util.jar"/>
  </path>

  <!-- Local third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, so
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Local line identifiers -->
    <pathelement location="${build.dir}/ids"/>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property
   !   "extra.class.path" (which can be defined locally using say
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
    <path refid="local.classpath"/>
    <path refid="built.classpath"/>
    <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath -->
  <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!-- Locate the JNI libraries for this platform. -->
  <path id="jni-ldpath.id">
    <pathelement path="${java.library.path}"/>
    <pathelement path="${dist.lib.arch}"/>
    <pathelement path="${star.jar.dir}/${os.arch}"/>
    <pathelement path="${star.build.dir}/jniast/lib/${os.arch}"/>
    <pathelement path="${star.build.dir}/jnihds/lib/${os.arch}"/>
  </path>
  <property name="jni-ldpath" refid="jni-ldpath.id"/>

  <!--
   !    ===========================================
   !    Check availability of optional dependencies
   !    ===========================================
   !
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>
  </target>


  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>

  <!--
  !   ==============
  !   Build the code
  !   ==============
  !
  !  The results of the compilation are placed in the build.classes
  !  directory. Other files that are also needed in the classes tree
  !  (i.e. resources like images) should also be copied into place here.
  !-->
  <target name="build"
          depends="prepare, check_packages, build_examples, unpack_jni"
          unless="runonly.install"
          description="-> compiles the source code">

    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           optimize="${optimize}"
           source="${source.version}">

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

      <!-- Exclude any Java files in the source tree that should not be
       !   compiled -->
      <exclude name="**/retired_code/*"/>
      <exclude name="**/*Test*"/>
      <exclude name="**/ExtractNDFWCS2XML.java"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/deploy.wsdd"/>
        <include name="**/*.xml"/>
        <include name="**/images/**"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}" includes="*">
        <and>
          <type type="file"/>
        </and>
      </fileset>
    </copy>

    <!-- Update the version properties file. Keep copy in real source for
     !   reference, but do not copy that into place. -->
    <echo file="${java.dir}/uk/ac/starlink/splat/util/splat.version"
          message="version=${version}${line.separator}"/>
    <mkdir dir="${build.classes}"/>
    <echo file="${build.classes}/uk/ac/starlink/splat/util/splat.version"
          message="version=${version}${line.separator}"/>


    <!-- Update the line identifier database. -->
    <uptodate property="lineids.notrequired"
              targetfile="${dist.lib.pkg}/splat_lines.jar">
      <srcfiles dir="${src.etc}/ids"/>
    </uptodate>
    <antcall target="build-lineids"/>
  </target>

  <!--
   !   =======================
   !   Create line id jar file
   !   =======================
   !
   !  Creates the jar file that contains the line identifiers. This
   !  is required when new files are added to the database.
   !-->
  <target name="build-lineids"
          unless="lineids.notrequired"
          description="-> create the distributable line identifier jar file" >

    <!-- Make the mirror tree with the pre-processed spectra, note
     !   requires JNIAST to be available for the current platform, so
     !   we set the LD_LIBRARY_PATH. Fail if doesn't work, don't want
     !   a corrupt jar file. -->
    <java classname="uk.ac.starlink.splat.util.LineIDTree" failonerror="true" fork="true">
      <classpath refid="classpath"/>
      <sysproperty key="java.library.path" value="${jni-ldpath}"/>
      <arg value="${src.etc}/ids"/>
      <arg value="${build.dir}/ids/ids"/>
      <jvmarg value="-Djava.awt.headless=true"/>
    </java>

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/splat_lines.jar"
         basedir="${build.dir}/ids"/>

  </target>

  <!--
   !   =============================
   !   Copy example data into place.
   !   =============================
   !-->
  <target name="build_examples">

    <mkdir dir="${build.examples}"/>
    <copy todir="${build.examples}">
      <fileset dir="${src.etc}/examples" includes="*">
        <and>
          <type type="file"/>
        </and>
      </fileset>
    </copy>

  </target>

  <!-- Pulls the architecture-specific shared libraries out of the source
   !   jar files in which they live.  These jar files are in the CVS
   !   repository, they are not built as part of the normal build target.
   !   The one specific to the build-time architecture can be built
   !   using the 'build-native' target, but this requires more than the
   !   basic CVS files to work (e.g. it needs the stardev classic libraries).
   !-->
  <target name="unpack_jni" unless="unpack.skip">
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="i386"/>
    </antcall>
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="sparc"/>
    </antcall>
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="x86"/>
    </antcall>
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="ppc"/>
    </antcall>
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="amd64"/>
    </antcall>
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="x86_64"/>
    </antcall>
  </target>

  <!-- Architecture-specific JNI jar file unpacker, skips if jar file
   !   missing -->
  <target name="unpack_jni_arch">
    <unjar dest="${dist.lib}/${unpack.arch}">
      <fileset file="${src.jars.dir}/${unpack.arch}/${name}_libs.jar"/>
      <patternset excludes="META-INF*/*"/>
    </unjar>
  </target>


  <!--
   !  ============================================
   !  Build the native shared library from sources
   !  ============================================
   !
   !  This does the actual build of the shared library for the build-time
   !  architecture, and requires a stardev installation.  It is not a
   !  dependency of any of the other public targets, and should not be
   !  invoked as part of the normal build process.  It should be invoked
   !  periodically (when NDF or the local C source change), once on each
   !  of the supported platforms, and the resulting new 'source' files
   !  (shared library jar files) checked in.
   !
   !  Note the build will not be attempted if the stardev property is not set.
   !-->
  <target name="build-native"
          description="-> builds native library">

    <!-- Extract the existing libraries from the jar file. There may
     !   be more than one library per architecture (i386 Linux and OS X)
     !   and we want to keep the other libraries. The datestamps should
     !   be in the past otherwise this will fail
     !-->
    <unjar dest="${build.lib.arch}">
      <fileset file="${src.lib.arch}/${name}_libs.jar"/>
    </unjar>

    <!-- Build the library -->
    <antcall target="execute_mk_script">
      <param name="mk.action" value="build"/>
    </antcall>

    <!-- Jar it up and copy it into the source tree ready for CVS checkin -->
    <jar destfile="${src.lib.arch}/${name}_libs.jar"
         basedir="${build.lib.arch}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
      </manifest>
    </jar>
  </target>

  <!--
   !  ===================================
   !  Execute shareable library MK script
   !  ===================================
   !
   !  Execute the "mk" script that creates the package shareable
   !  library. The action performed is controlled by the "mk.action"
   !  property that should be defined before an antcall to this
   !  target.
   !-->
  <target name="execute_mk_script">

    <!-- Before proceeding use a simple test to estimate if this
     !   may succeed. A failure isn't critical as SPLAT can use
     !   NDX support (available via JNIHDS) to access NDFs.
     !-->
     <available file="${stardev}/bin/ndf_link" type="file"
                property="stardev.exists"/>

     <!-- Only one of these executes, depending on whether "stardev.exists" is
      !   defined -->
     <antcall target="execute_mk_script_start"/>
     <antcall target="execute_mk_script_complete"/>
  </target>

  <target name="execute_mk_script_start" if="stardev.exists">

    <!-- Execute the given action for all known operating system types.
     !   This uses modified mk and makefiles from an old-style system
     !   which should be stored in ${src.jni.dir} along with the source
     !   code. Note some of these OS names seem to change from time to
     !   time and across JVMs, so beware. Clearly this is not portable.
     !-->

    <!-- Copy all source code into the build directory (keeps any
     !   intermediary files out of the source tree) -->
    <copy todir="${build.jni}">
      <fileset dir="${src.jni.dir}" includes="*"/>
    </copy>
    <chmod perm="ugo+rx" dir="${build.jni}" includes="*" maxparallel="50"/>

    <!-- Local and installed versions of any shareable libraries that we
     !   require to resolve against in a form for the UNIX "ld" command
     !-->
    <property name="jniast.share"
              value="-L${star.jar.dir}/${os.arch} -ljniast"/>
    <!-- OSX needs the full path, as JNI uses .jnilib not .dylib so -l fails-->
    <property name="jniast.share.osx"
              value="${star.jar.dir}/${os.arch}/libjniast.jnilib"/>

    <property name="java.shareables" value="${jniast.share}"/>
    <property name="java.shareables.osx" value="${jniast.share.osx}"/>

    <mkdir dir="${build.lib.arch}"/>

    <echo message="java.home=${java.home}"/>

    <!-- Note: these are selected by the "os" argument, which matches
     !   the current JVM value, so only one is actually executed. -->
    <exec dir="${build.jni}" executable="${build.jni}/mk" os="Linux">
      <env key="SYSTEM" value="ix86_Linux"/>
      <env key="STARLINK" value="${stardev}"/>
      <env key="JAVA_SYSTEM" value="linux"/>
      <env key="JAVA_HOME" value="${java.home}/.."/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${build.lib.arch}"/>
      <arg line="${mk.action}"/>
    </exec>

    <exec dir="${build.jni}" executable="${build.jni}/mk" os="SunOS">
      <env key="SYSTEM" value="sun4_Solaris"/>
      <env key="STARLINK" value="${stardev}"/>
      <env key="JAVA_SYSTEM" value="${os.arch}"/>
      <env key="JAVA_HOME" value="${java.home}/.."/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${build.lib.arch}"/>
      <arg line="${mk.action}"/>
    </exec>

    <exec dir="${build.jni}" executable="${build.jni}/mk" os="OSF1">
      <env key="SYSTEM" value="alpha_OSF1"/>
      <env key="STARLINK" value="${stardev}"/>
      <env key="JAVA_SYSTEM" value="alpha"/>
      <env key="JAVA_HOME" value="${java.home}/.."/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${build.lib.arch}"/>
      <arg line="${mk.action}"/>
    </exec>

    <exec dir="${build.jni}" executable="${build.jni}/mk" os="Mac OS X">
      <env key="SYSTEM" value="MacOSX"/>
      <env key="STARLINK" value="${stardev}"/>
      <env key="JAVA_SYSTEM" value="${os.arch}"/>
      <env key="JAVA_HOME" value="${java.home}/.."/>
      <env key="JAVA_SHAREABLES" value="${java.shareables.osx}"/>
      <env key="TARGET_LIB" value="${build.lib.arch}"/>
      <env key="STARJAVA_LIB" value="${star.install}/lib/${os.arch}"/>
      <arg line="${mk.action}"/>
    </exec>

  </target>

  <!-- Inverse of above, use to report that execute_mk_script_real has not
       been invoked, as stardev.exists is not set-->
  <target name="execute_mk_script_complete" unless="stardev.exists">
     <echo>
JNI libraries not built (NDF library not installed in ${stardev})"
     </echo>
  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs) on and, if
   !  appropriate, defines the application entrance point. The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Main-Class"
                   value="uk.ac.starlink.splat.SplatMain"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Architecture dependent jar files (shareable libraries for
     !   webstart) -->
    <copy todir="${dist.lib}">
       <fileset dir="${src.jars.dir}" includes="**/*.jar **/*.zip"/>
    </copy>

    <jar destfile="${dist.lib.pkg}/${name}_examples.jar"
         basedir="${build.examples}"/>

    <!-- Sign all jar files -->
    <antcall target="signjar"/>

  </target>

  <!-- Local target so it can be skipped when "skip.sign.jar" is set -->
  <target name="signjar"
          description="sign all jar files"
          unless="sign.jar.skip">

    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             maxmemory="128m"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
    </signjar>

  </target>


  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>Starlink SPLAT-VO - A Spectral Analysis Tool</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon kind="splash" href="splat_splash.gif"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>Starlink SPLAT-VO - Webstart edition</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="splat/splat.jar" main="true"/>
         <extension name="SPLAT-PARTS" href="splat-parts.jnlp"/>
         <extension name="JSKY-PARTS" href="jsky-parts.jnlp"/>
       </resources>
       <application_desc main_class="uk.ac.starlink.splat.SplatMain"/>
     </jnlp>

     <!-- May be needed as a component so provide that too -->
     <jnlp toFile="${dist.lib}/${name}-parts.jnlp" href="${name}-parts.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>Starlink SPLAT-VO - A Spectral Analysis Tool</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon kind="splash" href="splat_splash.gif"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink SPLAT-VO - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <fileset dir="${dist.lib}" includes="splat/*.jar splat/*.zip"/>
         <extension name="DATANODE" href="datanode.jnlp"/>
         <extension name="ASTGUI" href="astgui.jnlp"/>
         <extension name="NDX" href="ndx.jnlp"/>
         <extension name="JNIAST" href="jniast.jnlp"/>
         <extension name="SOAPSERVER" href="soapserver.jnlp"/>
         <extension name="FITS" href="fits.jnlp"/>
         <extension name="HDS" href="hds.jnlp"/>
         <extension name="PAL" href="pal.jnlp"/>
         <extension name="DIVA" href="diva.jnlp"/>
         <extension name="HELP" href="help.jnlp"/>
         <extension name="TABLE" href="table.jnlp"/>
         <extension name="VO" href="vo.jnlp"/>
         <extension name="PLASTIC" href="plastic.jnlp"/>
         <extension name="JSAMP" href="jsamp.jnlp"/>
       </resources>

       <!-- Do not enable this until webstart supports the loading
            of dependent libraries (JNIAST). 23/11/06 they are no
            workarounds (I've tried them all), so don't waste time
            on this. The bug to be fixed is:

            http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4491398
       -->

       <!-- Linux >
       <resources os="Linux" arch="i386">
         <nativelib href="i386/${name}_libs.jar"/>
       </resources>
       <resources os="Linux" arch="amd64">
         <nativelib href="amd64/${name}_libs.jar"/>
       </resources-->

       <!-- IBM Linux >
       <resources os="Linux" arch="x86">
         <nativelib href="i386/${name}_libs.jar"/>
       </resources-->

       <!-- Windows >
       <resources os="Windows">
          <nativelib href="x86/${name}_libs.jar"/>
       </resources-->

       <!-- SUN Solaris >
       <resources os="SunOS" arch="sparc">
         <nativelib href="sparc/${name}_libs.jar"/>
       </resources>
       <resources os="SunOS" arch="x86">
         <nativelib href="x86/${name}_libs.jar"/>
       </resources-->

       <!-- Mac OS X >
       <resources os="Mac OS X" arch="ppc">
         <nativelib href="ppc/${name}_libs.jar"/>
       </resources>
       <resources os="Mac OS X" arch="i386">
         <nativelib href="i386/${name}_libs.jar"/>
       </resources>
       <resources os="Mac OS X" arch="x86_64">
         <nativelib href="x86_64/${name}_libs.jar"/>
       </resources>
       <resources os="Mac OS X" arch="ppc64">
         <nativelib href="ppc64/${name}_libs.jar"/>
       </resources-->

       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin.pkg}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.lib.arch}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <mkdir dir="${dist.etc.pkg}"/>

    <!-- Copy any startup scripts etc. -->
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}">
        <include name="*"/>
        <include name=".splat_autoloads"/>
        <and>
          <type type="file"/>
        </and>
      </fileset>
    </copy>

    <!-- Copy auxiliary files. -->
    <copy todir="${dist.etc.pkg}">
      <fileset dir="${src.etc}"/>
    </copy>

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>

    <!-- Unpack the SPLAT SUN in hypertext format ${dist.docs} level to be
     !   picked up by findme/showme. -->
    <untar src="${src.docs}/sun243.htx_tar.gz" dest="${dist.docs}"
           compression="gzip" overwrite="true"/>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}" maxparallel="50"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}" maxparallel="50"/>
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}"
           maxparallel="50">
       <fileset dir="${dist.bin}"/>
    </chmod>
    <chmod perm="ugo+rx" dir="${dist.lib}" type="file" includes="libsplat*"
           failonerror="${chmod.fail}" maxparallel="50"/>
  </target>


  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>
    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>

    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin.pkg}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.etc.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>
    <mkdir dir="${star.lib.arch}"/>

    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.bin.pkg}
</echo>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
        <include name="**/libsplat.*"/>
      </fileset>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}" filtering="true"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

    <loggedcopy todir="${star.etc}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.etc}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.etc.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.lib.arch}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <mkdir dir="${dist.etc.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  The documentation is created from the Java sources. Should also
   !  extend this to include the possibility of other miscellaneous
   !  documentation (FAQs etc.).
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             source="${source.version}"
             classpathref="classpath">

      <doclet name="com.sun.tools.doclets.standard.Standard">
        <param name="-breakiterator"/>
      </doclet>

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
         <exclude name="**/retired_code"/>
         <exclude name="**/*Test*"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">
    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>
  </target>

  <!--
   !   ==========================================
   !   Creates the API documentation java sources
   !   ==========================================
   !
   !  Just copies the sources into the correct place.
   !-->
    <target name="javadoc-sources"
          description="-> make source files for release API documentation">
     <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->

    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
        <include name="**/*.java"/>
        <exclude name="**/retired_code/*"/>
        <exclude name="**/*Test*"/>
        <exclude name="**/ExtractNDFWCS2XML.java"/>
        <exclude name="**/FITS.java"/>
        <exclude name="**/*Holder.java"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   ! Note these are not JUnit based
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">
    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           deprecation="${deprecation}" >
      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="tests-classpath"/>
    </javac>
  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests">
  </target>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}"
           forkmode="once">

      <classpath refid="tests-classpath"/>

      <!-- Need to pick up local JNIAST, which might be installed or on the
       !   library path, note that java.library.path cannot be changed inside
       !   a JVM, so we have to fork and pass this from the environment.
       !   Set LD_LIBRARY_PATH and DYLD_LIBRARY_PATH as they are the only two
       !   ways that we support and are required for this to work (think
       !   this is because libsplat.so depends on libjniast.so and the JVM
       !   doesn't handle the loading of additional references). -->
      <!--sysproperty key="java.library.path" value="${jni-ldpath}"/-->
      <env key="LD_LIBRARY_PATH" value="${jni-ldpath}"/>
      <env key="DYLD_LIBRARY_PATH" value="{$jni-ldpath}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="plain" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <!-- Compile all code and run up the UI -->
  <target name="fullui"
          depends="compile-tests">
    <antcall target="debugui"/>
  </target>

  <!-- RUN up UI without compilation dependency (for testing/inspecting
   !   when coding not complete). -->
  <target name="debugui">

    <!-- Run up SPLAT from the local build, enable for remote JPDA debugging-->
    <java classname="uk.ac.starlink.splat.SplatMain" fork="true">
      <classpath refid="tests-classpath"/>
      <sysproperty key="http.proxyHost" value="${http.proxyHost}"/>
      <sysproperty key="http.proxyPort" value="${http.proxyPort}"/>
      <jvmarg value="-mx1024m"/>
      <jvmarg value="-Xdebug"/>
      <jvmarg value="-Xnoagent"/>
      <!--jvmarg value="-Xrunhprof:cpu=samples,file=profile.log"/-->
      <jvmarg value="-Djava.compiler=NONE"/>
      <jvmarg value="-Dsplat.development=${splat.development}"/>
      <jvmarg value="-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=7000"/>
      <jvmarg value="-Dsplat.etc=${src.etc}"/>
      <arg value="src/etc/testdata/NGC1275.txt"/>
    </java>
  </target>

  <!-- RUN up UI without compilation dependency and without remote
   !   debugging support -->
  <target name="plainui">

    <java classname="uk.ac.starlink.splat.SplatMain" fork="true">
      <classpath refid="tests-classpath"/>
      <sysproperty key="http.proxyHost" value="${http.proxyHost}"/>
      <sysproperty key="http.proxyPort" value="${http.proxyPort}"/>
      <jvmarg value="-Dsplat.development=${splat.development}"/>
      <jvmarg value="-Daxis.EngineConfigFactory=uk.ac.starlink.soap.AppEngineConfigurationFactory"/>
      <jvmarg value="-Daxis.ServerFactory=uk.ac.starlink.soap.AppAxisServerFactory"/>
      <arg value="src/etc/testdata/ramp.txt"/>
    </java>
  </target>

  <!-- Execute a given class with up to two arguments -->
  <property name="runclass" value="uk.ac.starlink.splat.SplatMain"/>
  <property name="runclass.args1" value=""/>
  <property name="runclass.args2" value=""/>
  <target name="runclass"
          depends="compile-tests">

    <java classname="${runclass}" fork="true">
      <classpath refid="tests-classpath"/>
      <sysproperty key="http.proxyHost" value="${http.proxyHost}"/>
      <sysproperty key="http.proxyPort" value="${http.proxyPort}"/>
      <arg value="${runclass.args1}"/>
      <arg value="${runclass.args2}"/>
    </java>
  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>


  <!--
   !   ==========================
   !   Build standalone jar files
   !   ==========================
   !
   !  Builds jar files which can be used on their own, without needing any
   !  other jars to be present, however, SPLAT will not work in this mode and
   !  requires the shareable libraries of JNIAST and JNIHDS.
   !-->
  <target name="build-standalone"
          description="-> builds a standalone jar file">

    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>

    <java classname="uk.ac.starlink.util.SuperJar" failonerror="yes">
      <classpath refid="classpath"/>
      <arg value="-o"/><arg value="${dist.lib.pkg}/splat-full.jar"/>
      <arg value="-x"/><arg value="srb.jar"/>
      <arg value="${star.lib.pkg}/splat.jar"/>
    </java>
    <jar destfile="${dist.lib.pkg}/splat-full.jar"
         update="yes"
         basedir="${star.bin}"
         includes="splat"/>

    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib.pkg}"
               includes="splat-full.jar"/>
    </signjar>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   SRB build file
 !
 !   This file describes how to build and install SRB from
 !   source and binary releases. SRB is a class library
 !   (i.e. provides an API and related documentation).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for SRB" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="SRB"/>
  <property name="name" value="srb"/>
  <property name="version" value="0.1"/>

  <!-- The Java package name -->
  <property name="package.name" value="{package.path}"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.4"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Any achitecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase"
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Installed jar files.
   !
   !   Name all the installed jar files of other packages that we depend on.
   !
   !   When compiling under Java 1.4 these will be used to produce a full
   !   classpath that is equivalent to that generated when these are
   !   referenced as optional bundled packages by the JVM.
   !   When compiling under Java 1.5 (and probably later) this is just
   !   a simple path of these jar files, as the expansion to a full optional
   !   bundled package classpath is performed by the compiler
   !
   !   What that all means is that the manifest classpaths of these jar files
   !   are honoured, the plain compiler pre Java 1.5 didn't do that. When Java
   !   1.4 is no longer used the extclasspath type can be replaced by a simple
   !   path.
   !-->
  <extclasspath id="installed.classpath">

    <!-- UTIL -->
    <pathelement location="${star.jar.dir}/util/util.jar"/>

    <!-- CONNECT -->
    <pathelement location="${star.jar.dir}/connect/connect.jar"/>

  </extclasspath>

  <!-- Local build system jar files.
   !
   !   Name all the jar files of other packages that we depend on, which have
   !   not been installed (should be same packages as in installed.classpath).
   !-->
  <extclasspath id="built.jarpath">

    <pathelement
       location="${star.build.dir}/util/lib/utuil/util.jar"/>
    <pathelement
       location="${star.build.dir}/connect/lib/connect/{package2.jar}"/>

  </extclasspath>

  <!-- Find all local third party jars files.
   !
   !   Normally these will be kept in their own third party package, but may
   !   be kept here temporarily, say if there are version conflicts that
   !   cannot be addressed. They are installed with the package jar files and
   !   should be entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  </path>

  <!-- Create the local build system CLASSPATH.
   !
   !   Create the classpath used when building this package as part of a full
   !   build system without any dependency on any installed or external jar
   !   files.
   !
   !   Classes compiled in the local build tree will be in the "build/classes"
   !   part of each package. Third party packages, have do not have any source
   !   code, just jar files, will have their jar files in their "dist"
   !   directories (usually lib/{package_name}).
   !
   !   So the full built classpath is created by constructing a path
   !   consisting of:
   !
   !      - all third party jar files in this package
   !      - all build/classes directories in the local build system (these
   !        will have the most recent class files)
   !      - all jar files named in built.jarpath, i.e. named local build
   !        system jar files (these can be normal packages in the "dist" state
   !        or third party packages)
   !      - all jar files in the "dist" directories of all packages in the
   !        local build system (these are necessary to make sure that the jar
   !        files in the previous part have their dependencies fulfilled,
   !        without having them all installed)
   !-->
  <path id="built.classpath">

    <!-- Third party jars held by this package -->
    <path refid="package.jars"/>

    <!-- All classes in the local build system -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent jars in the local build system -->
    <path refid="built.jarpath"/>

    <!-- All "dist" jar files to make sure everything is resolved, including
     !   relative URLs of the local packages, without installation -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

  </path>

  <!-- User-defined CLASSPATH.
   !
   !   This is set by the property "extra.class.path" (which can be defined
   !   locally using say -Dextra.class.path=$CLASSPATH on the command line
   !   or by setting the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Create the full CLASSPATH used during compilation.
   !
   !   This is created from the user-defined classpath, followed by the
   !   classpath for building against the local system, followed by the
   !   classpath for building against an installed system.
   !-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- Create the JUnit tests CLASSPATH.
   ! 
   !   Note that in addition to the build/classes and build/tests directory
   !   we also add tests.dir and tests.etc.dir so that resources may be
   !   located there. The full classpath is also used.
   !-->  
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    ============
   !    Library path
   !    ============
   !    Used by test targets for locating native libraries.
   !-->
  <path id="tests-libpath.id">
    <pathelement path="${java.library.path}"/>
    <pathelement location="${star.jar.dir}/${os.arch}"/>
  </path>
  <property name="tests-libpath" refid="tests-libpath.id"/>

  <!--
   !    ===============
   !    Extension tasks
   !    ===============
   !    Add any local or extension ANT tasks that are required. Local
   !    tasks should be moved into the ANT package if used outside of this
   !    package. 
   !-->
  <taskdef resource="axis-tasks.properties" classpathref="classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !
   !    Minimalist check of the required dependencies so that the build will
   !    not proceed if some basic dependencies are not present on the
   !    classpath. Optional components could also be checked here.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!-- UTIL -->
    <available property="util.present"
               classpathref="classpath"
               classname="uk.ac.starlink.util.DataSource"/>
    <fail message="No UTIL available" unless="util.present"/>

    <!-- CONNECT -->
    <available property="connect.present"
               classpathref="classpath"
               classname="uk.ac.starlink.connect.Connector"/>
    <fail message="No CONNECT available" unless="connect.present"/>

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <classpath refid="classpath"/>
      <compilerarg value="-proc:none" compiler="javac1.6"/>

      <include name="**/*.java"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/*.gif"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib}" includes="**/*.jar"/>
    </signjar>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this class library.
     !   This goes into "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">

      <information>
         <title>SRB - Classes for access to Storage Resource Broker filespace</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink SRB - Webstart edition"</description>
         <offline_allowed/>
       </information>

       <security>
          <all_permissions/>
       </security>

       <resources>
         <j2se version="1.5+"/>

         <!-- Define the main library jar file -->
         <jar href="${name}/${name}.jar"/>
         <jar href="${name}/jargon.jar"/>

         <!-- Name any extension packages we directly depend on -->
         <extension name="UTIL" href="util.jnlp"/>
         <extension name="CONNECT" href="connect.jnlp"/>
       </resources>

       <!-- This is a component -->
       <component_desc/>

     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <!-- <mkdir dir="${dist.bin.pkg}"/> -->
    <mkdir dir="${dist.lib.pkg}"/> 
    <mkdir dir="${dist.docs.pkg}"/>
    <!-- <mkdir dir="${dist.etc.pkg}"/> -->

    <!-- Copy any configuration/helper scripts etc. -->
 <!--
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>
  -->

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
 <!--
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>
 -->

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
    <!-- <mkdir dir="${star.bin.pkg}"/> -->
    <mkdir dir="${star.lib.pkg}"/>
    <!-- <mkdir dir="${star.etc.pkg}"/> -->
    <mkdir dir="${star.docs.pkg}"/>

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
 <!--
    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>
 -->

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory-->
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

    <!-- Make sure that the expected file structure exists, some
         of these files can be missing if originally empty -->
    <mkdir dir="${dist.dir}"/>
    <!-- <mkdir dir="${dist.bin.pkg}"/> -->
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <!-- <mkdir dir="${dist.etc.pkg}"/> -->

    <!-- Do normal install, but with many targets switched off-->
    <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
        <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">
<!--

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <classpath refid="tests-classpath"/>

    </javac>
-->

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

<!--
    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/JUnit*"/>
        </fileset>
      </batchtest>

    </junit>
-->

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   STARTASK build file
 !
 !   This file describes how to build and install STARTASK from
 !   source and binary releases. STARTASK is a class library
 !   (i.e. provides an API and related documentation).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for STARTASK" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/starjava)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/starjava)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="StarTask"/>
  <property name="name" value="startask"/>
  <property name="version" value="0.1"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.${name}"/>
  <property name="package.path" value="uk/ac/starlink/${name}"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.4"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any auxiliary files for the package-->
  <property name="src.etc.dir" value="${src.dir}/etc"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Any achitecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- {Other packages} -->
    <pathelement location="${star.jar.dir}/xercesImpl.jar"/>
    <pathelement location="${star.jar.dir}/xml-apis.jar"/>
    <pathelement location="${star.jar.dir}/axis/*.jar"/>
    <pathelement location="${star.jar.dir}/jini/*.jar"/>

    <!-- {More packages} -->
  </extclasspath>
  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">

    <fileset dir="${star.jar.dir}">
       <include name="axis/*.jar"/>
    </fileset>
    <pathelement 
       location="${star.build.dir}/{package2}/lib/{package2}/{package2.jar}"/>

    <!-- {More packages} -->
  </extclasspath>

  <!-- "Local" third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, say
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest. -->
  <path id="package.jars">
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>
    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property
   !   "extra.class.path" (which can be defined locally using say
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath, add tests.dir and tests.etc.dir so that
   !   resources may be located there -->
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    ============
   !    Library path
   !    ============
   !    Used by test targets for locating native libraries.
   !-->
  <path id="tests-libpath.id">
    <pathelement path="${java.library.path}"/>
    <pathelement location="${star.jar.dir}/${os.arch}"/>
  </path>
  <property name="tests-libpath" refid="tests-libpath.id"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!--  {Example package1}
    <available property="{package1}.present"
               classpathref="classpath"
               classname="uk.ac.starlink.{package1}.{MainClass}"/>

    <fail message="No {package1} available" unless="{package1}.present"/>
    -->

    <!-- {More critical dependencies} -->

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time 
     !   or installation directory -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
        <token key="INSTALL_DIR" value="${star.install}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here. 
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <classpath refid="classpath"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
      <exclude name="**/{Retired1.java}"/>
      <exclude name="**/{Retired2.java}"/>
      <exclude name="**/*.html"/>
      <exclude name="**/*.properties*"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="${package.path}/support/*"/>
        <exclude name="${package.path}/support/*.bck"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>
  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path"
            value="${jar.class.path}"/>
      </manifest>
    </jar>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin.pkg}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <mkdir dir="${dist.etc.pkg}"/>

    <!-- Copy any configuration/helper scripts etc. -->
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>

    <!-- Copy any auxiliary/configuration files etc. -->
    <copy todir="${dist.etc.pkg}">
      <fileset dir="${src.etc.dir}/" />
    </copy>

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>
 -->
    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
<!-- <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>
 -->
  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin.pkg}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.etc.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
    <loggedcopy todir="${star.bin}"
                filtering="true"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <loggedcopy todir="${star.etc}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.etc}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}">
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
${star.bin.pkg}
${star.etc.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory-->
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <mkdir dir="${dist.etc.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath"
             additionalparam="-breakiterator">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

  <!-- There are currently no tests. -->
  <!--
    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <classpath refid="tests-classpath"/>

    </javac>
  !-->

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

 <!-- There are currently no tests. -->
 <!--
    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/JUnit*"/>
        </fileset>
      </batchtest>

    </junit>
  !-->

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   Table build file
 !
 !   This file describes how to build and install Table from
 !   source and binary releases. Table is a class library
 !   (i.e. provides an API and related documentation).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for Table" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="Table"/>
  <property name="name" value="table"/>
  <property name="version" value="3.0-5"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.table"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.5"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>
  <property name="build.docs" value="${build.dir}/docs"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Any achitecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
           value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- UTIL -->
    <pathelement location="${star.jar.dir}/util/util.jar"/>

  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">
    <pathelement location="${star.build.dir}/util/lib/util/util.jar"/>
  </extclasspath>

  <!-- "Local" third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, say
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property
   !   "extra.class.path" (which can be defined locally using say
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath, add tests.dir and tests.etc.dir so that
   !   resources may be located there -->
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!-- Need Util -->
    <available property="util.present"
               classpathref="classpath"
               classname="uk.ac.starlink.util.DataSource"/>
    <fail message="No Util available" unless="util.present"/>

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here. 
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
      <exclude name="**/{Retired1.java}"/>
      <exclude name="**/{Retired2.java}"/>
      <exclude name="**/*.html"/>
      <exclude name="**/*.properties*"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${src.dir}/resources"/>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}">
          <include name="*.jar"/>
       </fileset>
    </copy>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib}" includes="**/*.jar"/>
    </signjar>
  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
     <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
           codebase="${webstart.codebase}">
      <information>
         <title>TABLE - table data access classes</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink TABLE - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
         <extension name="UTIL" href="util.jnlp"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.bin.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Copy application scripts. -->
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/"/>
    </copy>

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
    <!--
      <copy todir="${dist.docs.pkg}">
        <fileset dir="${src.docs}"/>
      </copy>
    -->

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <!--<zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>-->
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <!--<zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>-->

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <!--<tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>-->
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <!--<tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>-->

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory-->
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>


  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="src.dir" value="${src.dir}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="src.dir" value="${src.dir}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   TAMFITS build file
 !
 !   This file describes how to build the nom.tam.fits package 
 !   from a source release. It requires Apache ANT and a Java 
 !   Development Kit.
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> install a runonly distribution into Starlink tree
 !      jars             -> creates the package jar file
 !      javadocs         -> creates the API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> does nothing at present
 !
 !   Authors:
 !      Peter W. Draper (14-JUL-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for TAMFITS" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="TAMFITS"/>
  <property name="name" value="tamfits"/>
  <property name="version" value="0.96a"/>

  <!-- The Java package name -->
  <property name="package.name" value="nom.tam"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://heasarc.gsfc.nasa.gov/docs/heasarc/fits/java/v0.9/"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that 
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may 
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed). 
   !-->
  <extclasspath id="installed.classpath">

     <!-- Depends on nothing -->

  </extclasspath>
  
  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">

     <!-- Depends on nothing -->

  </extclasspath>

  <!-- Local third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, so
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <!-- <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>-->
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->
  
  </path>

  <!-- Extra user-defined classpath. This is set by the property 
   !   "extra.class.path" (which can be defined locally using say 
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>
  
  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
    <path refid="local.classpath"/>
    <path refid="built.classpath"/>
    <path refid="installed.classpath"/>
  </path>
    
  <!-- JUnit tests classpath -->
  <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>
  
  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages" 
          unless="runonly.install">

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>


  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>
  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images) should also be copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           optimize="${optimize}">

      <classpath refid="classpath"/>

      <!-- Exclude any Java files in the source tree that should not be
       !   compiled -->
      <exclude name="**/*_old.java"/>

    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <!-- <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/deploy.wsdd"/>
        <include name="**/images/**"/>
      </fileset>
    </copy>-->

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <!-- <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>-->

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs) on and, if
   !  appropriate, defines the application entrance point. The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
    </jar>

    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>TAMFITS - Java FITS access</title>
         <vendor>Tom McGlynn</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"TAMFITS - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="${name}/${name}.jar"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <!--<mkdir dir="${dist.bin.pkg}"/>-->
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <!--<mkdir dir="${dist.etc.pkg}"/>-->

    <!-- Copy any startup scripts etc. -->
    <!--<copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>-->

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
    <!--<chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>-->

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution 
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <!--<zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>-->
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <!--<zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>-->

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <!--<tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>-->
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <!--<tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>-->

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>
    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz" 
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2" 
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <!--<delete dir="${dist.bin}"/>-->
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <!--<delete dir="${dist.etc}"/>-->

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   !  and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <!--<mkdir dir="${star.bin.pkg}"/>-->
    <mkdir dir="${star.lib.pkg}"/>
    <!--<mkdir dir="${star.etc.pkg}"/>-->
    <mkdir dir="${star.docs.pkg}"/>

    <!--<loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>-->

    <!--<chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>-->

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory. 
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <!--<mkdir dir="${dist.bin.pkg}"/>-->
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <!--<mkdir dir="${dist.etc.pkg}"/>-->

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall" 
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  The documentation is created from the Java sources. Should also
   !  extend this to include the possibility of other miscellaneous
   !  documentation (FAQs etc.).
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">
    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>
  </target>

  <!--
   !   ==========================================
   !   Creates the API documentation java sources
   !   ==========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   ! 
   !  Application packages should only make public those parts of
   !  their internal APIs that they are prepared to support. Consider
   !  adding such code to proper class libraries (such as util).
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/*_old.java"/>
      </fileset>
    </copy>
  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   ! Note these are not JUnit based
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">
    <mkdir dir="${build.tests}"/>
    
    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           deprecation="${deprecation}" >
      <classpath refid="tests-classpath"/>
    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          description="-> does nothing"/>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   Task build file
 !
 !   This file describes how to build and install Task from
 !   source and binary releases. Task is a class library
 !   (i.e. provides an API and related documentation).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for Task" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="Task"/>
  <property name="name" value="task"/>
  <property name="version" value="0.2"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.task"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.5"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">

  </extclasspath>

  <!-- "Local" third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, say
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
<!--
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
-->
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property
   !   "extra.class.path" (which can be defined locally using say
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath, add tests.dir and tests.etc.dir so that
   !   resources may be located there -->
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here. 
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
      <exclude name="**/{Retired1.java}"/>
      <exclude name="**/{Retired2.java}"/>
      <exclude name="**/*.html"/>
      <exclude name="**/*.properties*"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/{package.support.files}"/>
        <include name="**/{more.package.support.files}"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
<!--
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>
-->

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value=""/>
      </manifest>
    </jar>

   
    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>

  </target>


  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>TASK</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink TASK - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="${name}/${name}.jar"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <!--<zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>-->
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <!--<zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>-->

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <!--<tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>-->
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <!--<tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>-->

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin.pkg}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.etc.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
<!--
    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>
-->

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory-->
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <mkdir dir="${dist.etc.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   {Package} build file
 !
 !   This file describes how to build and install {Package}
 !   from a source and binary release. {Package} is an application
 !   package, i.e. provides user-level commands and interfaces, as
 !   well as an optional programming API.
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for {Package}" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0.0.0.0.0.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="{PACKAGE}"/>
  <property name="name" value="{package}"/>
  <property name="version" value="1.0"/>

  <!-- The Java package name -->
  <property name="package.name" value="{package.path}"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.5"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase"
           value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Installed jar files.
   !
   !   Name all the installed jar files of other packages that we depend on.
   !
   !   When compiling under Java 1.4 these will be used to produce a full
   !   classpath that is equivalent to that generated when these are
   !   referenced as optional bundled packages by the JVM.
   !   When compiling under Java 1.5 (and probably later) this is just
   !   a simple path of these jar files, as the expansion to a full optional
   !   bundled package classpath is performed by the compiler
   !
   !   What that all means is that the manifest classpaths of these jar files
   !   are honoured, the plain compiler pre Java 1.5 didn't do that. When Java
   !   1.4 is no longer used the extclasspath type can be replaced by a simple
   !   path.
   !-->
  <extclasspath id="installed.classpath">

    <!-- {Other packages} -->
    <pathelement location="${star.jar.dir}/{package1}/{package1.jar}"/>
    <pathelement location="${star.jar.dir}/{package2}/{package2.jar}"/>

    <!-- {More packages} -->
  </extclasspath>

  <!-- Local build system jar files.
   !
   !   Name all the jar files of other packages that we depend on, which have
   !   not been installed (should be same packages as in installed.classpath).
   !-->
  <extclasspath id="built.jarpath">

    <pathelement
       location="${star.build.dir}/{package1}/lib/{package1}/{package1.jar}"/>
    <pathelement
       location="${star.build.dir}/{package2}/lib/{package2}/{package2.jar}"/>

    <!-- {More packages} -->
  </extclasspath>

  <!-- Find all local third party jars files.
   !
   !   Normally these will be kept in their own third party package, but may
   !   be kept here temporarily, say if there are version conflicts that
   !   cannot be addressed. They are installed with the package jar files and
   !   should be entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  </path>

  <!-- Create the local build system CLASSPATH.
   !
   !   Create the classpath used when building this package as part of a full
   !   build system without any dependency on any installed or external jar
   !   files.
   !
   !   Classes compiled in the local build tree will be in the "build/classes"
   !   part of each package. Third party packages, have do not have any source
   !   code, just jar files, will have their jar files in their "dist"
   !   directories (usually lib/{package_name}).
   !
   !   So the full built classpath is created by constructing a path
   !   consisting of:
   !
   !      - all third party jar files in this package
   !      - all build/classes directories in the local build system (these
   !        will have the most recent class files)
   !      - all jar files named in built.jarpath, i.e. named local build
   !        system jar files (these can be normal packages in the "dist" state
   !        or third party packages)
   !      - all jar files in the "dist" directories of all packages in the
   !        local build system (these are necessary to make sure that the jar
   !        files in the previous part have their dependencies fulfilled,
   !        without having them all installed)
   !-->
  <path id="built.classpath">

    <!-- Third party jars held by this package -->
    <path refid="package.jars"/>

    <!-- All classes in the local build system -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent jars in the local build system -->
    <path refid="built.jarpath"/>

    <!-- All "dist" jar files to make sure everything is resolved, including
     !   relative URLs of the local packages, without installation -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

  </path>

  <!-- User-defined CLASSPATH.
   !
   !   This is set by the property "extra.class.path" (which can be defined
   !   locally using say -Dextra.class.path=$CLASSPATH on the command line
   !   or by setting the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Create the full CLASSPATH used during compilation.
   !
   !   This is created from the user-defined classpath, followed by the
   !   classpath for building against the local system, followed by the
   !   classpath for building against an installed system.
   !-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- Create the JUnit tests CLASSPATH.
   !
   !   Note that in addition to the build/classes and build/tests directory
   !   we also add tests.dir and tests.etc.dir so that resources may be
   !   located there. The full classpath is also used.
   !-->
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    ============
   !    Library path
   !    ============
   !    Used by test targets for locating native libraries.
   !-->
  <path id="tests-libpath.id">
    <pathelement path="${java.library.path}"/>
    <pathelement location="${star.jar.dir}/${os.arch}"/>
  </path>
  <property name="tests-libpath" refid="tests-libpath.id"/>

  <!--
   !    ===============
   !    Extension tasks
   !    ===============
   !    Add any local or extension ANT tasks that are required. Local
   !    tasks should be moved into the ANT package if used outside of this
   !    package.
   !-->
  <taskdef resource="extra-tasks.properties" classpathref="classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !
   !    Minimalist check of the required dependencies so that the build will
   !    not proceed if some basic dependencies are not present on the
   !    classpath. Optional components could also be checked here.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!--  {Example package1} -->
    <available property="{package1}.present"
               classpathref="classpath"
               classname="uk.ac.starlink.{package1}.{MainClass}"/>

    <fail message="No {package1} available" unless="{package1}.present"/>

    <!--  {Example package2} -->
    <available property="{package2}.present"
               classpathref="classpath"
               classname="uk.ac.starlink.{package1}.{MainClass}"/>

    <fail message="No {package2} available" unless="{package2}.present"/>

    <!-- {More critical dependencies} -->

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <classpath refid="classpath"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
      <exclude name="**/{Retired1.java}"/>
      <exclude name="**/{Retired2.java}"/>
      <exclude name="**/*.html"/>
      <exclude name="**/*.properties*"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/{package.support.files}"/>
        <include name="**/{more.package.support.files}"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs) on and
   !  defines the application entrance point. The jar files should be
   !  placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Main-Class" value="{package.main.class}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
    </signjar>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !
   ! The webstart setup for an application requires that it have two
   ! JNLP files. One to describe it as an application and one as a component.
   ! The component form is required if another application wants to use
   ! this application, either directly (by embedding) or just as a
   ! dependency (for contact via webservices). These two functions cannot be
   ! performed in the same two JNLP files.
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this application.
     !   Note this goes into "dist.lib", not the package dependent lib.
     !-->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">

      <information>
         <title>{Package} - {description}</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>Starlink {Package} - Webstart edition</description>
         <offline_allowed/>
       </information>

       <security>
          <all_permissions/>
       </security>

       <resources>
         <j2se version="1.5+"/>

         <!-- The application main jar file -->
         <jar href="${name}/${name}.jar"/>

         <!-- All other components and dependencies of this application.
          !   Keep these in the component extension so this information is in
          !   one place and so this application is usable by other 
          !   applications). --> 
         <extension name="{PACKAGE}-PARTS" href="${name}-parts.jnlp"/>

         <!-- Other applications that this application uses. Note these
          !   should not normally be named in the "parts" component to avoid
          !   the possibility of circular dependencies. -->
         <extension name="{App1}-PARTS" href="{app1}-parts.jnlp"/>
         <extension name="{App2}-PARTS" href="{app2}-parts.jnlp"/>
       </resources>

       <!-- This an an application JNLP file. -->
       <application_desc main_class="{main-class}"/>
     </jnlp>

    <!-- Create a webstart JNLP file for this application as a component, 
     !   so that may be used by other applications. This goes into "dist.lib".
     !-->
     <jnlp toFile="${dist.lib}/${name}-parts.jnlp" href="${name}-parts.jnlp"
          codebase="${webstart.codebase}">

      <information>
         <title>{Package} - {description}</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>Starlink {Package} - Webstart edition</description>
         <offline_allowed/>
       </information>

       <security>
          <all_permissions/>
       </security>

       <resources>
         <j2se version="1.5+"/>

         <!-- All jar files of this application -->
         <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>

         <!-- Components that this component depends on (non applications
          !   named in the application jar file class-path). -->
         <extension name="{EXT1}" href="{ext1}.jnlp"/>
         <extension name="{EXT2}" href="{ext2}.jnlp"/>
       </resources>

       <!-- This is a component -->
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin.pkg}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <mkdir dir="${dist.etc.pkg}"/>

    <!-- Copy any startup scripts etc. -->
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin.pkg}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.etc.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.bin.pkg}
</echo>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <mkdir dir="${dist.etc.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html">
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !
   !  Application packages should only make public those parts of
   !  their internal APIs that they are prepared to support. Consider
   !  adding such code to proper class libraries (such as util).
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/JUnit*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   {Package} build file
 !
 !   This file describes how to build and install {Package} from
 !   source and binary releases. {Package} is a class library
 !   (i.e. provides an API and related documentation).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for {Package}" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="{PACKAGE}"/>
  <property name="name" value="{package}"/>
  <property name="version" value="1.0"/>

  <!-- The Java package name -->
  <property name="package.name" value="{package.path}"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.5"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Any achitecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase"
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Installed jar files.
   !
   !   Name all the installed jar files of other packages that we depend on.
   !
   !   When compiling under Java 1.4 these will be used to produce a full
   !   classpath that is equivalent to that generated when these are
   !   referenced as optional bundled packages by the JVM.
   !   When compiling under Java 1.5 (and probably later) this is just
   !   a simple path of these jar files, as the expansion to a full optional
   !   bundled package classpath is performed by the compiler
   !
   !   What that all means is that the manifest classpaths of these jar files
   !   are honoured, the plain compiler pre Java 1.5 didn't do that. When Java
   !   1.4 is no longer used the extclasspath type can be replaced by a simple
   !   path.
   !-->
  <extclasspath id="installed.classpath">

    <!-- {Other packages} -->
    <pathelement location="${star.jar.dir}/{package1}/{package1.jar}"/>
    <pathelement location="${star.jar.dir}/{package2}/{package2.jar}"/>

    <!-- {More packages} -->
  </extclasspath>

  <!-- Local build system jar files.
   !
   !   Name all the jar files of other packages that we depend on, which have
   !   not been installed (should be same packages as in installed.classpath).
   !-->
  <extclasspath id="built.jarpath">

    <pathelement
       location="${star.build.dir}/{package1}/lib/{package1}/{package1.jar}"/>
    <pathelement
       location="${star.build.dir}/{package2}/lib/{package2}/{package2.jar}"/>

    <!-- {More packages} -->
  </extclasspath>

  <!-- Find all local third party jars files.
   !
   !   Normally these will be kept in their own third party package, but may
   !   be kept here temporarily, say if there are version conflicts that
   !   cannot be addressed. They are installed with the package jar files and
   !   should be entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  </path>

  <!-- Create the local build system CLASSPATH.
   !
   !   Create the classpath used when building this package as part of a full
   !   build system without any dependency on any installed or external jar
   !   files.
   !
   !   Classes compiled in the local build tree will be in the "build/classes"
   !   part of each package. Third party packages, have do not have any source
   !   code, just jar files, will have their jar files in their "dist"
   !   directories (usually lib/{package_name}).
   !
   !   So the full built classpath is created by constructing a path
   !   consisting of:
   !
   !      - all third party jar files in this package
   !      - all build/classes directories in the local build system (these
   !        will have the most recent class files)
   !      - all jar files named in built.jarpath, i.e. named local build
   !        system jar files (these can be normal packages in the "dist" state
   !        or third party packages)
   !      - all jar files in the "dist" directories of all packages in the
   !        local build system (these are necessary to make sure that the jar
   !        files in the previous part have their dependencies fulfilled,
   !        without having them all installed)
   !-->
  <path id="built.classpath">

    <!-- Third party jars held by this package -->
    <path refid="package.jars"/>

    <!-- All classes in the local build system -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent jars in the local build system -->
    <path refid="built.jarpath"/>

    <!-- All "dist" jar files to make sure everything is resolved, including
     !   relative URLs of the local packages, without installation -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

  </path>

  <!-- User-defined CLASSPATH.
   !
   !   This is set by the property "extra.class.path" (which can be defined
   !   locally using say -Dextra.class.path=$CLASSPATH on the command line
   !   or by setting the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Create the full CLASSPATH used during compilation.
   !
   !   This is created from the user-defined classpath, followed by the
   !   classpath for building against the local system, followed by the
   !   classpath for building against an installed system.
   !-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- Create the JUnit tests CLASSPATH.
   ! 
   !   Note that in addition to the build/classes and build/tests directory
   !   we also add tests.dir and tests.etc.dir so that resources may be
   !   located there. The full classpath is also used.
   !-->  
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    ============
   !    Library path
   !    ============
   !    Used by test targets for locating native libraries.
   !-->
  <path id="tests-libpath.id">
    <pathelement path="${java.library.path}"/>
    <pathelement location="${star.jar.dir}/${os.arch}"/>
  </path>
  <property name="tests-libpath" refid="tests-libpath.id"/>

  <!--
   !    ===============
   !    Extension tasks
   !    ===============
   !    Add any local or extension ANT tasks that are required. Local
   !    tasks should be moved into the ANT package if used outside of this
   !    package. 
   !-->
  <taskdef resource="axis-tasks.properties" classpathref="classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !
   !    Minimalist check of the required dependencies so that the build will
   !    not proceed if some basic dependencies are not present on the
   !    classpath. Optional components could also be checked here.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!--  {Example package1} -->
    <available property="{package1}.present"
               classpathref="classpath"
               classname="uk.ac.starlink.{package1}.{MainClass}"/>

    <fail message="No {package1} available" unless="{package1}.present"/>

    <!--  {Example package2} -->
    <available property="{package2}.present"
               classpathref="classpath"
               classname="uk.ac.starlink.{package1}.{MainClass}"/>

    <fail message="No {package2} available" unless="{package2}.present"/>

    <!-- {More critical dependencies} -->

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <classpath refid="classpath"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
      <exclude name="**/{Retired1.java}"/>
      <exclude name="**/{Retired2.java}"/>
      <exclude name="**/*.html"/>
      <exclude name="**/*.properties*"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/{package.support.files}"/>
        <include name="**/{more.package.support.files}"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this class library.
     !   This goes into "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">

      <information>
         <title>{Package} - {description}</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink {Package} - Webstart edition"</description>
         <offline_allowed/>
       </information>

       <security>
          <all_permissions/>
       </security>

       <resources>
         <j2se version="1.5+"/>

         <!-- Define the main library jar file -->
         <jar href="${name}/${name}.jar"/>

         <!-- Name any extension packages we directly depend on -->
         <extension name="{EXT1}" href="{ext1}.jnlp"/>
         <extension name="{EXT2}" href="{ext2}.jnlp"/>
       </resources>

       <!-- This is a component -->
       <component_desc/>

     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin.pkg}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <mkdir dir="${dist.etc.pkg}"/>

    <!-- Copy any configuration/helper scripts etc. -->
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin.pkg}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.etc.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory-->
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <mkdir dir="${dist.etc.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/JUnit*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !  {Package} build file
 !
 !   This file describes how to build and install the {Package}
 !   package from its binary release. {Package} is a pre-built third
 !   party package that is permanently in the "dist" configuration.
 !
 !   The main targets are:
 !
 !      build            -> makes copies of local files that will be modified
 !      clean            -> removes local copies
 !      deinstall        -> undo the install target
 !      dist             -> makes package into dist state

 !      export           -> creates the full distribution archives
 !      export-runonly   -> same as export
 !      export-source    -> same as export
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> same as install
 !      jars             -> add manifest and signs jar files
 !      javadocs         -> does nothing
 !      javadoc-sources  -> does nothing
 !      test             -> may run a test for checking package function
 !
 !   The targets that do nothing are provided for compatibility with
 !   the normal build system.
 !
 !   Authors:
 !      Peter W. Draper (16-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for {Package}" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good idea as names
   !   are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="{PACKAGE}"/>
  <property name="name" value="{package}"/>
  <property name="version" value="1.0"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing any unmodified jars of this package -->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Distribution directories, these are the actual state of this
   !   package at all times -->
  <property name="dist.dir" value="${basedir}"/>

  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase"
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="{package_original_home_page}"/>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

  </target>

  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !-->
  <target name="build"
          depends="prepare"
          description="-> make local copies of files for modification">

    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>

  </target>

  <!--
   !   ===========================
   !   Create the package jar file
   !   ===========================
   !

   !  Update the manifest of the package main jar file, if
   !  needed. This is typically the jar file with the main package
   !  classes. If this package has more than one such jar file, then
   !  update them all.
   !
   !  Packages whose jar files are not already signed (by the
   !  originator) should be signed here.
   !-->
  <target name="jars"
          description="-> does nothing">

     <!-- Add the manifest to the jar file, just an update -->
    <jar destfile="${dist.lib.pkg}/{package.jar}" basedir="${dist.dir}"
         update="true" excludes="**">

      <!-- Create the manifest, note wraps in column 80 are done
       !   automatically, so just use a single line. Dependencies
       !   are named using relative URLs-->
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>

    </jar>

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
    </signjar>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package.
     !   This goes into "dist.lib".
     !-->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">

      <information>
         <title>{Package} - {description}</title>
         <vendor>{Vendor}</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>{Package} - Webstart edition</description>
         <offline_allowed/>
      </information>

      <security>
        <all_permissions/>
      </security>

      <resources>
        <j2se version="1.5+"/>
        <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
      </resources>

      <component_desc/>

     </jnlp>

  </target>

  <!--
   !   =============================
   !   Create the local distribution
   !   =============================
   !
   !  Nothing to do, this package is permanently in this condition.
   !-->
  <target name="dist"
          depends="jars,webstart"
          description="-> make package ready for distribution">
  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  package.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  Same as export, except for the name.
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

    <antcall target="create_archives">
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. Same as export, except for the
   !  name.
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

    <antcall target="create_archives">
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required.
   ! For this package these are all the same just set the property
   ! "archive.name" to define what name to use for the outfile
   ! files. The archives are also written into the directory
   ! ${star.archive.dir} (the local directory by default).
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>
    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>
      <zipfileset dir="${dist.bin}" prefix="${name}/bin"/>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib"/>

    </zip>

    <tar longfile="gnu" destfile="${archive.name}.tar">

      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin"/>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib"/>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   ! Does nothing.
   !-->
  <target name="clean"
          description="-> removes local copies">

    <delete dir="${dist.lib}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the package into another set of directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>

    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin}"/>
    <mkdir dir="${star.lib}"/>
    <mkdir dir="${star.docs}"/>

    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.bin.pkg}
</echo>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   =========================================
   !
   ! Same as install.
   !-->
  <target name="install-runonly"
          description="-> install distribution into Starlink tree">

     <antcall target="install"/>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   ! that were copied into place by the install target.
   !-->

 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Does nothing.
   !-->
  <target name="javadocs"
          description="-> does nothing">
  </target>

  <!--
   !   ==========================================
   !   Creates the API documentation java sources
   !   ==========================================
   !
   !  Does nothing.
   !-->
  <target name="javadoc-sources"
          description="-> does nothing">
  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          description="-> does nothing"/>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   TOPCAT build file
 !
 !   This file describes how to build and install {Package}
 !   from a source and binary release. {Package} is an application
 !   package, i.e. provides user-level commands and interfaces, as
 !   well as a programming API.
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Targets specific to TOPCAT:
 !      build-standalone -> builds topcat-full.jar, topcat-lite.jar
 !      docs-pdf         -> builds sun253.pdf
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for TOPCAT" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="TOPCAT"/>
  <property name="name" value="topcat"/>
  <property name="version" value="4.1+"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.topcat"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.5"/>

  <!-- JVM binary to use for certain forked tasks.  This may be different
   !   from that used to run ant.  This is a bit of a hack; in some
   !   cases we want to run the build on a 1.5 JDK to generate Java1.5 classes,
   !   but 1.6 needs to be used for some documentation tasks to avoid
   !   1.5-specific xerces bugs.  An alternative approach would be 
   !   cross-compilation of all packages. -->
  <property name="alt.java" value="java"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="user.doc" value="sun253"/>
  <property name="src.docs" value="${src.dir}/docs"/>
  <property name="xdoc.etc" value="${star.dir}/etc/xdoc"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directory for demo data -->
  <property name="src.etc" value="${src.dir}/etc"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.javadocs" value="${build.dir}/javadocs"/>
  <property name="build.docs" value="${build.dir}/docs"/>
  <property name="build.etc" value="${build.dir}/etc"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>
  <property name="dist.osx" value="${dist.dir}/osx-${name}"/>
  <property name="dist.dmgfile" value="${dist.dir}/${name}-full.dmg"/>

  <property name="dist.bin.pkg" value="${dist.bin}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
           value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}/"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- Table -->
    <pathelement location="${star.jar.dir}/table/table.jar"/>

    <!-- TTOOLS -->
    <pathelement location="${star.jar.dir}/ttools/ttools.jar"/>

    <!-- Help -->
    <pathelement location="${star.jar.dir}/help/jhall.jar"/>

    <!-- Util -->
    <pathelement location="${star.jar.dir}/util/util.jar"/>

  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">
    <pathelement location="${star.build.jar}/util/lib/util/util.jar"/>
    <pathelement location="${star.build.jar}/table/lib/table/table.jar"/>
    <pathelement location="${star.build.jar}/ttools/lib/ttools/ttools.jar"/>
    <pathelement location="${star.build.jar}/help/lib/help/jhall.jar"/>
  </extclasspath>

  <!-- "Local" third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, say
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property
   !   "extra.class.path" (which can be defined locally using say
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
    <path refid="local.classpath"/>
    <path refid="built.classpath"/>
    <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath, add tests.dir and tests.etc.dir so that
   !   resources may be located there -->
  <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <pathelement location="${star.jar.dir}/xdoc/xdoc.jar"/>
    <path refid="classpath"/>
  </path>

  <!-- Need installed JNIAST for javadoc fun and games - this seems to do it
   !   (though maybe means the main classpath is broken??) -->
  <path id="docs-classpath">
    <path refid="installed.classpath"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    ============
   !    Library path
   !    ============
   !    Used by test targets for locating native libraries.
   !-->
  <path id="tests-libpath.id">
    <pathelement path="${java.library.path}"/>
    <pathelement location="${star.jar.dir}/${os.arch}"/>
  </path>
  <property name="tests-libpath" refid="tests-libpath.id"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!-- UTIL -->
    <available property="util.present"
               classpathref="classpath"
               classname="uk.ac.starlink.util.DataSource"/>
    <fail message="No UTIL available" unless="util.present"/>

    <!-- TABLE -->
    <available property="table.present"
               classpathref="classpath"
               classname="uk.ac.starlink.table.StarTable"/>
    <fail message="No TABLE available" unless="table.present"/>

    <!-- HELP -->
    <available property="help.present"
               classpathref="classpath"
               classname="javax.help.JHelp"/>
    <fail message="No HELP available" unless="help.present"/>

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- Human-readable copyright string -->
    <property name="copyright.string"
              value="Copyright &#169; 2003-${year} CCLRC: Council for the Central Laboratory of the Research Councils.  All Rights Reserved."/>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here. 
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
      <exclude name="**/{Retired1.java}"/>
      <exclude name="**/{Retired2.java}"/>
      <exclude name="**/*.html"/>
      <exclude name="**/*.properties*"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${src.dir}/resources"/>
    </copy>
    <copy todir="${build.classes}/uk/ac/starlink/topcat">
      <fileset dir="${src.docs}" includes="figures/*"/>
    </copy>

    <!-- Write some required GIFs to the images directory programatically. -->
    <java classname="uk.ac.starlink.topcat.ResourceIcon"
          failonerror="yes"
          dir="${build.classes}/uk/ac/starlink/topcat/images/"
          fork="yes">
      <sysproperty key="java.awt.headless" value="true"/>
      <classpath refid="classpath"/>
      <arg value="-writegifs"/>
    </java>

    <!-- Version string. -->
    <echo file="${build.classes}/uk/ac/starlink/topcat/version-string"
          message="${version}"/>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>

    <!-- Call target to do time-consuming build of additional components;
     !   first check that they are not already in place. -->
    <condition property="extras.built">
      <and>
        <uptodate targetfile="${build.javadocs}/uk/ac/starlink/topcat/func">
          <srcfiles dir="${java.dir}/uk/ac/starlink/topcat/func/"/>
        </uptodate>
        <uptodate targetfile="${build.etc}/demo">
          <srcfiles dir="${src.etc}/demo"/>
        </uptodate>
      </and>
    </condition>
    <antcall target="build-extras"/>

  </target>

  <!-- Sub-target to perform time-consuming build of additional components
   !   in build phase; unless attribute allows it to be skipped. -->
  <target name="build-extras" unless="extras.built">

    <!-- Construct HTML documentation for the JEL-accessible classes.
     !   This is built using Javadoc, and is available from the MethodWindow
     !   method browser. -->
    <javadoc doclet="uk.ac.starlink.ttools.build.HtmlDoclet"
             docletpathref="classpath"
             failonerror="true"
             public="true"
             destdir="${build.javadocs}"
             sourcepath="${java.dir}"
             packagenames="uk.ac.starlink.topcat.func"
             classpathref="classpath"
             source="${source.version}"/>

     <antcall target="build_demo"/>
  </target>

  <!--
   !   ==========================
   !   Build standalone jar files
   !   ==========================
   !
   !  Builds jar files which can be used on their own, without needing any
   !  other jars to be present.  Two of them are built: topcat-lite.jar
   !  which contains enough classes to do most things but not support for
   !  peripheral items like MySpace access etc.
   !-->
  <target name="build-standalone"
          depends="install"
          description="-> builds a standalone jar file">

    <!-- Build temporary zip file containing things not in the input jars
     !   which ought to be included in the standalone jars. -->
    <exec outputproperty="gitversion"
          logerror="true"
          executable="${star.dir}/bin/gitversion"/>
    <echo message="${gitversion}"
          file="${build.classes}/uk/ac/starlink/topcat/revision-string"/>
    <mkdir dir="${build.classes}/uk/ac/starlink/ttools"/>
    <echo message="${gitversion}"
          file="${build.classes}/uk/ac/starlink/ttools/revision-string"/>

    <zip destfile="${dist.lib.pkg}/extras.zip">
      <fileset dir="${star.bin}" includes="topcat stilts"/>
      <fileset dir="${star.dir}/source/src/etc" includes="LICENCE.txt"/>
      <fileset dir="${star.etc}/ttools" includes="stilts.py"/>
      <fileset dir="${build.classes}">
        <include name="uk/ac/starlink/topcat/revision-string"/>
        <include name="uk/ac/starlink/ttools/revision-string"/>
      </fileset>
    </zip>
    <delete file="${build.classes}/uk/ac/starlink/topcat/revision-string"/>
    <delete file="${build.classes}/uk/ac/starlink/ttools/revision-string"/>

    <!-- Build topcat-lite.jar - minimal standalone which does basic things. -->
    <java classname="uk.ac.starlink.util.SuperJar" failonerror="yes">
      <classpath refid="classpath"/>
      <arg value="-oj"/><arg value="${dist.lib.pkg}/topcat-lite.jar"/>
      <arg value="-xjar"/><arg value="array.jar"/>
      <arg value="-xjar"/><arg value="astrogrid.jar"/>
      <arg value="-xjar"/><arg value="axis.jar"/>
      <arg value="-xjar"/><arg value="hds.jar"/>
      <arg value="-xjar"/><arg value="hdx.jar"/>
      <arg value="-xjar"/><arg value="jaiutil.jar"/>
      <arg value="-xjar"/><arg value="jniast.jar"/>
      <arg value="-xjar"/><arg value="junit.jar"/>
      <arg value="-xjar"/><arg value="ndx.jar"/>
      <arg value="-xjar"/><arg value="sog.jar"/>
      <arg value="-xjar"/><arg value="soapserver.jar"/>
      <arg value="-xjar"/><arg value="srb.jar"/>
      <arg value="-xent"/><arg value="COPYING.txt"/>
      <arg value="-xent"/><arg value="README.txt"/>
      <arg value="-xent"/><arg value="package cache/"/>
      <arg value="${star.lib.pkg}/topcat.jar"/>
      <arg value="${dist.lib.pkg}/extras.zip"/>
    </java>

    <java classname="uk.ac.starlink.util.SuperJar" failonerror="yes">
      <classpath refid="classpath"/>
      <arg value="-oj"/><arg value="${dist.lib.pkg}/topcat-full.jar"/>
      <arg value="-xjar"/><arg value="junit.jar"/>
      <arg value="-xjar"/><arg value="log4j.jar"/>
      <arg value="-xjar"/><arg value="log4j-core.jar"/>
      <arg value="-xjar"/><arg value="jsky/jel.jar"/>
      <arg value="-xjar"/><arg value="diva/acme.jar"/>
      <arg value="-xjar"/><arg value="gsi-classes.jar"/>
      <arg value="-xent"/><arg value="COPYING.txt"/>
      <arg value="-xent"/><arg value="README.txt"/>
      <arg value="-xent"/><arg value="package cache/"/>
      <arg value="${star.lib.pkg}/topcat.jar"/>
      <arg value="${dist.lib.pkg}/extras.zip"/>
    </java>

    <delete file="${dist.lib.pkg}/extras.zip"/>

    <echo message="standalone jar files not signed"/>
    <!--
     !   <signjar alias="${webstart.alias}"
     !            keystore="${webstart.keystore}"
     !            keypass="${webstart.keypass}"
     !            storepass="${webstart.storepass}">
     !     <fileset dir="${dist.lib.pkg}"
     !              includes="topcat-lite.jar topcat-full.jar"/>
     !   </signjar>
     !-->
  </target>

  <!--
   !   ===================
   !   Construct demo data
   !   ===================
   !-->
  <target name="build_demo">
    <property name="src.demo" value="${src.etc}/demo"/>
    <property name="build.demo" 
              value="${build.etc}/demo/uk/ac/starlink/topcat/demo"/>
    <mkdir dir="${build.demo}"/>

    <!-- Set up a file recording which demo files are to be used. -->
    <property name="demo.list" value="${build.demo}/demo_list"/>
    <delete file="${demo.list}" quiet="true"/>
    <touch file="${demo.list}"/>

    <bzip2 src="${src.demo}/votable/6dfgs_mini.xml"
           destfile="${build.demo}/6dfgs_mini.xml.bz2"/>
    <echo append="true" file="${demo.list}" message="6dfgs_mini.xml.bz2&#xA;"/>

    <copy todir="${build.demo}">
      <fileset dir="${src.demo}/fits" includes="863sub.fits"/>
      <fileset dir="${src.demo}/votable" includes="messier.xml,vizier.xml.gz"/>
    </copy>
    <echo append="true" file="${demo.list}" message="messier.xml&#xA;"/>
    <echo append="true" file="${demo.list}" message="vizier.xml.gz&#xA;"/>
    <echo append="true" file="${demo.list}" message="863sub.fits&#xA;"/>

    <gzip src="${src.demo}/fits/tables.fit"
          zipfile="${build.demo}/tables.fit.gz"/>
    <echo append="true" file="${demo.list}" message="tables.fit.gz&#xA;"/>

    <tar destfile="${build.demo}/demo.tar.bz2"
         compression="bzip2">
      <tarfileset dir="${src.etc}">
        <include name="demo/votable/messier.xml"/>
        <include name="demo/fits/tables.fit"/>
        <include name="demo/others/**"/>
      </tarfileset>
    </tar>
    <echo append="true" file="${demo.list}" message="demo.tar.bz2&#xA;"/>
  </target>


  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs) on and
   !  defines the application entrance point. The jar files should be
   !  placed directly in the distribution directories. 
   !-->
  <target name="jars"
          depends="build, docs-html"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar">
      <fileset dir="${build.classes}"/>
      <fileset dir="${build.javadocs}"/>
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Main-Class"
                   value="uk.ac.starlink.topcat.Driver"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
        <!-- Required for WebStart signed jars at java 7u51+ -->
        <attribute name="Permissions" value="all-permissions"/>
        <attribute name="Application-Name" value="TOPCAT"/>
      </manifest>
    </jar>

    <jar destfile="${dist.lib.pkg}/${name}_demo.jar"
         basedir="${build.etc}/demo"/>

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
    </signjar>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>TOPCAT</title>
         <vendor>Mark Taylor, Bristol University</vendor>
         <homepage href="${home.page}"/>
         <icon href="${home.page}images/tc_sok.gif"/>
         <description>"TOPCAT - Tool for OPerations on Catalogues And Tables"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="${name}/${name}.jar"/>
         <extension name="TOPCAT-PARTS" href="${name}-parts.jnlp"/>
       </resources>
       <application_desc main_class="uk.ac.starlink.topcat.Driver"/>
     </jnlp>

     <!-- May be needed as a component so provide that too -->
     <jnlp toFile="${dist.lib}/${name}-parts.jnlp" href="${name}-parts.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>TOPCAT - Tool for OPerations on Catalogues And Tables</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink TOPCAT - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
         <extension name="TTOOLS" href="ttools.jnlp"/>
         <extension name="DATANODE" href="datanode.jnlp"/>
         <extension name="HELP" href="help.jnlp"/>
         <extension name="CONNECT" href="connect.jnlp"/>
         <extension name="ASTROGRID" href="astrogrid.jnlp"/>
         <extension name="SRB" href="srb.jnlp"/>
         <extension name="PLASTIC" href="plastic.jnlp"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!-- Create an MacOS X Java application bundle, using the osxjarbundler ant
   !   task built (see http://jarbundler.sourceforge.net).
   !   Additionally, create a .dmg file for distribution.
   !-->
  <target name="build-osxapp"
          depends="build_demo,build-standalone"
          description="-> builds .dmg application bundle for MacOS X">
    <delete dir="${dist.osx}" quiet="true"/>
    <mkdir dir="${dist.osx}"/>
    <!-- 'Infostring' should not contain a version number (as of OS X
     !   10.4 - see docs for CFBundleGetInfoString); 'version' should
     !   be the `marketing version of the bundle' (ie, the release
     !   version); 'buildnumber' can optionally hold a rolling build number.
     !   -->
    <osxjarbundler dir="${dist.osx}"
                mainclass="${package.name}.Driver"
                name="${Name}"
                shortname="${Name}"
                aboutmenuname="${Name}"
                bundleid="${package.name}"
                stubfile="${src.dir}/lib/MacOS/TopcatStub"
                icon="${src.dir}/lib/MacOS/Topcat.icns"
                infostring="${Name} ${copyright.string}"
                jvmversion="1.5+"
                vmoptions=""
                version="${version}"
                jar="${dist.lib.pkg}/topcat-full.jar">

      <!-- demo data lives in ${src.etc}/demo (see target build_demo) -->
      <resourcefileset dir="${src.etc}"
                       includes="demo/**"/>
      <javaproperty name="uk.ac.starlink.topcat.demodir"
                    value="$APP_PACKAGE/Contents/Resources/demo"/>

      <javaproperty name="uk.ac.starlink.topcat.cmdname"
                    value="topcat"/>
      <!-- Put the menus in the screen menu bar, rather than an
           application-specific one -->
      <javaproperty name="apple.laf.useScreenMenuBar" value="true"/>

    </osxjarbundler>

    <!-- Copy the docs into the release directory -->
    <mkdir dir="${dist.osx}/docs"/>
    <copy todir="${dist.osx}/docs">
      <fileset dir="${dist.docs}/${name}" excludes="javadocs javadocs/**"/>
    </copy>

    <!-- Copy scripts into the release directory -->
    <mkdir dir="${dist.osx}/bin"/>
    <copy todir="${dist.osx}/bin">
      <fileset dir="${star.bin}" includes="topcat stilts"/>
    </copy>
    <chmod perm="ugo+x" type="file" failonerror="yes" maxparallel="50">
      <fileset dir="${dist.osx}/bin"/>
    </chmod>

    <mkdir dir="${dist.osx}/README.rtfd"/>
    <copy todir="${dist.osx}/README.rtfd">
      <fileset dir="${src.dir}/lib/MacOS/README.rtfd"/>
    </copy>

    <!-- The final step - generating the .dmg file - can only be done on
     !   a Mac.  Either do it, or write a message saying how.  If the build
     !   is being done on a non-Mac system, just copy the ${dist.osx} 
     !   directory to a Mac and run hdiutil there. -->
    <condition property="isMacos">
      <os family="mac"/>
    </condition>
    <!-- Note: to examine the dmg file on OSX do 
     !      % hdiutil attach topcat.dmg 
     ! ...  % hdiutil detach /dev/... -->
    <echo message="Attempt to build .dmg file (will only work on Mac)"/>
    <echo message="   hdiutil create -srcfolder ${dist.osx} -volname ${name} -ov ${dist.dmgfile}"/>
    <exec executable="/usr/bin/hdiutil" os="Mac OS X">
      <arg value="create"/>
      <arg value="-srcfolder"/>
      <arg value="${dist.osx}"/>
      <arg value="-volname"/>
      <arg value="${name}"/>
      <arg value="-ov"/>
      <arg value="${dist.dmgfile}"/>
    </exec>
  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,docs-html,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin.pkg}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <mkdir dir="${dist.etc.pkg}"/>

    <!-- Copy application scripts. -->
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${build.docs}"
               includes="images/* figures/* ${user.doc}/* *.pdf"/>
    </copy>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}" maxparallel="50"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}" maxparallel="50"/>
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}"
           maxparallel="50">
       <fileset dir="${dist.bin}"/>
    </chmod>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>
    <delete dir="${dist.osx}" quiet="true"/>
    <delete dir="${dist.dmgfile}" quiet="true"/>
  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.bin.pkg}
</echo>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
        <include name="**/*.icns"/>
      </fileset>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
         <exclude name="uk/ac/starlink/topcat/doc"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <!-- Cope with custom tags. -->
      <tag name="example"
           description="Examples:"
           scope="methods, fields"
           enabled="true"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom>${copyright.string}</bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html">
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   ======================================================
   !   Creates additional HTML documentation from XML sources
   !   ======================================================
   !
   !   The XML user document is downconverted to single- and multiple-
   !   file HTML versions in the docs directory, and a JavaHelp version
   !   on the classpath of the application.
   !-->
  <target name="docs-html"
          depends="build, html_check, docs_depend"
          unless="docs.notrequired"
          description="-> creates the user documentation">

    <!-- Transform the user document XML to a single HTML document. -->
    <mkdir dir="${build.docs}/${user.doc}"/>
    <copy todir="${build.docs}/${user.doc}">
      <fileset dir="${xdoc.etc}" includes="sun-style.css"/>
    </copy>
    <xslt in="${build.docs}/${user.doc}.xml" 
          out="${build.docs}/${user.doc}/${user.doc}.html"
          style="${xdoc.etc}/toHTML1.xslt">
      <param name="VERSION" expression="${version}"/>
      <param name="BASEDIR" expression="${build.docs}/${user.doc}"/>
      <param name="COVERIMAGE" expression="../figures/multishot-mini.gif"/>
      <param name="CSS_HREF" expression="sun-style.css"/>
    </xslt>

    <!-- Transform the user document from XML to HTML form for browsing. -->
    <java classpathref="classpath"
          dir="${src.docs}"
          classname="uk.ac.starlink.xdoc.MultiXML"
          failonerror="yes"
          fork="yes"
          jvm="${alt.java}">
      <sysproperty key="java.awt.headless" value="true"/>
      <arg value="-style"/> <arg value="${xdoc.etc}/toHTML.xslt"/>
      <arg value="-param"/> <arg value="VERSION=${version}"/>
      <arg value="-param"/> <arg value="BASEDIR=${build.docs}/${user.doc}"/>
      <arg value="-param"/> 
                       <arg value="COVERIMAGE=../figures/multishot-mini.gif"/>
      <arg value="-param"/> <arg value="CSS_HREF=sun-style.css"/>
      <arg value="${build.docs}/${user.doc}.xml"/>
      <arg value="${build.docs}/${user.doc}"/>
    </java>

    <!-- Copy same into the classes directory so that it ends up in the
     !   jar file.  -->
    <copy todir="${build.classes}/uk/ac/starlink/topcat/${user.doc}">
      <fileset dir="${build.docs}/${user.doc}"/>
    </copy>

    <!-- Transform the user document from XML to JavaHelp form. -->
    <java classpathref="classpath"
          dir="${src.docs}" 
          classname="uk.ac.starlink.xdoc.MultiXML" 
          failonerror="yes"
          fork="yes"
          jvm="${alt.java}">
      <sysproperty key="java.awt.headless" value="true"/>
      <arg value="-style"/> <arg value="${xdoc.etc}/toHelp.xslt"/>
      <arg value="-param"/> <arg value="VERSION=${version}"/>
      <arg value="-param"/> <arg value="BASEDIR=${build.docs}/${user.doc}"/>
      <arg value="-param"/> <arg value="CSS_HREF=sun-style.css"/>
      <arg value="${build.docs}/${user.doc}.xml"/>
      <arg value="${build.classes}/uk/ac/starlink/topcat/help"/>
    </java>

    <!-- Builds the help file index database.  Uses the "search-config" file
     !   generated by the toHelp stylesheet, and deletes it when done. -->
    <java classpathref="classpath"
          dir="${build.classes}/uk/ac/starlink/topcat/help"
          fork="true"
          classname="com.sun.java.help.search.Indexer"
          failonerror="yes">
      <arg value="-c"/>
      <arg value="search-config"/>
    </java>
    <delete file="${build.classes}/uk/ac/starlink/topcat/help/search-config"/>

    <!-- Copy the image icons themselves into the help directory where they
     !   will be referenced from the HTML. -->
    <copy todir="${build.classes}/uk/ac/starlink/topcat/help">
      <fileset dir="${build.docs}/${user.doc}"
               includes="${user.doc}.html sun-style.css"/>
    </copy>
  </target>

  <!--
   !   =================================================
   !   Create user document in PDF form from XML sources
   !   =================================================
   !
   !   The XML document is downconverted to PDF via xsl-fo using Fop.
   !
   !   This process is, for reasons I haven't tried very hard to
   |   understand, rather slow (~3 minutes) and also problematic
   !   in that it can fail due to a Xerces bug in (Sun's) J2SE1.5.
   !   Given that, and the fact that the PDF user document is rather
   !   a special-interest item, this target is no longer invoked as
   !   part of the normal install target.  If the PDF user document
   !   is required, this target must be invoked explicitly.
   !-->
  <target name="docs-pdf"
          depends="build, docs_depend"
          unless="docs.notrequired"
          description="-> creates the user documentation in PDF form">

    <!-- Transform the user document XML to a PDF document via XSL-FO. -->
    <xslt in="${build.docs}/${user.doc}.xml"
          out="${build.docs}/${user.doc}.fo"
          style="${xdoc.etc}/toFo.xslt">
      <param name="VERSION" expression="${version}"/>
      <param name="BASEDIR" expression="${build.docs}/${user.doc}"/>
      <param name="FIGDIR" expression="${build.docs}/figures"/>
      <param name="COVERIMAGE" expression="../multishot.gif"/>
    </xslt>
    <java classname="org.apache.fop.apps.Fop"
          failonerror="yes"
          fork="yes"
          jvm="${alt.java}"
          maxmemory="256M">
      <classpath>
        <fileset dir="${star.jar.dir}/xdoc" includes="*.jar"/>
      </classpath>
      <sysproperty key="java.awt.headless" value="true"/>
      <arg value="-q"/>
      <arg value="-fo"/> <arg value="${build.docs}/${user.doc}.fo"/>
      <arg value="-pdf"/> <arg value="${build.docs}/${user.doc}.pdf"/>
    </java>
  </target>

  <!-- Checks whether the HTML docs build is up to date. -->
  <target name="html_check" unless="docs.notrequired">
    <uptodate property="docs.notrequired"
              srcfile="${src.docs}/${user.doc}.xml" 
              targetfile="${build.docs}/${user.doc}/${user.doc}.html"/>
  </target>

  <!-- Prepares for document creation.  The XML source document and all
   !   the external entities it requires are copied into the build.docs
   !   directory. -->
  <target name="docs_depend"
          depends="build"
          unless="docs.notrequired">

    <property name="ttools.java" value="${java.dir}/../../../ttools/src/main"/>

    <!-- Make destination directory for built files. -->
    <mkdir dir="${build.docs}"/>

    <!-- Copy required source files there. -->
    <copy todir="${build.docs}">
      <fileset dir="${src.docs}" 
               includes="${user.doc}.xml figures/* multishot.gif"/>
      <fileset dir="${build.classes}/uk/ac/starlink/topcat/"
               includes="images/*"/>
      <fileset dir="${xdoc.etc}"
               includes="docs.dtd"/>
    </copy>

    <!-- Write a file containing entity definitions for all the image files
     !   that might be referenced in the user document (this file is 
     !   referenced from within the user document as an external entity).
     !   This JVM needs to be forked in order for the command to run
     !   properly on MacOS X (10.4.9), for reasons I don't really 
     !   understand. -->
    <java classname="uk.ac.starlink.topcat.ResourceIcon" 
          output="${build.docs}/image.defs"
          logerror="true"
          fork="true"
          failonerror="yes">
      <sysproperty key="java.awt.headless" value="true"/>
      <classpath refid="classpath"/>
      <arg value="-entities"/>
    </java>

    <!-- Construct XML documentation for the JEL-accessible classes.
     !   This is built using Javadoc, and forms part of the user document. -->
    <javadoc doclet="uk.ac.starlink.topcat.doc.SummaryXmlDoclet"
             docletpathref="classpath"
             failonerror="true"
             public="true"
             additionalparam="-gen -o ${build.docs}/general-javadocs.xml" 
             sourcepath="${ttools.java}"
             packagenames="uk.ac.starlink.ttools.func"
             classpathref="classpath"
             source="${source.version}"/>
    <javadoc doclet="uk.ac.starlink.topcat.doc.SummaryXmlDoclet"
             docletpathref="docs-classpath"
             failonerror="true"
             public="true"
             additionalparam="-act -o ${build.docs}/activation-javadocs.xml" 
             sourcepath="${java.dir}"
             packagenames="uk.ac.starlink.topcat.func"
             classpathref="classpath"
             source="${source.version}"/>
    <javadoc doclet="uk.ac.starlink.topcat.doc.SummaryXmlDoclet"
             docletpathref="docs-classpath"
             failonerror="true"
             public="true"
             additionalparam="-gen -headonly -o ${build.docs}/general-classes-javadocs.xml"
             sourcepath="${ttools.java}"
             packagenames="uk.ac.starlink.ttools.func"
             classpathref="classpath"
             source="${source.version}"/>
    <javadoc doclet="uk.ac.starlink.topcat.doc.SummaryXmlDoclet"
             docletpathref="docs-classpath"
             failonerror="true"
             public="true"
             additionalparam="-act -headonly -o ${build.docs}/activation-classes-javadocs.xml"
             sourcepath="${java.dir}"
             packagenames="uk.ac.starlink.topcat.func"
             classpathref="classpath"
             source="${source.version}"/>

    <!-- Construct topcat usage message in XML. -->
    <property name="topcat.usage" value="${build.docs}/topcat.usage"/>
    <echo message="&lt;![CDATA[" file="${topcat.usage}" append="no"/>
    <java classname="uk.ac.starlink.topcat.Driver"
          failonerror="yes"
          fork="no"
          output="${topcat.usage}"
          append="yes"
          classpathref="classpath">
      <sysproperty key="java.awt.headless" value="true"/>
      <arg value="-help"/>
    </java>
    <echo message="]]&gt;" file="${topcat.usage}" append="yes"/>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   ! 
   !  Application packages should only make public those parts of
   !  their internal APIs that they are prepared to support. Consider
   !  adding such code to proper class libraries (such as util).
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests,docs-html"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="basedir" value="${basedir}"/>
      <sysproperty key="xdoc.etc" value="${xdoc.etc}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <sysproperty key="tests.withnet" value="${tests.withnet}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests,docs-html"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="basedir" value="${basedir}"/>
      <sysproperty key="xdoc.etc" value="${xdoc.etc}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <sysproperty key="tests.withnet" value="${tests.withnet}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   Treeview build file
 !
 !   This file describes how to build and install Treeview
 !   from a source and binary release. Treeview is an application
 !   package, i.e. provides user-level commands and interfaces.
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for Treeview" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="Treeview"/>
  <property name="name" value="treeview"/>
  <property name="version" value="3.0"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.treeview"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="true"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.4"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="true"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="src.etc" value="${src.dir}/etc"/>
  <property name="src.lib" value="${src.dir}/lib"/>
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.etc}/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.etc" value="${build.dir}/etc"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase"
           value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/treeview/"/>

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Installed jar files.
   !
   !   Name all the installed jar files of other packages that we depend on.
   !
   !   When compiling under Java 1.4 these will be used to produce a full
   !   classpath that is equivalent to that generated when these are
   !   referenced as optional bundled packages by the JVM.
   !   When compiling under Java 1.5 (and probably later) this is just
   !   a simple path of these jar files, as the expansion to a full optional
   !   bundled package classpath is performed by the compiler
   !
   !   What that all means is that the manifest classpaths of these jar files
   !   are honoured, the plain compiler pre Java 1.5 didn't do that. When Java
   !   1.4 is no longer used the extclasspath type can be replaced by a simple
   !   path.
   !-->
  <extclasspath id="installed.classpath">

    <!-- Datanode -->
    <pathelement location="${star.jar.dir}/datanode/datanode.jar"/>

    <!-- AXIS -->
    <pathelement location="${star.jar.dir}/axis/axis.jar"/>

    <!-- JSky -->
    <pathelement location="${star.jar.dir}/jsky/jsky.jar"/>

    <!-- JAIUtil -->
    <pathelement location="${star.jar.dir}/jaiutil/jaiutil.jar"/>

    <!-- TOPCAT -->
    <pathelement location="${star.jar.dir}/topcat/topcat.jar"/>

    <!-- SPLAT -->
    <pathelement location="${star.jar.dir}/splat/splat.jar"/>

    <!-- SoG -->
    <pathelement location="${star.jar.dir}/sog/sog.jar"/>

  </extclasspath>

  <!-- As above
   !
   !   Exactly the same as above, but as a plain path.  Used when
   !   outputting the list of dependencies.  When and if the extclasspath
   !   above can be replaced by a plain path, or when one can be generated
   !   from the other, this should be removed.
   !-->
<!--
XXX delete
  <path id="installed.jarpath">
    <pathelement location="${star.jar.dir}/datanode/datanode.jar"/>
    <pathelement location="${star.jar.dir}/axis/axis.jar"/>
    <pathelement location="${star.jar.dir}/jsky/jsky.jar"/>
    <pathelement location="${star.jar.dir}/jaiutil/jaiutil.jar"/>
    <pathelement location="${star.jar.dir}/topcat/topcat.jar"/>
    <pathelement location="${star.jar.dir}/splat/splat.jar"/>
    <pathelement location="${star.jar.dir}/sog/sog.jar"/>
  </path>
-->

  <!-- Local build system jar files.
   !
   !   Name all the jar files of other packages that we depend on, which have
   !   not been installed (should be same packages as in installed.classpath).
   !-->
  <extclasspath id="built.jarpath">

    <pathelement
      location="${star.build.dir}/datanode/lib/datanode/datanode.jar"/>
    <pathelement
      location="${star.build.dir}/axis/lib/axis/axis.jar"/>
    <pathelement
      location="${star.build.dir}/jsky/lib/jsky/jsky.jar"/>
    <pathelement
      location="${star.build.dir}/jaiutil/lib/jaiutil/jaiutil.jar"/>
    <pathelement
      location="${star.build.dir}/topcat/lib/topcat/topcat.jar"/>
    <pathelement
      location="${star.build.dir}/splat/lib/splat/splat.jar"/>
    <pathelement
      location="${star.build.dir}/sog/lib/sog/sog.jar"/>

  </extclasspath>

  <!-- Find all local third party jars files.
   !
   !   Normally these will be kept in their own third party package, but may
   !   be kept here temporarily, say if there are version conflicts that
   !   cannot be addressed. They are installed with the package jar files and
   !   should be entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  </path>

  <!-- Create the local build system CLASSPATH.
   !
   !   Create the classpath used when building this package as part of a full
   !   build system without any dependency on any installed or external jar
   !   files.
   !
   !   Classes compiled in the local build tree will be in the "build/classes"
   !   part of each package. Third party packages, have do not have any source
   !   code, just jar files, will have their jar files in their "dist"
   !   directories (usually lib/{package_name}).
   !
   !   So the full built classpath is created by constructing a path
   !   consisting of:
   !
   !      - all third party jar files in this package
   !      - all build/classes directories in the local build system (these
   !        will have the most recent class files)
   !      - all jar files named in built.jarpath, i.e. named local build
   !        system jar files (these can be normal packages in the "dist" state
   !        or third party packages)
   !      - all jar files in the "dist" directories of all packages in the
   !        local build system (these are necessary to make sure that the jar
   !        files in the previous part have their dependencies fulfilled,
   !        without having them all installed)
   !-->
  <path id="built.classpath">

    <!-- Third party jars held by this package -->
    <path refid="package.jars"/>

    <!-- All classes in the local build system -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent jars in the local build system -->
    <path refid="built.jarpath"/>

    <!-- All "dist" jar files to make sure everything is resolved, including
     !   relative URLs of the local packages, without installation -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

  </path>

  <!-- User-defined CLASSPATH.
   !
   !   This is set by the property "extra.class.path" (which can be defined
   !   locally using say -Dextra.class.path=$CLASSPATH on the command line
   !   or by setting the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Create the full CLASSPATH used during compilation.
   !
   !   This is created from the user-defined classpath, followed by the
   !   classpath for building against the local system, followed by the
   !   classpath for building against an installed system.
   !-->
  <path id="classpath">
    <path refid="local.classpath"/>
    <path refid="built.classpath"/>
    <path refid="installed.classpath"/>
  </path>

  <!-- Create the JUnit tests CLASSPATH.
   ! 
   !   Note that in addition to the build/classes and build/tests directory
   !   we also add tests.dir and tests.etc.dir so that resources may be
   !   located there. The full classpath is also used.
   !-->  
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    ============
   !    Library path
   !    ============
   !    Used by test targets for locating native libraries.
   !-->
  <path id="tests-libpath.id">
    <pathelement path="${java.library.path}"/>
    <pathelement location="${star.jar.dir}/${os.arch}"/>
  </path>
  <property name="tests-libpath" refid="tests-libpath.id"/>

  <!--
   !    ===============
   !    Extension tasks
   !    ===============
   !    Add any local or extension ANT tasks that are required. Local
   !    tasks should be moved into the ANT package if used outside of this
   !    package. 
   !-->
  <!-- <taskdef resource="extra-tasks.properties" classpathref="classpath"/> -->

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !
   !    Minimalist check of the required dependencies so that the build will
   !    not proceed if some basic dependencies are not present on the
   !    classpath. Optional components could also be checked here.
   !-->
  <target name="check_packages"
          depends="really_check_packages"
          unless="runonly.install">

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>
  </target>

  <target name="really_check_packages"
          if="but_its_too_slow">

    <!-- Datanode -->
    <available property="datanode.present"
               classpathref="classpath"
               classname="uk.ac.starlink.datanode.nodes.DataNode"/>
    <fail message="No Datanode available" unless="datanode.present"/>

    <!-- AXIS -->
    <available property="axis.present"
               classpathref="classpath"
               classname="org.apache.axis.Message"/> 
    <fail message="No Axis available" unless="axis.present"/>

    <!-- JSky -->
    <available property="jsky.present"
               classpathref="classpath"
               classname="jsky.image.ImageProcessor"/>
    <fail message="No JSky available" unless="jsky.present"/>

    <!-- JAIUtil -->
    <available property="jaiutil.present"
               classpathref="classpath"
               classname="uk.ac.starlink.jaiutil.SimpleRenderedImage"/>
    <fail message="No JAIUtil available" unless="jaiutil.present"/>

    <!-- TOPCAT -->
    <available property="topcat.present"
               classpathref="classpath"
               classname="uk.ac.starlink.topcat.ControlWindow"/>
    <fail message="No TOPCAT available" unless="topcat.present"/>

    <!-- SPLAT -->
    <available property="splat.present"
               classpathref="classpath"
               classname="uk.ac.starlink.splat/data/SpecData"/>
    <fail message="No Splat available" unless="splat.present"/>

    <!-- Need SoG -->
    <available property="sog.present"
               classpathref="classpath"
               classname="uk.ac.starlink.sog/SOG"/>
    <fail message="No SOG available" unless="sog.present"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

  <!-- Human-readable copyright string -->
  <property name="copyright.string"
            value="Copyright &#169; 2002-${year} CCLRC: Council for the Central Laboratory of the Research Councils.  All Rights Reserved."/>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages, build_demo"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">
      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

      <include name="**/*.java"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()").
     !   Some of these must be filtered (for keyword substitution) 
     !   and others must not be. -->
    <property name="filtered.resources" value="**/build.properties"/>
    <copy todir="${build.classes}">
      <filterchain>
        <replacetokens>
          <token key="VERSION" value="${version}"/>
          <token key="DATE" value="${TODAY}"/>
          <token key="TIME" value="${TSTAMP}"/>
          <token key="BUILT_BY" value="${user.name}"/>
        </replacetokens>
      </filterchain>
      <fileset dir="${src.dir}/resources" includes="${filtered.resources}"/>
    </copy>
    <copy todir="${build.classes}">
      <fileset dir="${src.dir}/resources" excludes="${filtered.resources}"/>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>

  </target>

  <!-- 
   !   ===================
   !   Construct demo data
   !   ===================
   !-->
  <target name="build_demo">
    <property name="build.demo" value="${build.etc}/demo"/>
    <property name="src.demo" value="${src.etc}/demo"/>

    <copy todir="${build.demo}">
      <fileset dir="${src.demo}"
               excludes="**/Origins,votable/vizier.xml,zip/hello.jar"/>
    </copy>
    <gzip src="${src.demo}/votable/vizier.xml" 
          zipfile="${build.demo}/votable/vizier.xml.gz"/>

    <mkdir dir="${build.demo}/tar"/>
    <tar destfile="${build.demo}/tar/demo.tar.gz"
         compression="gzip"
         basedir="${src.etc}"
         includes="demo/fits/tables.fit,demo/votable/cover.xml,
                   demo/zip/hello.jar"/>

  </target>

  <!-- Create an MacOS X Java application bundle, using the jarbundler ant
   !   task (see http://jarbundler.sourceforge.net)
   !
   !   See http://developer.apple.com/documentation/Java/Conceptual/Java14Development/index.html if you're really interested in the gory details.
   !
   !   The jarbundler task will work only on OS X
   !-->
  <target name="build_osxapp"
          depends="build_demo,build-standalone">
    <property name="release.dir" value="release-osx"/>
    <mkdir dir="${release.dir}"/>
    <osxjarbundler dir="${release.dir}"
                   mainclass="${package.name}.Driver"
                   name="${Name}"
                   shortname="${Name}"
                   bundleid="${package.name}"
                   icon="${src.lib}/MacOS/Treeview.icns"
                   infostring="${Name} ${copyright.string}"
                   jvmversion="1.5+"
                   version="${version}"
                   jar="${dist.lib.pkg}/treeview-full.jar">

      <!-- Copy in the ppc JNI libraries -->
      <resourcefileset dir="${star.dir}/lib"
                       includes="ppc/*.jnilib"/>
      <javaproperty name="java.library.path"
                    value="$APP_PACKAGE/Contents/Resources/ppc"/>

      <!-- The first Intel Macs will appear in February/March 2006; at
       !   that point it will become necessary to add ix86/osx
       !   libraries to the bundle, and possible to test it. -->

      <!-- demo data lives in ${build.etc}/demo (see target build_demo) -->
      <resourcefileset dir="${build.etc}"
                       includes="demo/**"/>
      <javaproperty name="uk.ac.starlink.treeview.demodir"
                    value="$APP_PACKAGE/Contents/Resources/demo"/>

      <javaproperty name="uk.ac.starlink.treeview.cmdname"
                    value="treeview"/>

      <!-- Put the menus in the screen menu bar, rather than an
           application-specific one -->
      <javaproperty name="apple.laf.useScreenMenuBar" value="true"/>
    </osxjarbundler>

    <!-- Copy the docs into the release directory (anything else?) -->
    <copy todir="${release.dir}">
      <fileset dir="${dist.docs}"/>
    </copy>

    <!-- Create a .dmg file containing the app and docs -->
    <exec executable="/usr/bin/hdiutil" os="Mac OS X">
      <arg value="create"/>
      <arg value="-srcfolder"/>
      <arg value="${release.dir}"/>
      <arg value="-volname"/>
      <arg value="${Name} ${version}"/>
      <arg value="-ov"/>
      <arg value="${Name}-${version}.dmg"/>
    </exec>
  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs) on and
   !  defines the application entrance point. The jar files should be
   !  placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <!-- Main Treeview jar file -->
    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Main-Class" value="uk.ac.starlink.treeview.Driver"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
      <exclude name="**/.*"/>
    </jar>

    <!-- Jar files for other commands. -->
    <jar destfile="${dist.lib.pkg}/showndx.jar">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Main-Class" 
                   value="uk.ac.starlink.treeview.NdxDisplayer"/>
        <attribute name="Class-Path" value="treeview.jar"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib}">
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
        <exclude name="**/showndx.jar"/>
      </fileset>
    </signjar>

  </target>

  <!--
   !   ==========================
   !   Build standalone jar files
   !   ==========================
   !
   !  Builds a jar file which can be used on its own, without needing any
   !  other jars to be present. (patterned after the similar target in TopCat)
   !-->
  <target name="build-standalone"
          depends="install"
          description="-> builds a standalone jar file">
    <java classname="uk.ac.starlink.util.SuperJar" failonerror="yes">
      <classpath refid="classpath"/>
      <arg value="-o"/><arg value="${dist.lib.pkg}/treeview-full.jar"/>
      <arg value="-x"/><arg value="junit.jar"/>
      <arg value="-x"/><arg value="log4j.jar"/>
      <arg value="-x"/><arg value="log4j-core.jar"/>
      <arg value="-x"/><arg value="jsky/jel.jar"/>
      <arg value="-x"/><arg value="diva/acme.jar"/>
      <arg value="-x"/><arg value="splat.jar"/>
      <arg value="-x"/><arg value="gsi-classes.jar"/>
      <arg value="${star.lib.pkg}/treeview.jar"/>
    </java>
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib.pkg}"
               includes="treeview-full.jar"/>
    </signjar>
  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this application. 
     !   This goes into "dist.lib" 
     !-->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">

      <information>
         <title>Treeview - tool for displaying hierarchical structures</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>Starlink Treeview - Webstart edition</description>
         <offline_allowed/>
       </information>

       <security>
          <all_permissions/>
       </security>

       <resources>
         <j2se version="1.5+"/>

         <!-- The application main jar file -->
         <jar href="${name}/${name}.jar"/>

         <!-- Other library packages used by this application -->
         <extension name="DATANODE" href="datanode.jnlp"/>
         <extension name="AXIS" href="axis.jnlp"/>

         <!-- Other applications that this application uses. Note
          !   these shouuld not normally be named in the "parts"
          !   component to avoid the possibility of circular
          !   dependencies -->
         <extension name="TOPCAT-PARTS" href="topcat-parts.jnlp"/>
         <extension name="SPLAT-PARTS" href="splat-parts.jnlp"/>
         <extension name="SOG-PARTS" href="sog-parts.jnlp"/>
       </resources>

       <!-- This an an application JNLP file. -->
       <application_desc main_class="uk.ac.starlink.treeview.Driver"/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin.pkg}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <mkdir dir="${dist.etc.pkg}"/>

    <!-- Copy any startup scripts etc. -->
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>

    <!-- Copy auxiliary files. -->
    <copy todir="${dist.etc.pkg}">
      <fileset dir="${build.etc}"/>
    </copy>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">
      <exclude name="**/.*"/>

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">
      <exclude name="**/.*"/>

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

    <!-- The following are magic names, deleting products built only on OS X:
     !   they probably ought to be synchronised better with
     !   target build_osxapp.
     ! -->
    <delete dir="release-osx" quiet="true"/>
    <delete file="${Name}-${version}.dmg" quiet="true"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin.pkg}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.etc.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <!-- this is a temporary measure to clean up the directory dist.bin.pkg;
     !   it now wants to be a file and can't copy the file over if it's 
     !   still a directory. -->
    <delete dir="${star.bin}/${name}" failonerror="false"/>

    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory
     !   (note exact format required) -->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

    <loggedcopy todir="${star.etc}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.etc}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.etc.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <mkdir dir="${dist.etc.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
         <exclude name="**/.*"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom>${copyright.string}</bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html">
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !
   !  Application packages should only make public those parts of
   !  their internal APIs that they are prepared to support. Consider
   !  adding such code to proper class libraries (such as util).
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
          <exclude name="**/.*"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="install, compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="ant.basedir" value="${basedir}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="install, compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="ant.basedir" value="${basedir}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <target name="fullui"
          depends="compile-tests">

    <!-- Run up Treeview from the local build, setup to be debugged
     !   from socket -->
    <java classname="uk.ac.starlink.treeview.Driver" fork="true">
      <classpath refid="tests-classpath"/>
      <jvmarg value="-Djava.library.path=${tests-libpath}"/>
      <jvmarg value="-Duk.ac.starlink.treeview.cmdname=treeview"/>
      <jvmarg value="-Duk.ac.starlink.treeview.demodir=${src.etc}/demo"/>
      <jvmarg value="-Xdebug"/>
      <jvmarg value="-Xnoagent"/>
      <jvmarg value="-Djava.compiler=NONE"/>
      <jvmarg value="-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=7002"/>
    </java>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!-- Ant build file for toy 'Hello World' java package. -->

<project name="hello" default="build" basedir=".">

  <property name="package.name" value="hello"/>

  <target name="build" 
          description="-> builds the package and export files">

    <javac srcdir="${basedir}"
           destdir="${basedir}"/>

    <jar destfile="${package.name}.jar" 
         basedir="${basedir}">
      <exclude name="**/.*"/>
      <exclude name="*.jar"/>
      <exclude name="*.zip"/>
      <exclude name="build.xml"/>
      <manifest>
        <attribute name="Main-Class" value="uk.ac.starlink.hello.HelloWorld"/>
      </manifest>
    </jar>

    <zip destfile="${package.name}_src.zip"
         basedir="${basedir}">
      <exclude name="**/.*"/>
      <exclude name="**/*.class"/>
      <exclude name="*.jar"/>
      <exclude name="*.zip"/>
    </zip>
    
  </target>

  <target name="test" 
          depends="build"
          description="-> Runs a test of the package">
    <java fork="true" jar="${package.name}.jar"/>
  </target>

  <target name="clean"
          description="-> Removes all built and intermediate files">
    <delete>
      <fileset dir="${basedir}">
        <include name="**/*.class"/>
        <include name="${package.name}.jar"/>
        <include name="${package.name}_src.zip"/>
      </fileset>
    </delete>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   TTOOLS build file
 !
 !   This file describes how to build and install TTOOLS
 !   from a source and binary release. TTOOLS is an application
 !   package, i.e. provides user-level commands and interfaces, as
 !   well as an optional programming API.
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for TTOOLS" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="TTOOLS"/>
  <property name="name" value="ttools"/>
  <property name="version" value="2.5-2+"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.ttools"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.5"/>

  <!-- JVM binary to use for certain forked tasks.  This may be different
   !   from that used to run ant.  This is a bit of a hack; in some
   !   cases we want to run the build on a 1.5 JDK to generate Java1.5 classes,
   !   but 1.6 needs to be used for some documentation tasks to avoid
   !   1.5-specific xerces bugs.  An alternative approach would be
   !   cross-compilation of all packages. -->
  <property name="alt.java" value="java"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="true"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>
  <property name="src.docs.examp" value="${src.docs}/examp"/>
  <property name="user.doc" value="sun256"/>
  <property name="coverimage" value="ttools2.gif"/>
  <property name="xdoc.etc" value="${star.dir}/etc/xdoc"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files"
            value="**/*.gif,**/*.jpg,**/*.jpeg,**/*.ico,**/*.png,**/*.eps*"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.javadocs" value="${build.dir}/javadocs"/>
  <property name="build.docs" value="${build.dir}/docs"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.etc" value="${build.dir}/etc"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase"
           value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Installed jar files.
   !
   !   Name all the installed jar files of other packages that we depend on.
   !
   !   When compiling under Java 1.4 these will be used to produce a full
   !   classpath that is equivalent to that generated when these are
   !   referenced as optional bundled packages by the JVM.
   !   When compiling under Java 1.5 (and probably later) this is just
   !   a simple path of these jar files, as the expansion to a full optional
   !   bundled package classpath is performed by the compiler
   !
   !   What that all means is that the manifest classpaths of these jar files
   !   are honoured, the plain compiler pre Java 1.5 didn't do that. When Java
   !   1.4 is no longer used the extclasspath type can be replaced by a simple
   !   path.
   !-->
  <extclasspath id="installed.classpath">

    <!-- UTIL -->
    <pathelement location="${star.jar.dir}/util/util.jar"/>

    <!-- TABLE -->
    <pathelement location="${star.jar.dir}/table/table.jar"/>

    <!-- FITS -->
    <pathelement location="${star.jar.dir}/fits/fits.jar"/>

    <!-- VOTABLE -->
    <pathelement location="${star.jar.dir}/votable/votable.jar"/>

  </extclasspath>

  <!-- Local build system jar files.
   !
   !   Name all the jar files of other packages that we depend on, which have
   !   not been installed (should be same packages as in installed.classpath).
   !-->
  <extclasspath id="built.jarpath">

    <pathelement location="${star.build.dir}/util/lib/util/util.jar"/>
    <pathelement location="${star.build.dir}/table/lib/table/table.jar"/>
  </extclasspath>

  <!-- Find all local third party jars files.
   !
   !   Normally these will be kept in their own third party package, but may
   !   be kept here temporarily, say if there are version conflicts that
   !   cannot be addressed. They are installed with the package jar files and
   !   should be entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  </path>

  <!-- Create the local build system CLASSPATH.
   !
   !   Create the classpath used when building this package as part of a full
   !   build system without any dependency on any installed or external jar
   !   files.
   !
   !   Classes compiled in the local build tree will be in the "build/classes"
   !   part of each package. Third party packages, have do not have any source
   !   code, just jar files, will have their jar files in their "dist"
   !   directories (usually lib/{package_name}).
   !
   !   So the full built classpath is created by constructing a path
   !   consisting of:
   !
   !      - all third party jar files in this package
   !      - all build/classes directories in the local build system (these
   !        will have the most recent class files)
   !      - all jar files named in built.jarpath, i.e. named local build
   !        system jar files (these can be normal packages in the "dist" state
   !        or third party packages)
   !      - all jar files in the "dist" directories of all packages in the
   !        local build system (these are necessary to make sure that the jar
   !        files in the previous part have their dependencies fulfilled,
   !        without having them all installed)
   !-->
  <path id="built.classpath">

    <!-- Third party jars held by this package -->
    <path refid="package.jars"/>

    <!-- All classes in the local build system -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent jars in the local build system -->
    <path refid="built.jarpath"/>

    <!-- All "dist" jar files to make sure everything is resolved, including
     !   relative URLs of the local packages, without installation -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

  </path>

  <!-- User-defined CLASSPATH.
   !
   !   This is set by the property "extra.class.path" (which can be defined
   !   locally using say -Dextra.class.path=$CLASSPATH on the command line
   !   or by setting the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Create the full CLASSPATH used during compilation.
   !
   !   This is created from the user-defined classpath, followed by the
   !   classpath for building against the local system, followed by the
   !   classpath for building against an installed system.
   !-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- Create the JUnit tests CLASSPATH.
   !
   !   Note that in addition to the build/classes and build/tests directory
   !   we also add tests.dir and tests.etc.dir so that resources may be
   !   located there. The full classpath is also used.
   !-->
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <pathelement location="${build.etc}"/>
    <fileset dir="src/testlib" includes="*.jar"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    ============
   !    Library path
   !    ============
   !    Used by test targets for locating native libraries.
   !-->
  <path id="tests-libpath.id">
    <pathelement path="${java.library.path}"/>
    <pathelement location="${star.jar.dir}/${os.arch}"/>
  </path>
  <property name="tests-libpath" refid="tests-libpath.id"/>

  <!--
   !    ===============
   !    Extension tasks
   !    ===============
   !    Add any local or extension ANT tasks that are required. Local
   !    tasks should be moved into the ANT package if used outside of this
   !    package.
   !-->
  <!-- <taskdef resource="extra-tasks.properties" classpathref="classpath"/> -->

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !
   !    Minimalist check of the required dependencies so that the build will
   !    not proceed if some basic dependencies are not present on the
   !    classpath. Optional components could also be checked here.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!-- UTIL -->
    <available property="util.present"
               classpathref="classpath"
               classname="uk.ac.starlink.util.DataSource"/>
    <fail message="No UTIL available" unless="util.present"/>

    <!-- TABLE -->
    <available property="table.present"
               classpathref="classpath"
               classname="uk.ac.starlink.table.StarTable"/>
    <fail message="No TABLE available" unless="table.present"/>

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
      <include name="**/*.java"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${src.dir}/resources"/>
    </copy>

    <!-- Write the package version number to a file. -->
    <echo file="${build.classes}/uk/ac/starlink/ttools/stilts.version"
          message="${version}"/>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>

    <!-- Call target to do time-consuming build of additional components;
     !   first check that they are not already in place. -->
    <condition property="extras.built">
      <and>
        <uptodate targetfile="${build.javadocs}/uk/ac/starlink/ttools/func">
          <srcfiles dir="${java.dir}/uk/ac/starlink/ttools/func"/>
        </uptodate>
        <uptodate targetfile="${build.etc}/stilts.py">
          <srcfiles dir="${java.dir}"/>
        </uptodate>
      </and>
    </condition>
    <antcall target="build-extras"/>

  </target>

  <!-- Sub-target to perform time-consuming build of additional components
   !   in build phase; unless attribute allows it to be skipped. -->
  <target name="build-extras" unless="extras.built">

    <!-- Construct HTML documentation for JEL-accessible classes. -->
    <mkdir dir="${build.javadocs}"/>
    <javadoc doclet="uk.ac.starlink.ttools.build.HtmlDoclet"
             docletpathref="classpath"
             failonerror="true"
             public="true"
             additionalparam="-headings"
             destdir="${build.javadocs}"
             sourcepath="${java.dir}"
             packagenames="uk.ac.starlink.ttools.func"
             classpathref="classpath"
             source="${source.version}"/>

    <!-- Write and compile JyStilts module source code. -->
    <echo message="Generating stilts.py"/>
    <mkdir dir="${build.etc}"/>
    <java classname="uk.ac.starlink.ttools.build.JyStilts"
          output="${build.etc}/stilts.py"
          failonerror="yes"
          fork="true"
          logerror="yes">
      <classpath refid="classpath"/>
      <sysproperty key="java.awt.headless" value="true"/>
    </java>

    <!-- Write LaTeX fonts resource list. -->
    <echo message="Assembling list of LaTeX fonts"/>
    <mkdir dir="${build.classes}/uk/ac/starlink/ttools/plot2"/>
    <java classname="uk.ac.starlink.ttools.plot.ExternalFontMapper"
          output="${build.classes}/uk/ac/starlink/ttools/plot2/latex_fonts.txt"
          failonerror="yes"
          fork="true"
          logerror="yes">
      <classpath refid="classpath"/>
      <sysproperty key="java.awt.headless" value="true"/>
      <arg value="${src.jars.dir}/jlatexmath.jar"/>
    </java>
  </target>

  <target name="build-standalone" depends="install">

    <!-- Build temporary zip file containing things not in the input jars
     !   which ought to be included in the standalone jars. -->
    <exec outputproperty="gitversion"
          logerror="true"
          executable="${star.dir}/bin/gitversion"/>
    <echo message="${gitversion}"
          file="${build.classes}/uk/ac/starlink/ttools/revision-string"/>
    <zip destfile="${dist.lib.pkg}/stilts-version.zip">
      <fileset dir="${build.classes}"
               includes="uk/ac/starlink/ttools/revision-string"/>
    </zip>
    <delete file="${build.classes}/uk/ac/starlink/ttools/revision-string"/>

    <java classname="uk.ac.starlink.util.SuperJar" failonerror="yes">
      <classpath refid="classpath"/>
      <arg value="-oj"/><arg value="${dist.lib.pkg}/stilts.jar"/>
      <arg value="-oz"/><arg value="${dist.lib.pkg}/stilts_jars.zip"/>
      <arg value="-xjar"/><arg value="junit.jar"/>
      <arg value="-xjar"/><arg value="array.jar"/>
      <arg value="-xjar"/><arg value="jniast.jar"/>
      <arg value="-xjar"/><arg value="hdx.jar"/>
      <arg value="-xjar"/><arg value="ndx.jar"/>
      <arg value="-xjar"/><arg value="topcat.jar"/>
      <arg value="-xjar"/><arg value="org.mortbay.jmx.jar"/>
      <arg value="-xjar"/><arg value="jasper-combined.jar"/>
      <arg value="-file"/><arg value="${star.bin}/stilts"/>
      <arg value="-file"/><arg value="${star.build.dir}/src/etc/LICENCE.txt"/>
      <arg value="-file"/><arg value="${star.docs.pkg}/README.cea"/>
      <arg value="-file"/><arg value="${star.etc.pkg}/stilts.py"/>
      <arg value="${star.lib.pkg}/stilts-app.jar"/>
      <arg value="${dist.lib.pkg}/stilts-version.zip"/>
    </java>
    <delete file="${dist.lib.pkg}/stilts-version.zip"/>
  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs) on and
   !  defines the application entrance point. The jar files should be
   !  placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <!-- Create the library jar file, ttools.jar. -->
    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar">
      <fileset dir="${build.classes}"/>
      <fileset dir="${build.javadocs}"/>
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Also create a jar file which can be used to invoke the STILTS 
     !   application.  As well as a Main-Class, this wants a reference
     !   to the TOPCAT jar file, so that tpipe's topcat output mode can
     !   start up TOPCAT when required.  If you try to put topcat.jar
     !   in the Class-Path entry of the ttools.jar file, it causes part
     !   of the build (or at least the test) to blow up with recursive
     !   classpath trouble, so this jar file contains nothing but a
     !   manifest. -->
    <jar destfile="${dist.lib.pkg}/stilts-app.jar" excludes="**">
      <manifest> 
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${name}.jar ../topcat/topcat.jar"/>
        <attribute name="Main-Class" value="uk.ac.starlink.ttools.Stilts"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib}"
               includes="**/*.jar **/*.zip"
               excludes="**/stilts.jar **/stilts-app.jar **/stilts_jars.zip"/>
    </signjar>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !
   ! The webstart setup for an application requires that it have two
   ! JNLP files. One to describe it as an application and one as a component.
   ! The component form is required if another application wants to use
   ! this application, either directly (by embedding) or just as a
   ! dependency (for contact via webservices). These two functions cannot be
   ! performed in the same two JNLP files.
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this application as a component, 
     !   so that may be used by other applications. This goes into "dist.lib".
     !-->
     <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">

      <information>
         <title>TTOOLS - auxiliary table manipulation utilities</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>Starlink TTOOLS - Webstart edition</description>
         <offline_allowed/>
       </information>

       <security>
          <all_permissions/>
       </security>

       <resources>
         <j2se version="1.5+"/>

         <!-- All jar files of this application -->
         <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"
                  excludes="**/stilts.jar **/stilts-app.jar
                            **/stilts_jars.zip"/>

         <!-- Components that this component depends on (non applications
          !   named in the application jar file class-path). -->
         <extension name="TABLE" href="table.jnlp"/>
         <extension name="TAMFITS" href="tamfits.jnlp"/>
         <extension name="FITS" href="fits.jnlp"/>
         <extension name="MIRAGE" href="mirage.jnlp"/>
         <extension name="VOTABLE" href="votable.jnlp"/>
         <extension name="TASK" href="task.jnlp"/>
         <extension name="VO" href="vo.jnlp"/>
         <extension name="PAL" href="pal.jnlp"/>
         <extension name="PLASTIC" href="plastic.jnlp"/>
       </resources>

       <!-- This is a component -->
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,docs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin.pkg}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <mkdir dir="${dist.etc.pkg}"/>

    <!-- Copy any startup scripts etc. -->
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}" excludes="*.template"/>
    </copy>

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${build.docs}"
               includes="${user.doc}/* *.pdf README.*"/>
    </copy>

    <!-- Copy extra files. -->
    <copy todir="${dist.etc.pkg}">
      <fileset dir="${build.etc}"/>
    </copy>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}" maxparallel="50"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}" maxparallel="50"/>
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}"
           maxparallel="50">
       <fileset dir="${dist.bin}"/>
    </chmod>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin.pkg}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.etc.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.etc}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.etc}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.etc.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <mkdir dir="${dist.etc.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             failonerror="yes"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
         <exclude name="uk/ac/starlink/ttools/build"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <!-- Cope with custom tags. -->
      <tag name="example" 
           description="Examples:"
           scope="methods, fields"
           enabled="true"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html">
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =================================================
   !   Creates additional documentation from XML sources
   !   =================================================
   !
   !   The XML user document is downconverted to PDF and single- 
   !   and multiple-file HTML versions in the docs directory.
   !-->
  <target name="docs"
          depends="build, docs_check"
          unless="docs.notrequired"
          description="-> creates the user documentation">

    <!-- Make destination directory for built files. -->
    <mkdir dir="${build.docs}"/>

    <!-- Copy required source files there. -->
    <copy todir="${build.docs}">
      <fileset dir="${src.docs}" includes="${user.doc}.xml"/>
      <fileset dir="${xdoc.etc}" includes="docs.dtd"/>
      <fileset dir="${src.docs}" includes="README.*"/>
      <fileset dir="${src.docs.examp}" includes="*.xml"/>
    </copy>
    <copy todir="${build.docs}/${user.doc}">
      <fileset dir="${src.docs.examp}"
               includesfile="${src.docs.examp}/plot-example-files.txt"/>
    </copy>

    <!-- Construct XML documentation for the JEL-accessible classes.
     !   This is built using Javadoc, and forms part of the user document. -->
    <javadoc doclet="uk.ac.starlink.ttools.build.FullXmlDoclet"
             docletpathref="classpath"
             failonerror="true"
             public="true"
             additionalparam="-o ${build.docs}/jel-javadocs.xml"
             sourcepath="${java.dir}"
             packagenames="uk.ac.starlink.ttools.func"
             classpathref="classpath"
             source="${source.version}"/>

    <!-- Write an XML file containing usage output for some actual
     !   command invocations. -->
    <java classname="uk.ac.starlink.ttools.build.OutputCapture"
          failonerror="yes"
          fork="no"
          output="${build.docs}/stilts-usage.xml"
          logerror="yes"
          classpathref="classpath">
      <arg value="uk.ac.starlink.ttools.Stilts"/>
      <arg value="-help"/>
    </java>
    <java classname="uk.ac.starlink.ttools.build.OutputCapture"
          failonerror="yes"
          fork="no"
          output="${build.docs}/tcopy-usage.xml"
          logerror="yes"
          classpathref="classpath">
      <arg value="uk.ac.starlink.ttools.Stilts"/>
      <arg value="tcopy"/>
      <arg value="help"/>
    </java>
    <!-- fork="yes" required below else ant confuses JAXP -->
    <java classname="uk.ac.starlink.ttools.build.OutputCapture"
          failonerror="yes"
          fork="yes"
          output="${build.docs}/tcopy-in-usage.xml"
          logerror="yes"
          classpathref="classpath">
      <arg value="uk.ac.starlink.ttools.Stilts"/>
      <arg value="tcopy"/>
      <arg value="help=in"/>
    </java>

    <!-- Write XML files containing per-task usage information
     !   for inclusion in the user document. -->
    <java classname="uk.ac.starlink.ttools.build.PurposeWriter"
          failonerror="yes"
          output="${build.docs}/purpose-defs.xml"
          logerror="yes"
          fork="yes"
          classpathref="classpath">
      <sysproperty key="java.awt.headless" value="true"/>
    </java>
    <java classname="uk.ac.starlink.ttools.build.UsageWriter"
          failonerror="yes"
          fork="yes"
          dir="${build.docs}"
          classpathref="classpath">
      <sysproperty key="java.awt.headless" value="true"/>
    </java>
    <java classname="uk.ac.starlink.ttools.build.FilterDoc"
          failonerror="yes"
          output="${build.docs}/filter-docs.xml"
          logerror="yes"
          classpathref="classpath"/>
    <java classname="uk.ac.starlink.ttools.build.ModeDoc"
          failonerror="yes"
          output="${build.docs}/mode-docs.xml"
          logerror="yes"
          classpathref="classpath"/>
    <java classname="uk.ac.starlink.ttools.build.PaintModeDoc"
          failonerror="yes"
          output="${build.docs}/paintmode-docs.xml"
          logerror="yes"
          classpathref="classpath">
      <sysproperty key="java.awt.headless" value="true"/>
    </java>

    <!-- Write XML files containing MatchEngine usage information
     !   for inclusion in the user document. -->
    <java classname="uk.ac.starlink.ttools.build.MatcherUsage"
          failonerror="yes"
          fork="yes"
          dir="${build.docs}"
          classpathref="classpath">
      <arg value="sky"/>
      <arg value="skyerr"/>
      <arg value="skyellipse"/>
      <arg value="sky3d"/>
      <arg value="exact"/>
      <arg value="1d"/>
      <arg value="2d"/>
      <arg value="2d_anisotropic"/>
      <arg value="2d_cuboid"/>
      <arg value="2d_err"/>
      <arg value="2d_ellipse"/>
      <arg value="sky+1d"/>
    </java>

    <!-- Transform the user document XML to a single HTML document. -->
    <mkdir dir="${build.docs}/${user.doc}"/>
    <copy todir="${build.docs}/${user.doc}">
      <fileset dir="${src.docs}" includes="${coverimage}"/>
      <fileset dir="${xdoc.etc}" includes="sun-style.css"/>
    </copy>
    <xslt in="${build.docs}/${user.doc}.xml"
          out="${build.docs}/${user.doc}/${user.doc}.html"
          style="${xdoc.etc}/toHTML1.xslt">
      <param name="VERSION" expression="${version}"/>
      <param name="BASEDIR" expression="${build.docs}/${user.doc}"/>
      <param name="COVERIMAGE" expression="${coverimage}"/>
      <param name="CSS_HREF" expression="sun-style.css"/>
    </xslt>

    <!-- Transform the user document to a multi-page HTML document. -->
    <java classpathref="classpath"
          dir="${src.docs}"
          classname="uk.ac.starlink.xdoc.MultiXML"
          failonerror="yes"
          fork="yes"
          jvm="${alt.java}">
      <sysproperty key="java.awt.headless" value="true"/>
      <arg value="-style"/> <arg value="${xdoc.etc}/toHTML.xslt"/>
      <arg value="-param"/> <arg value="VERSION=${version}"/>
      <arg value="-param"/> <arg value="BASEDIR=${build.docs}/${user.doc}"/>
      <arg value="-param"/> <arg value="COVERIMAGE=${coverimage}"/>
      <arg value="-param"/> <arg value="CSS_HREF=sun-style.css"/>
      <arg value="${build.docs}/${user.doc}.xml"/>
      <arg value="${build.docs}/${user.doc}"/>
    </java>

    <!-- Transform the user document XML to a PDF document via XSL-FO. -->
    <xslt in="${build.docs}/${user.doc}.xml"
          out="${build.docs}/${user.doc}.fo"
          style="${xdoc.etc}/toFo.xslt">
      <param name="VERSION" expression="${version}"/>
      <param name="BASEDIR" expression="${build.docs}/${user.doc}"/>
      <param name="COVERIMAGE" expression="${coverimage}"/>
    </xslt>
    <java classname="org.apache.fop.apps.Fop"
          failonerror="yes"
          fork="yes">
      <classpath>
        <fileset dir="${star.jar.dir}/xdoc" includes="*.jar"/>
      </classpath>
      <sysproperty key="java.awt.headless" value="true"/>
      <arg value="-q"/>
      <arg value="-fo"/> <arg value="${build.docs}/${user.doc}.fo"/>
      <arg value="-pdf"/> <arg value="${build.docs}/${user.doc}.pdf"/>
    </java>
  </target>

  <!-- Checks whether the docs build is up to date. -->
  <target name="docs_check" unless="docs.notrequired">
    <uptodate property="docs.notrequired"
              srcfile="${src.docs}/${user.doc}.xml"
              targetfile="${build.docs}/${user.doc}/${user.doc}.html"/>
  </target>

  <!--
   !   =======================
   !   Generates example plots
   !   =======================
   !
   !   This target is not called by any of the standard targets, but may
   !   be invoked by hand to write example plot files and associated
   !   descriptions into the source tree.  This approach may be changed
   !   at a later date, but for now it's more convenient than generating
   !   these plots at build time, since (a) the plotting is somewhat
   !   time-consuming and (b) some input datasets are large (not ideal for 
   !   checking into source archive).
   !-->
  <target name="plot-examples"
          description="-> generate example text and graphics for plot commands "
          depends="build">
    <echo message="Writing plot example files to source dir ${src.docs.examp}"/>
    <java classpathref="classpath"
          dir="${src.docs.examp}"
          classname="uk.ac.starlink.ttools.build.PlotExample"
          failonerror="yes"
          fork="yes">
      <sysproperty key="java.awt.headless" value="true"/>
    </java>
  </target>


  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !
   !  Application packages should only make public those parts of
   !  their internal APIs that they are prepared to support. Consider
   !  adding such code to proper class libraries (such as util).
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <sysproperty key="tests.withnet" value="${tests.withnet}"/>
      <sysproperty key="basedir" value="${basedir}"/>
      <sysproperty key="xdoc.etc" value="${xdoc.etc}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test.java"/>
          <exclude name="**/net_tests/*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <!--
   !   =================
   !   Run network tests
   !   =================
   !-->
  <target name="run-net-tests"
          depends="compile-tests"
          if="junit.present"
          description="-> run network-dependent JUnit tests">
    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <formatter type="brief" usefile="false"/>
      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/net_tests/*Test.java"/>
        </fileset>
      </batchtest>
    </junit>
  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <sysproperty key="tests.withnet" value="${tests.withnet}"/>
      <sysproperty key="basedir" value="${basedir}"/>
      <sysproperty key="xdoc.etc" value="${xdoc.etc}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !  UTIL build file
 !
 !   This file describes how to build the UTIL package from a source
 !   release. It requires Apache ANT and a Java Development Kit.
 !
 !   In addition UTIL may have requirements for other "core" and
 !   "third-party" packages to complete the compilation and any
 !   testing.
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> install a runonly distribution into Starlink tree
 !      jars             -> creates the package jar file
 !      javadocs         -> creates the API documentation
 !      javadoc-sources  -> does nothing
 !      uitest           -> run up any user interface tests
 !      test             -> run JUnit tests
 !
 !   Authors:
 !      Peter W. Draper (2-JUL-2002)
 !      Mark Taylor (13-AUG-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for UTIL" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="UTIL"/>
  <property name="name" value="util"/>
  <property name="version" value="1.0"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.util"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.5"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="true"/>
  <property name="junit.filtertrace" value="off"/>
  <property name="junit.summary" value="no"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing miscellaneous files -->
  <property name="src.etc" value="${src.dir}/etc"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- JUnit -->
    <pathelement location="${star.jar.dir}/junit/junit.jar"/>

  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">
    <pathelement location="${star.build.dir}/junit/lib/junit/junit.jar"/>
  </extclasspath>

  <!-- "Local" third party jars. 
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property
   !   "extra.class.path" (which can be defined locally using say
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
    <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath -->
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!--  Need JUnit -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

    <fail message="No JUnit available" unless="junit.present"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images) should also be copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

      <!-- Exclude any Java files in the source tree that should not be
       !   compiled -->
      <exclude name="**/NdxDomImpl.java"/>
      <exclude name="**/README*"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/images/*"/>
        <include name="**/text/*"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs) on and, if
   !  appropriate, defines the application entrance point. The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
       <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
    </signjar>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>UTIL - utility classes</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink UTIL - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin}"/>
    <mkdir dir="${dist.etc}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Copy any scripts. Note for "util" these can be found in the
     !   "bin" directory, not just the package bin. -->
    <copy todir="${dist.bin}">
      <fileset dir="${script.dir}/" />
    </copy>

    <!-- Copy etc files. These go directly into the "etc" directory too. -->
    <copy todir="${dist.etc}">
      <fileset dir="${src.etc}/" />
    </copy>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>
    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

   <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.bin.pkg}
</echo>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.etc}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.etc}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.etc.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

    <!-- Make sure that the expected file structure exists, some
         of these files can be missing if originally empty -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Do normal install, but with many targets switched off-->
    <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}" failonerror="false"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  The documentation is created from the Java sources. Should also
   !  extend this to include the possibility of other miscellaneous
   !  documentation (FAQs etc.).
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">
    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>
  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/support/*"/>
          <exclude name="**/makefile"/>
          <exclude name="**/testcases/*"/>
          <exclude name="**/VERSION"/>
          <exclude name="**/README"/>
          <exclude name="**/.*"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">
    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >
      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="tests-classpath"/>
    </javac>
  </target>


  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <jvmarg value="-enableassertions"/>
      <classpath refid="tests-classpath"/>

      <sysproperty key="java.io.tmpdir" value="${build.tests}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="plain" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test.java"/>
        </fileset>
      </batchtest>

    </junit>
  </target>


  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">
      <jvmarg value="-enableassertions"/>
      <sysproperty key="java.io.tmpfile" value="${build.tests}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>
    </junit>
  </target>

  <!--
   !  =====================
   !  Run non-JUnit UI test
   !  =====================
   ! 
   ! Use this to test interaction with a UI.
   !-->
  <target name="uitest"
          depends="compile-tests"
          description="Run up UIs for testing">

    <java classname="TestProxySetupFrame" fork="true">
      <classpath refid="tests-classpath"/>
    </java>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   VO build file
 !
 !   This file describes how to build and install VO from
 !   source and binary releases. VO is a class library
 !   (i.e. provides an API and related documentation).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for VO" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!-- Web proxy configuration, you will usually override these in
   !   ~/.stardev.properties or .properties -->
  <property name="http.proxyPort" value="8080"/>
  <property name="http.proxyHost" value=""/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="VO"/>
  <property name="name" value="vo"/>
  <property name="version" value="0.2"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.vo"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.5"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Any achitecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase"
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Installed jar files.
   !
   !   Name all the installed jar files of other packages that we depend on.
   !
   !   When compiling under Java 1.4 these will be used to produce a full
   !   classpath that is equivalent to that generated when these are
   !   referenced as optional bundled packages by the JVM.
   !   When compiling under Java 1.5 (and probably later) this is just
   !   a simple path of these jar files, as the expansion to a full optional
   !   bundled package classpath is performed by the compiler
   !
   !   What that all means is that the manifest classpaths of these jar files
   !   are honoured, the plain compiler pre Java 1.5 didn't do that. When Java
   !   1.4 is no longer used the extclasspath type can be replaced by a simple
   !   path.
   !-->
  <extclasspath id="installed.classpath">

    <pathelement location="${star.jar.dir}/axis/axis.jar"/>
    <pathelement location="${star.jar.dir}/util/util.jar"/>
    <pathelement location="${star.jar.dir}/table/table.jar"/>
    <pathelement location="${star.jar.dir}/votable/votable.jar"/>

  </extclasspath>

  <!-- Local build system jar files.
   !
   !   Name all the jar files of other packages that we depend on, which have
   !   not been installed (should be same packages as in installed.classpath).
   !-->
  <extclasspath id="built.jarpath">

    <pathelement location="${star.build.dir}/axis/lib/axis/axis.jar"/>
    <pathelement location="${star.build.dir}/util/lib/util/util.jar"/>
    <pathelement location="${star.build.dir}/table/lib/table/table.jar"/>
    <pathelement location="${star.build.dir}/votable/lib/votable/votable.jar"/>

  </extclasspath>

  <!-- Find all local third party jars files.
   !
   !   Normally these will be kept in their own third party package, but may
   !   be kept here temporarily, say if there are version conflicts that
   !   cannot be addressed. They are installed with the package jar files and
   !   should be entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  </path>

  <!-- Create the local build system CLASSPATH.
   !
   !   Create the classpath used when building this package as part of a full
   !   build system without any dependency on any installed or external jar
   !   files.
   !
   !   Classes compiled in the local build tree will be in the "build/classes"
   !   part of each package. Third party packages, have do not have any source
   !   code, just jar files, will have their jar files in their "dist"
   !   directories (usually lib/{package_name}).
   !
   !   So the full built classpath is created by constructing a path
   !   consisting of:
   !
   !      - all third party jar files in this package
   !      - all build/classes directories in the local build system (these
   !        will have the most recent class files)
   !      - all jar files named in built.jarpath, i.e. named local build
   !        system jar files (these can be normal packages in the "dist" state
   !        or third party packages)
   !      - all jar files in the "dist" directories of all packages in the
   !        local build system (these are necessary to make sure that the jar
   !        files in the previous part have their dependencies fulfilled,
   !        without having them all installed)
   !-->
  <path id="built.classpath">

    <!-- Third party jars held by this package -->
    <path refid="package.jars"/>

    <!-- All classes in the local build system -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent jars in the local build system -->
    <path refid="built.jarpath"/>

    <!-- All "dist" jar files to make sure everything is resolved, including
     !   relative URLs of the local packages, without installation -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

  </path>

  <!-- User-defined CLASSPATH.
   !
   !   This is set by the property "extra.class.path" (which can be defined
   !   locally using say -Dextra.class.path=$CLASSPATH on the command line
   !   or by setting the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Create the full CLASSPATH used during compilation.
   !
   !   This is created from the user-defined classpath, followed by the
   !   classpath for building against the local system, followed by the
   !   classpath for building against an installed system.
   !-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- Create the JUnit tests CLASSPATH.
   ! 
   !   Note that in addition to the build/classes and build/tests directory
   !   we also add tests.dir and tests.etc.dir so that resources may be
   !   located there. The full classpath is also used.
   !-->  
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    ============
   !    Library path
   !    ============
   !    Used by test targets for locating native libraries.
   !-->
  <path id="tests-libpath.id">
    <pathelement path="${java.library.path}"/>
    <pathelement location="${star.jar.dir}/${os.arch}"/>
  </path>
  <property name="tests-libpath" refid="tests-libpath.id"/>

  <!--
   !    ===============
   !    Extension tasks
   !    ===============
   !    Add any local or extension ANT tasks that are required. Local
   !    tasks should be moved into the ANT package if used outside of this
   !    package. 
   !-->
  <taskdef resource="axis-tasks.properties" classpathref="classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !
   !    Minimalist check of the required dependencies so that the build will
   !    not proceed if some basic dependencies are not present on the
   !    classpath. Optional components could also be checked here.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!-- AXIS -->
    <available property="axis.present"
               classpathref="classpath"
               classname="org.apache.axis.client.Service"/>
    <fail message="No AXIS available" unless="axis.present"/>

    <!-- UTIL -->
    <available property="util.present"
               classpathref="classpath"
               classname="uk.ac.starlink.util.CgiQuery"/>
    <fail message="No UTIL available" unless="util.present"/>

    <!-- TABLE -->
    <available property="table.present"
               classpathref="classpath"
               classname="uk.ac.starlink.table.StarTable"/>
    <fail message="No TABLE available" unless="table.present"/>

    <!-- VOTABLE -->
    <available property="votable.present"
               classpathref="classpath"
               classname="uk.ac.starlink.votable.VOElementFactory"/>
    <fail message="No VOTABLE available" unless="votable.present"/>
 
    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">
    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">
      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <!-- <compilerarg value="-Xlint:unchecked"/> -->
      <classpath refid="classpath"/>
      <include name="**/*.java"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${src.dir}/resources"/>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>

    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib.pkg}" includes="*.jar"/>
    </signjar>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this class library.
     !   This goes into "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">

      <information>
         <title>VO - Classes for access to some VO services</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink VO - Webstart edition"</description>
         <offline_allowed/>
       </information>

       <security>
          <all_permissions/>
       </security>

       <resources>
         <j2se version="1.5+"/>

         <!-- Define the library jar files -->
         <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>

         <!-- Name any extension packages we directly depend on -->
         <extension name="RAYREG" href="rayreg.jnlp"/>
         <extension name="REGISTRY" href="registry.jnlp"/>
         <extension name="AXIS" href="axis.jnlp"/>
         <extension name="UTIL" href="util.jnlp"/>
         <extension name="TABLE" href="table.jnlp"/>
         <extension name="VOTABLE" href="votable.jnlp"/>

       </resources>

       <!-- This is a component -->
       <component_desc/>

     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin.pkg}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <mkdir dir="${dist.etc.pkg}"/>

    <!-- Copy any configuration/helper scripts etc. -->
 <!--
    <copy todir="${dist.bin}">
      <fileset dir="${script.dir}/" />
    </copy>
 -->

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
 <!--
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>
 -->

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin.pkg}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.etc.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory-->
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <mkdir dir="${dist.etc.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >
      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests, run-normal-tests, run-net-tests"
          if="junit.present"/>

  <target name="run-normal-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <sysproperty key="basedir" value="${basedir}"/>
      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test.java"/>
          <exclude name="**/*NetTest.java"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  

  <!--
   !  Runs network-based testcases; currently a no-op unless 
   !  the tests.withnet system property is set.  This is so that the standard
   !  test target can be invoked without error in the absence of network
   !  connections.
   !-->
  <target name="run-net-tests"
          depends="compile-tests"
          if="tests.withnet">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <sysproperty key="http.proxyHost" value="${http.proxyHost}"/>
      <sysproperty key="http.proxyPort" value="${http.proxyPort}"/>
      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*NetTest.java*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <sysproperty key="http.proxyHost" value="${http.proxyHost}"/>
      <sysproperty key="http.proxyPort" value="${http.proxyPort}"/>

      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   VOTable build file
 !
 !   This file describes how to build and install VOTable from
 !   source and binary releases. VOTable is a class library
 !   (i.e. provides an API and related documentation).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for VOTable" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" 
            value="http://java.sun.com/j2se/${java.specification.version}/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="VOTable"/>
  <property name="name" value="votable"/>
  <property name="version" value="2.0"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.votable"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.5"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="true"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Any achitecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase" 
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- {Other packages} -->
    <pathelement location="${star.jar.dir}/table/table.jar"/>
    <pathelement location="${star.jar.dir}/util/util.jar"/>
    <pathelement location="${star.jar.dir}/tamfits/tamfits.jar"/>

  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <extclasspath id="built.jarpath">

    <pathelement location="${star.build.dir}/table/lib/table/table.jar"/>
    <pathelement location="${star.build.dir}/util/lib/util/util.jar"/>
    <pathelement location="${star.build.dir}/tamfits/lib/tamfits/tamfits.jar"/>

  </extclasspath>

  <path id="built.classpath">

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property
   !   "extra.class.path" (which can be defined locally using say
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath, add tests.dir and tests.etc.dir so that
   !   resources may be located there -->
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!--  Table -->
    <available property="table.present"
               classpathref="classpath"
               classname="uk.ac.starlink.table.StarTable"/>
    <fail message="No Table available" unless="table.present"/>

    <!--  Util -->
    <available property="util.present"
               classpathref="classpath"
               classname="uk.ac.starlink.util.URLUtils"/>
    <fail message="No Util available" unless="util.present"/>

    <!--  TAMFITS -->
    <available property="tamfits.present"
               classpathref="classpath"
               classname="nom.tam.fits.Fits"/>
    <fail message="No TAMFITS available" unless="tamfits.present"/>

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here. 
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
      <exclude name="**/{Retired1.java}"/>
      <exclude name="**/{Retired2.java}"/>
      <exclude name="**/*.html"/>
      <exclude name="**/*.properties*"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
<!-- 
    <copy todir="${build.classes}">
      <fileset dir="${src.dir}/resources"/>
    </copy>
  -->

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>VOTable</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink VOTable - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="${name}/${name}.jar"/>
         <extension name="TABLE" href="table.jnlp"/>
         <extension name="UTIL" href="util.jnlp"/>
       </resources>
       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
    <!--
      <copy todir="${dist.docs.pkg}">
        <fileset dir="${src.docs}"/>
      </copy>
    -->

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
    <!--
      <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
         <fileset dir="${dist.bin}"/>
      </chmod>
    -->

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <!--<zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>-->
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <!--<zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>-->

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <!--<tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>-->
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <!--<tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>-->

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
    <!--
      <loggedcopy todir="${star.bin}"
                  logfile="${install.log}"
                  overwrite="${install.overwrite}"
                  logfileAppend="false">
        <fileset dir="${dist.bin}"/>
      </loggedcopy>

      <chmod perm="ugo+rx" failonerror="${chmod.fail}">
        <fileset dir="${star.bin}">
          <present targetdir="${dist.bin}" present="both"/>
        </fileset>
      </chmod>
    -->

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory-->
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>


  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="tests-classpath"/>

    </javac>

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test.java"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
<?xml version="1.0"?>

<!--
 !   XDOC build file
 !
 !   This file describes how to build and install XDOC from
 !   source and binary releases. XDOC is a class library
 !   (i.e. provides an API and related documentation).
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> installs the distribution
 !      install-runonly  -> installs a runonly distribution
 !      jars             -> creates the package jar file(s)
 !      javadocs         -> creates the package API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      test             -> runs JUnit test cases
 !
 !   Authors:
 !      Peter W. Draper (17-SEP-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for XDOC" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://java.sun.com/j2se/1.5.0/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="XDOC"/>
  <property name="name" value="xdoc"/>
  <property name="version" value="0.1"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.xdoc"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.5"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>
  <property name="junit.assertions" value="-enableassertions"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing any JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Any achitecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase"
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Installed jar files.
   !
   !   Name all the installed jar files of other packages that we depend on.
   !
   !   When compiling under Java 1.4 these will be used to produce a full
   !   classpath that is equivalent to that generated when these are
   !   referenced as optional bundled packages by the JVM.
   !   When compiling under Java 1.5 (and probably later) this is just
   !   a simple path of these jar files, as the expansion to a full optional
   !   bundled package classpath is performed by the compiler
   !
   !   What that all means is that the manifest classpaths of these jar files
   !   are honoured, the plain compiler pre Java 1.5 didn't do that. When Java
   !   1.4 is no longer used the extclasspath type can be replaced by a simple
   !   path.
   !-->
  <extclasspath id="installed.classpath">

    <!-- {Other packages} -->
<!--
    <pathelement location="${star.jar.dir}/{package1}/{package1.jar}"/>
-->
  </extclasspath>

  <!-- Local build system jar files.
   !
   !   Name all the jar files of other packages that we depend on, which have
   !   not been installed (should be same packages as in installed.classpath).
   !-->
  <extclasspath id="built.jarpath">

<!--
    <pathelement
       location="${star.build.dir}/{package1}/lib/{package1}/{package1.jar}"/>
-->
  </extclasspath>

  <!-- Find all local third party jars files.
   !
   !   Normally these will be kept in their own third party package, but may
   !   be kept here temporarily, say if there are version conflicts that
   !   cannot be addressed. They are installed with the package jar files and
   !   should be entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  </path>

  <!-- Create the local build system CLASSPATH.
   !
   !   Create the classpath used when building this package as part of a full
   !   build system without any dependency on any installed or external jar
   !   files.
   !
   !   Classes compiled in the local build tree will be in the "build/classes"
   !   part of each package. Third party packages, have do not have any source
   !   code, just jar files, will have their jar files in their "dist"
   !   directories (usually lib/{package_name}).
   !
   !   So the full built classpath is created by constructing a path
   !   consisting of:
   !
   !      - all third party jar files in this package
   !      - all build/classes directories in the local build system (these
   !        will have the most recent class files)
   !      - all jar files named in built.jarpath, i.e. named local build
   !        system jar files (these can be normal packages in the "dist" state
   !        or third party packages)
   !      - all jar files in the "dist" directories of all packages in the
   !        local build system (these are necessary to make sure that the jar
   !        files in the previous part have their dependencies fulfilled,
   !        without having them all installed)
   !-->
  <path id="built.classpath">

    <!-- Third party jars held by this package -->
    <path refid="package.jars"/>

    <!-- All classes in the local build system -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent jars in the local build system -->
    <path refid="built.jarpath"/>

    <!-- All "dist" jar files to make sure everything is resolved, including
     !   relative URLs of the local packages, without installation -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

  </path>

  <!-- User-defined CLASSPATH.
   !
   !   This is set by the property "extra.class.path" (which can be defined
   !   locally using say -Dextra.class.path=$CLASSPATH on the command line
   !   or by setting the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Create the full CLASSPATH used during compilation.
   !
   !   This is created from the user-defined classpath, followed by the
   !   classpath for building against the local system, followed by the
   !   classpath for building against an installed system.
   !-->
  <path id="classpath">
     <path refid="local.classpath"/>
     <path refid="built.classpath"/>
     <path refid="installed.classpath"/>
  </path>

  <!-- Create the JUnit tests CLASSPATH.
   ! 
   !   Note that in addition to the build/classes and build/tests directory
   !   we also add tests.dir and tests.etc.dir so that resources may be
   !   located there. The full classpath is also used.
   !-->  
 <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    ============
   !    Library path
   !    ============
   !    Used by test targets for locating native libraries.
   !-->
  <path id="tests-libpath.id">
    <pathelement path="${java.library.path}"/>
    <pathelement location="${star.jar.dir}/${os.arch}"/>
  </path>
  <property name="tests-libpath" refid="tests-libpath.id"/>

  <!--
   !    ===============
   !    Extension tasks
   !    ===============
   !    Add any local or extension ANT tasks that are required. Local
   !    tasks should be moved into the ANT package if used outside of this
   !    package. 
   !-->
  <taskdef resource="axis-tasks.properties" classpathref="classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !
   !    Minimalist check of the required dependencies so that the build will
   !    not proceed if some basic dependencies are not present on the
   !    classpath. Optional components could also be checked here.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!--  {Example package1} -->
<!--
    <available property="{package1}.present"
               classpathref="classpath"
               classname="uk.ac.starlink.{package1}.{MainClass}"/>
    <fail message="No {package1} available" unless="{package1}.present"/>
-->

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images and property files) should also be
   !  copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages"
          unless="runonly.install"
          description="-> compiles the source code">

    <mkdir dir="${build.classes}"/>
    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           source="${source.version}"
           optimize="${optimize}">

      <compilerarg value="-proc:none" compiler="javac1.6"/>
      <classpath refid="classpath"/>

      <!-- Exclude any files in the source tree that should not be
       !   compiled -->
      <exclude name="**/{Retired1.java}"/>
      <exclude name="**/{Retired2.java}"/>
      <exclude name="**/*.html"/>
      <exclude name="**/*.properties*"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/{package.support.files}"/>
        <include name="**/{more.package.support.files}"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}"/>
    </copy>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs). The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file(s)">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Sign all jar files -->
    <signjar jar="${dist.lib.pkg}/${name}.jar"
             alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}"/>

  </target>

  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this class library.
     !   This goes into "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">

      <information>
         <title>{Package} - {description}</title>
         <vendor>Starlink UK</vendor>
         <homepage href="${home.page}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink {Package} - Webstart edition"</description>
         <offline_allowed/>
       </information>

       <security>
          <all_permissions/>
       </security>

       <resources>
         <j2se version="1.5+"/>

         <!-- Define the main library jar file -->
         <jar href="${name}/${name}.jar"/>

         <!-- Name any extension packages we directly depend on -->
         <extension name="{EXT1}" href="{ext1}.jnlp"/>
         <extension name="{EXT2}" href="{ext2}.jnlp"/>
       </resources>

       <!-- This is a component -->
       <component_desc/>

     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <mkdir dir="${dist.etc.pkg}"/>

    <!-- Copy any configuration/helper scripts etc. -->
<!--
    <mkdir dir="${dist.bin.pkg}"/>
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}/" />
    </copy>
-->

    <copy todir="${dist.etc.pkg}">
      <fileset dir="${src.dir}/etc"/>
    </copy>

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>
<!--
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}">
       <fileset dir="${dist.bin}"/>
    </chmod>
 -->

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>

    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> installs distribution">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin.pkg}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.etc.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <!-- Note: if you uncomment any of the following (reasonable since
     !   the class library may not have any scripts), then make sure
     !   that the first loggedcopy has logfileAppend="false" so that
     !   the copy logfile is initialised -->
<!--
    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>
-->

    <loggedcopy todir="${star.etc}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.etc}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.etc.pkg}
</echo>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory-->
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <mkdir dir="${dist.etc.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  Create documentation from the Java sources. Additional
   !  documentation is kept in the ${src.docs} directory.
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             defaultexcludes="yes"
             source="${source.version}"
             classpathref="classpath">

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =========================================
   !   Makes the API java source files available
   !   =========================================
   !
   !  The full API documentation is created from all the various
   !  packages (of which this package is just one). This target makes
   !  the source code that should be used in the full public API
   !  available in a special part of the build tree so that it can be
   !  automatically discovered. This method works around two potential
   !  problems, not all source code the in src/main directories should be
   !  in the API docs, and it's not possible to make this distinction
   !  easily outside this package (cannot pass out a fileset), plus
   !  some code is generated, so cannot be located by scanning the
   !  src/main tree. When javadocs can be generated incrementally this
   !  arrangement should be reworked to generate whatever is needed as
   !  part of the javadocs target.
   !-->
  <target name="javadoc-sources"
          description="-> make source files for release API documention">

    <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->
    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
          <exclude name="**/README"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">

<!--
    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           source="${source.version}"
           deprecation="${deprecation}" >

      <classpath refid="tests-classpath"/>

    </javac>
-->

  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">
<!--

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">

      <classpath refid="tests-classpath"/>

      <jvmarg value="${junit.assertions}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="brief" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/JUnit*"/>
        </fileset>
      </batchtest>

    </junit>
-->

  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">

      <sysproperty key="hdx.home" value="${hdx.home}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.library.path" value="${tests-libpath}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>
      <classpath refid="tests-classpath"/>
      <jvmarg value="${junit.assertions}"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>

    </junit>

  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
